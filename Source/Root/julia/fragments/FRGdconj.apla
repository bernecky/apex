'% SAC Code fragments for dyadic conjunctions, such as x +.* y',(⎕UCS 10),'% Robert Bernecky 2007-05-08',(⎕UCS 10 10),'% ALL code requires checks for length error!! rbe 2005-09-05',(⎕UCS 10 10),'% For the non-trivial cases of inner product, we',(⎕UCS 10),'% define several algorithms, roughly in order of decreasing best-case',(⎕UCS 10),'% performance on x f.g y:',(⎕UCS 10),'%',(⎕UCS 10),'%  STAR:   performs z[i;]<- z[i;] f x[i;j] g y[j;]',(⎕UCS 10),'%               This fetches each x-element exactly once, so it',(⎕UCS 10),'%               saves type-coercion time on x. It also operates',(⎕UCS 10),'%               in scalar-vector mode on g, stride-1, and in',(⎕UCS 10),'%               vector-vector mode on f, also stride-1. The first',(⎕UCS 10),'%               iteration can be peeled to initialize each row of z,',(⎕UCS 10),'%               or z can be initialized to the identity element for f.',(⎕UCS 10),'%  ',(⎕UCS 10),'%                Furthermore, we can use knowledge of f and g to ',(⎕UCS 10),'%              eliminate the above iteration step any time that:',(⎕UCS 10),'%             x[i;j] g anything',(⎕UCS 10),'%             produces a left identity for f. E.g., in x OR.AND y,',(⎕UCS 10),'%               if x[i;j] is zero, then:',(⎕UCS 10),'%                   x[i;j] AND  y[j;] ',(⎕UCS 10),'%          is all zeros, and since zero is an identity element ',(⎕UCS 10),'%               for f (OR), then the above computation step does not',(⎕UCS 10),'%               affect the final result, so it can be ignored.',(⎕UCS 10),'%               This also helps plain, old PLUS.TIMES, when the left',(⎕UCS 10),'%               argument has a lot of zeros. See Robert Bernecky''s MSc',(⎕UCS 10),'%               thesis (APEX) for more details.',(⎕UCS 10),'%',(⎕UCS 10),'%                A typical use would be using OR.AND to compute a ',(⎕UCS 10),'%             transitive closure step in a Boolean graph.',(⎕UCS 10),'%',(⎕UCS 10),'%         STARLIKE: ',(⎕UCS 10),'%            Same as STAR, except that if x[i;j] is an identity',(⎕UCS 10),'%            for g, we skip the scalar-vector computation of:',(⎕UCS 10),'%                      x[i;j] g y[j;]',(⎕UCS 10),'%                and merely reduce y[j;] into the result:',(⎕UCS 10),'%                      z[i;]<-z[i;] f y[j;]',(⎕UCS 10),'%',(⎕UCS 10),'%        QUICKSTOP0, QUICKSTOP1:',(⎕UCS 10),'%               These algorithms are a special case of TRANSPOSE,',(⎕UCS 10),'%             except that the vector-vector dot product of a result element',(⎕UCS 10),'%               will stop short when one of the computations on g',(⎕UCS 10),'%               produces a result that fixes the result of f on that',(⎕UCS 10),'%          element. The most common example of this is:',(⎕UCS 10),'%                  z<-x AND.EQUALS y',(⎕UCS 10),'%             typically on text matrices. If any character x[i;k]',(⎕UCS 10),'%           does not match its corresponding character y[k;j], ',(⎕UCS 10),'%           then the result element z[i;k] must be zero, so ',(⎕UCS 10),'%              further computation of that result element halts.',(⎕UCS 10),'%             The algorithms differ only in their halting criteria',(⎕UCS 10),'%          being zero or one. There may be room for more general',(⎕UCS 10),'%                 halting values, but I couldn''t think of one in more',(⎕UCS 10),'%           than 30 seconds of thought.',(⎕UCS 10),'%',(⎕UCS 10),'%         TRANSPOSE: ',(⎕UCS 10),'%           This is the most generic case. ',(⎕UCS 10),'%               It merely transposes the right argument before',(⎕UCS 10),'%                performing the classical linear algebra algorithm.',(⎕UCS 10),'%            This makes the repeated accesses to the right argument',(⎕UCS 10),'%                stride-1 (after the transpose, anyway).',(⎕UCS 10),'% ',(⎕UCS 10 10),'%Fragment dot 000 bidc bidc bidc .',(⎕UCS 10),'%Fragment dot 000 bidc bidc bidc STAR',(⎕UCS 10),'%Fragment dot 000 bidc bidc bidc TRANSPOSE',(⎕UCS 10),'inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE y$SYSVARFGDECL)',(⎕UCS 10),'{ /* Scalar-Scalar inner product */ ',(⎕UCS 10),'  z =  $FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'} ',(⎕UCS 10),'%Generate , $FRVALUE, $CT$XT$GZT, 000, ., $CT',(⎕UCS 10 10),'%Fragment dot 010 bidc bidc bidc .',(⎕UCS 10),'%Fragment dot 010 bidc bidc bidc STAR',(⎕UCS 10),'%Fragment dot 010 bidc bidc bidc TRANSPOSE',(⎕UCS 10),'inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE[.] y$SYSVARFGDECL)',(⎕UCS 10),'{ /* Scalar-Vector inner product */ ',(⎕UCS 10),'  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'} ',(⎕UCS 10),'%Generate , $FRVALUE, $XT$CT$GCT, 011, ., $CT',(⎕UCS 10),'%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT',(⎕UCS 10 10),'%Fragment dot 100 bidc bidc bidc .',(⎕UCS 10),'%Fragment dot 100 bidc bidc bidc STAR',(⎕UCS 10),'%Fragment dot 100 bidc bidc bidc TRANSPOSE',(⎕UCS 10),'inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE y$SYSVARFGDECL)',(⎕UCS 10),'{ /* Vector-Scalar inner product */ ',(⎕UCS 10),'  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'} ',(⎕UCS 10),'%Generate , $FRVALUE, $CT$CT$GZT, 101, ., $CT',(⎕UCS 10),'%Generate $FNM,   sl,      X$GZT$ZT,   X10, $SPECRED, $CT',(⎕UCS 10 10),'%Fragment dot 110 bidc bidc bidc .',(⎕UCS 10),'%Fragment dot 110 bidc bidc bidc STAR',(⎕UCS 10),'%Fragment dot 110 bidc bidc bidc TRANSPOSE',(⎕UCS 10),'inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE[.] y$SYSVARFGDECL)',(⎕UCS 10),'{ /* Vector-Vector inner product */ ',(⎕UCS 10),'  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'} ',(⎕UCS 10),'%Generate , $FRVALUE, $CT$CT$GZT, 111, ., $CT',(⎕UCS 10),'%Generate $FNM,         sl,      X$GZT$ZT,   X10, $SPECRED, $GZT',(⎕UCS 10 10),'%Fragment dot 0** bidc bidc bidc .',(⎕UCS 10),'%Fragment dot 0** bidc bidc bidc TRANSPOSE',(⎕UCS 10),'inline $ZTYPE[*] $FNAME$IPALG($XTYPE x, $YTYPE[*] y$SYSVARFGDECL)',(⎕UCS 10),'{ /* TRANSPOSE case of inner product z = scalar f.g y */',(⎕UCS 10),' yt = to$GCT(TRANSPOSE(y));',(⎕UCS 10),' xct = to$GCT(x);',(⎕UCS 10),' shp = drop([-1], shape(yt));',(⎕UCS 10),' z = with {',(⎕UCS 10),'     (. <= iv <= .) {',(⎕UCS 10),'               vy = yt[iv];',(⎕UCS 10),'    } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(xct,vy$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),'       } : genarray(shp, $OTFILL);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT',(⎕UCS 10),'%Generate ,     $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT',(⎕UCS 10),'%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT',(⎕UCS 10 10),'%Fragment dot *0* bidc bidc bidc .',(⎕UCS 10),'%Fragment dot *0* bidc bidc bidc STAR',(⎕UCS 10),'%Fragment dot *0* bidc bidc bidc TRANSPOSE',(⎕UCS 10),'inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE y$SYSVARFGDECL)',(⎕UCS 10),'{ /* Inner product z =  f.g scalar-y */',(⎕UCS 10),' shp = drop([-1], shape(x));',(⎕UCS 10),' z = with {',(⎕UCS 10),'       (. <= iv <= .) {',(⎕UCS 10),'       } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(to$GCT(x[iv]),to$GCT(y)$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),'       } : genarray(shp, $OTFILL);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate ,   $FRVALUE, $GCT$GCT$GZT, 101, ., $GCT',(⎕UCS 10),'%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT',(⎕UCS 10 10 10),'%Fragment dot 1** bidc bidc bidc TRANSPOSE',(⎕UCS 10),'inline $ZTYPE[*] $FNAME$IPALG($XTYPE[.] x, $YTYPE[*] y$SYSVARFGDECL)',(⎕UCS 10),'{ /* TRANSPOSE case of inner product z = vector_f.g y */',(⎕UCS 10),' yt = to$GCT(TRANSPOSE(y));',(⎕UCS 10),' xct = to$GCT(x);',(⎕UCS 10),' /* if (1 != shape(xct)[[0]]) FIXME; length error check */',(⎕UCS 10),' ',(⎕UCS 10),' shp = drop([-1],shape(xct)) ++ drop([1], shape(y));',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .) {',(⎕UCS 10),'               vx = xct[take([dim(x)-1], iv)];',(⎕UCS 10),'                vy = yt[ reverse(take([1-dim(y)], iv))];',(⎕UCS 10),'       } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),'         } :genarray(shp, $OTFILL);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate ,    TRANSPOSE, X$YT$YT, X**, ., $YT',(⎕UCS 10),'%Generate ,     $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT',(⎕UCS 10),'%Generate $FNM, sl, X$GZT$ZT,   X10, $SPECRED, $GZT',(⎕UCS 10 10),'%Fragment dot *1* bidc bidc bidc STAR',(⎕UCS 10),'%Fragment dot *2* bidc bidc bidc STAR',(⎕UCS 10),'inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)',(⎕UCS 10),'{ /* CDC STAR-100 APL Algorithm for inner product */',(⎕UCS 10),'  ',(⎕UCS 10),' /* This computes, for z=x f.g y,',(⎕UCS 10),'  *          z[i;] = z[i;]f x[i;j]g y[j;]',(⎕UCS 10),'  *  Thus, it runs stride-1, and we only fetch left argument',(⎕UCS 10),'  *  elements once. It includes skipping a g row iteration and',(⎕UCS 10),'  *  an f row-reduce iteration when x[i;j] generates an identity for f.',(⎕UCS 10),'  *  R. Bernecky 2005-11-24',(⎕UCS 10),'  */',(⎕UCS 10),'  rowsx = drop([-1],shape(x));',(⎕UCS 10),'  colsx = shape(x)[[dim(x)-1]];',(⎕UCS 10),'  colsy = shape(y)[[dim(y)-1]];',(⎕UCS 10),'  Zrow = genarray([colsy],$OTFILL);',(⎕UCS 10),'  /* Parallel over rows of x */',(⎕UCS 10),'  z = with {',(⎕UCS 10),'    (. <= [row] <= .) {',(⎕UCS 10),'       Crow = Zrow;',(⎕UCS 10),'       for (colx=0; colx<colsx; colx++) {',(⎕UCS 10),'         xel = x[row,colx];',(⎕UCS 10),'         xel = to$GCT(xel);',(⎕UCS 10),'         if (to$GCT($FGID) != xel) { /* Skip iteration if it''s an identity */',(⎕UCS 10),'           VEC = $FRVALUE$GCT$GCT$GZT(xel,to$GCT(y[[colx]])$SYSVARGKER);',(⎕UCS 10),'           Crow = $FNM$ZT$ZT$ZT( Crow, to$CT(VEC)$SYSVARFKER);',(⎕UCS 10),'         }',(⎕UCS 10),'       }',(⎕UCS 10),'     } : Crow;',(⎕UCS 10),'  } : genarray( rowsx, Zrow);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT',(⎕UCS 10),'%Generate , $FNM,         $ZT$ZT$ZT,  111 , ., $CT',(⎕UCS 10 10),'%Fragment dot *1* bidc bidc bidc STARLIKE',(⎕UCS 10),'%Fragment dot *2* bidc bidc bidc STARLIKE',(⎕UCS 10),'inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)',(⎕UCS 10),'{ /* CDC STAR-100 APL Algorithm for inner product */',(⎕UCS 10),' /* This computes, for z=x f.g y,',(⎕UCS 10),'  *            z[i;] = z[i;]f x[i;j]g y[j;]',(⎕UCS 10),'  *  Thus, it runs stride-1, and we only fetch left argument',(⎕UCS 10),'  *  elements once. STARLIKE is similar to dotSTAR, except that:',(⎕UCS 10),'  *   1. "f" is such that we can''t avoid the reduce step. ',(⎕UCS 10),'  *   2. "x[i;j] f" is such that it may produce an identity on y[j;].',(⎕UCS 10),'  *      If so, we don''t apply f to that row.',(⎕UCS 10),'  *  R. Bernecky 2005-11-24',(⎕UCS 10),'  */',(⎕UCS 10),'  rowsx = drop([-1],shape(x));',(⎕UCS 10),'  colsx = shape(x)[[dim(x)-1]];',(⎕UCS 10),'  colsy = shape(y)[[dim(y)-1]];',(⎕UCS 10),'  Zrow = genarray([colsy],$OTFILL);',(⎕UCS 10),'  /* Parallel over rows of x */',(⎕UCS 10),'  z = with {',(⎕UCS 10),'    (. <= [row] <= .) {',(⎕UCS 10),'      Crow = Zrow;',(⎕UCS 10),'      for (colx=0; colx<colsx; colx++) {',(⎕UCS 10),'        xel = x[row,colx];',(⎕UCS 10),'        xel = to$GCT( xel);',(⎕UCS 10),'        if (to$GCT($FGID) != xel) { /* Skip iteration if it''s an f identity */',(⎕UCS 10),'          Crow = $FNM$ZT$ZT$ZT( Crow, to$CT( y[colx])$SYSVARFKER);',(⎕UCS 10),'        }',(⎕UCS 10),'      }',(⎕UCS 10),'    } : Crow;',(⎕UCS 10),'  }: genarray( rowsx, Zrow);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , $FNM,    $ZT$ZT$ZT,  111 , ., $CT',(⎕UCS 10 10),'%Fragment dot *** bidc bidc bidc QUICKSTOP0',(⎕UCS 10),'inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)',(⎕UCS 10),'{ /* QUICKSTOP0 case of inner product z = matrix f.g matrix */',(⎕UCS 10),'  /* The reduction quick-stops if any of its results are zero */',(⎕UCS 10),'  /* E.g., char ^.= char */',(⎕UCS 10 10),' yt = to$GCT(TRANSPOSE(y));',(⎕UCS 10),' xct = to$GCT(x);',(⎕UCS 10),' shp = drop([-1],shape(x)) ++ drop([1], shape(y));',(⎕UCS 10),' z = with {',(⎕UCS 10),'   (. <= iv <= .) {',(⎕UCS 10),'      vx = xct[take([dim(x)-1], iv)];',(⎕UCS 10),'      vy = yt[ reverse(take([1-dim(y)], iv))];',(⎕UCS 10),'    } : $FNMslX$GZT$ZTQUICKSTOP($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),' } : genarray(shp, $OTFILL);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate ,       TRANSPOSE, X$YT$YT, X**, ., $YT',(⎕UCS 10),'%Generate , $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT',(⎕UCS 10),'%Generate $FNM,        sl,      X$GZT$ZT,   X10, QUICKSTOP, $ZT',(⎕UCS 10 10),'%Fragment dot *** bidc bidc bidc TRANSPOSE',(⎕UCS 10),'%Fragment dot *** bidc bidc bidc STAR',(⎕UCS 10),'%Fragment dot *** bidc bidc bidc .',(⎕UCS 10),'inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)',(⎕UCS 10),'{ /* Generic case of inner product z = x f.g y */',(⎕UCS 10),' yt = to$GCT(TRANSPOSE(y));',(⎕UCS 10),' xct = to$GCT(x);',(⎕UCS 10),' shp = drop([-1],shape(x)) ++ drop([1], shape(y));',(⎕UCS 10),' z = with {',(⎕UCS 10),'   (. <= iv <= .) {',(⎕UCS 10),'     vx = xct[take([dim(x)-1], iv)];',(⎕UCS 10),'     vy = yt[ reverse(take([1-dim(y)], iv))];',(⎕UCS 10),'   } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);',(⎕UCS 10),' } : genarray(shp, $OTFILL);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate ,       TRANSPOSE, X$YT$YT, X**, ., $YT',(⎕UCS 10),'%Generate ,     $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT',(⎕UCS 10),'%Generate $FNM, sl      , X$GZT$ZT,   X10, $SPECRED, $GZT',(⎕UCS 10 10)
