('% SAC Code fragments for monadic upgrade, downgrade',(⎕UCS 10),'% Robert Bernecky 2006-11-09',(⎕UCS 10 10 10),'%Fragment ugrd x11 x b i .      Vector upgrade on Booleans',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)',(⎕UCS 10),'{ /* Upgrade of boolean-valued vector */',(⎕UCS 10),'  /* ((~y)/iota rho y),y/iota rho y */',(⎕UCS 10),'  /* Model upgradeBV2 from workspace 42 upgrade: rbe/2005-12-11 */',(⎕UCS 10),'/*',(⎕UCS 10),'        z{<-}upgradeBV2 bv;s;n0;n1;i',(⎕UCS 10),'        @ upgrade boolean vector',(⎕UCS 10),'        s{<-}+/bv',(⎕UCS 10),'        z{<-}({rho}bv){rho}{neg}1',(⎕UCS 10),'        n0{<-}0',(⎕UCS 10),'        n1{<-}({rho}bv)[0]-s',(⎕UCS 10),'        :for i :in {iota}{rho}bv',(⎕UCS 10),'         :if ~bv[i]',(⎕UCS 10),'          z[n0]{<-}i',(⎕UCS 10),'          n0{<-}n0+1',(⎕UCS 10),'         :else',(⎕UCS 10),'          z[n1]{<-}i',(⎕UCS 10),'          n1{<-}n1+1',(⎕UCS 10),'         :endif',(⎕UCS 10),'        :endfor',(⎕UCS 10),'*/',(⎕UCS 10 10),' s = sum(toi(y));',(⎕UCS 10),' shpy = shape(y)[[0]];',(⎕UCS 10),' z = genarray(shape(y),-1);',(⎕UCS 10),' n0 = 0;',(⎕UCS 10),' n1 = shpy-s;',(⎕UCS 10),' for(i=0; i<shpy; i++){',(⎕UCS 10),'   if (false == toB(y[[i]]))',(⎕UCS 10),'        {z[[n0]] = i; n0++;}',(⎕UCS 10),'   else',(⎕UCS 10),'        {z[[n1]] = i; n1++;}',(⎕UCS 10),' }',(⎕UCS 10),' return(z+QUADio);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , iota, XII, X01, ., I ',(⎕UCS 10 10),'%Fragment dgrd x11 x b i .      Vector downgrade on Booleans',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)',(⎕UCS 10),'{ /* Downgrade of boolean vector. */',(⎕UCS 10),'  /* (y/iota rho y),(~y)/iota rho y */',(⎕UCS 10),'  /* See APL model downgradeBV2 in workspace 42 upgrade',(⎕UCS 10),'   * R. Bernecky 2005-11-04',(⎕UCS 10),'   */',(⎕UCS 10),' s = sum(toi(y));',(⎕UCS 10),' z = genarray(shape(y),-1);',(⎕UCS 10),' shpy = shape(y)[[0]];',(⎕UCS 10),' n0 = shpy-1;',(⎕UCS 10),' n1 = s-1;',(⎕UCS 10),' for(i=shpy-1; i>=0; i--)',(⎕UCS 10),'   if (false == toB(y[[i]]))',(⎕UCS 10),'        {z[[n0]] = i; n0--;}',(⎕UCS 10),'   else',(⎕UCS 10),'        {z[[n1]] = i; n1--;}',(⎕UCS 10),' return(z+QUADio); ',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment ugrd x11 x bi i PV   Vector upgrade of permutation vector',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)',(⎕UCS 10),'{ /* Upgrade of permutation vector. */',(⎕UCS 10),'  /* This exploits array predicate astPredPV */',(⎕UCS 10),'  z = genarray(shape(y), -1);',(⎕UCS 10),'  for( i=0; i<shape(y)[0]; i++) {',(⎕UCS 10),'        z[[y[[i]]]] = i+QUADio;',(⎕UCS 10),'  }',(⎕UCS 10),' return(z); ',(⎕UCS 10),'}',(⎕UCS 10 10 10),'%Fragment dgrd x11 x bi i  PV downgrade on permutation vector',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)',(⎕UCS 10),'{ /* Downgrade of permutation vector. */',(⎕UCS 10),'  /* This exploits array predicate astPredPV */',(⎕UCS 10),'  z = genarray(shape(y), -1);',(⎕UCS 10),'  size = shape(y)[0];',(⎕UCS 10),'  for( i=0; i<size; i++) {',(⎕UCS 10),'        z[[(size-1)-y[[i]]]] = i+QUADio;',(⎕UCS 10),'  }',(⎕UCS 10),' return(z); ',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment ugrd x11 x i i    .  ',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)',(⎕UCS 10),'{ /* Integer vector upgrade  ',(⎕UCS 10),'   * See radix upgrade model in ws RadixGrade.dws',(⎕UCS 10),'   */',(⎕UCS 10),'  rad = 256;',(⎕UCS 10),'  radixbase = 8; /* 2 log rad */',(⎕UCS 10),'  bitsperint = 32;',(⎕UCS 10),'  numpasses = bitsperint/8;',(⎕UCS 10),'  hist = RadixGradeHistograms( y);',(⎕UCS 10),'  z = genarray( shape(y), -1);',(⎕UCS 10),'  if( 0 != shape(y)[0]) {',(⎕UCS 10),'    pv = iota(shape(y)[0]);',(⎕UCS 10),'    /* LSB-> MSB sort order */',(⎕UCS 10),'    for( pas=numpasses-1; pas>=0; pas--) {',(⎕UCS 10),'      /* Skip pass if all nums in same bucket */',(⎕UCS 10),'      if( shape(y)[0] != hist[pas, RadixGradeGetIdx( pas, y[pv[0]])]) {',(⎕UCS 10),'        pvo = RadixGradeOffsets( rad, pas, hist);',(⎕UCS 10),'        for( i=0; i<shape(y)[0]; i++) {',(⎕UCS 10),'          val = RadixGradeGetIdx( pas, y[pv[i]]);',(⎕UCS 10),'          z[pvo[val]] = pv[i];',(⎕UCS 10),'          pvo[val] =  pvo[val] + ((val<0) ? -1 : 1); ',(⎕UCS 10),'        }',(⎕UCS 10),'        pv = z;',(⎕UCS 10),'      }',(⎕UCS 10),'    }',(⎕UCS 10),'  }',(⎕UCS 10),'  z = QUADio + z; ',(⎕UCS 10),'  return( z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , RadixGradeHistograms, X$YTI, X11, .,',(⎕UCS 10),'%Generate , RadixGradeOffsets, X$YTI, X11, .,',(⎕UCS 10),'%Generate , RadixGradeGetIdx, X$YTI, X00, .,',(⎕UCS 10 10),'%Fragment ugrd x** x bidc i    .  ',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($YTYPE[+] y, int QUADio)',(⎕UCS 10),'{ /* Vector/matrix upgrade  */',(⎕UCS 10),' z = QUADio + UpgradeHeap(y); ',(⎕UCS 10),' return( z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , UpgradeHeap, X$YTI, X**, ., $CT',(⎕UCS 10 10),'%Fragment UpgradeHeap x** x bidc i    .  internal matrix upgrade',(⎕UCS 10),'inline $ZTYPE[.] UpgradeHeap($YTYPE[+] y)',(⎕UCS 10),'{ ',(⎕UCS 10),'/*    Do APL upgrade of array y using heapsort.',(⎕UCS 10),'      This is a sub-function shared by upgrade/downgrade/indexof, etc.',(⎕UCS 10),'      This version adapted from the Sara Baase "Computer Algorithms"',(⎕UCS 10),'      version of heapsort.',(⎕UCS 10),'     Robert Bernecky 2006-11-14',(⎕UCS 10),'     Knuth, Vol. III, pp. 145-148 gives a good example. ',(⎕UCS 10),'     APL model: (See workspace apex2003/wss/upgrade or',(⎕UCS 10),'                 apex2003/wif/upgrade)',(⎕UCS 10),'                Also UTGrade.dws',(⎕UCS 10),'r{<-}upgradeHeap v;#io;N;heap',(⎕UCS 10),'@ Upgrade vector using heapsort',(⎕UCS 10),'#io{<-}0',(⎕UCS 10),'N{<-}{rho}v',(⎕UCS 10),':if N{<=}1',(⎕UCS 10),'  r{<-}{iota}N',(⎕UCS 10),':else',(⎕UCS 10),'  heap{<-}MakeHeap(v)',(⎕UCS 10),'  r{<-}(UnHeap(heap))',(⎕UCS 10),':endif',(⎕UCS 10),'*/',(⎕UCS 10 10),' N = shape(y)[[0]];',(⎕UCS 10),' if (N <= 1)',(⎕UCS 10),'        z = iota(N); ',(⎕UCS 10),' else{',(⎕UCS 10),'        heap = MakeHeap(y);',(⎕UCS 10),'        z = UnHeap(heap,y);',(⎕UCS 10),' }',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10 10),'inline int[.] MakeHeap($YTYPE[+] v)',(⎕UCS 10),'{ /* Build heap from array v. v has at least two elements */',(⎕UCS 10),'/*',(⎕UCS 10),'r{<-}MakeHeap v;i;n;heap;biggest',(⎕UCS 10),'@ Build heap from v',(⎕UCS 10),'@ We know v has at least two elements',(⎕UCS 10),'N{<-}{rho}v',(⎕UCS 10),'heap{<-}{iota}N',(⎕UCS 10),':for i :in {reverse}{iota}{floor}N{divide}2',(⎕UCS 10),'  y FixHeap i,heap[i],n',(⎕UCS 10),':endfor',(⎕UCS 10),'r{<-}heap',(⎕UCS 10),'*/',(⎕UCS 10),' n = shape(v)[[0]];',(⎕UCS 10),' heap = iota(n);',(⎕UCS 10),' lim = n/2;',(⎕UCS 10),' for(i=lim-1; i>=0; i--) {',(⎕UCS 10),'        heap = FixHeap(heap, v, i, heap[[i]], n);',(⎕UCS 10),' }',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}',(⎕UCS 10 10),'inline int[.] UnHeap(int[.] heap, $YTYPE[+]v)',(⎕UCS 10),'{ /* Extract heap elements in top-to-bottom order */',(⎕UCS 10),'  n = shape(v)[[0]];',(⎕UCS 10),'  for(heapsize= n-1; heapsize>0; heapsize--){',(⎕UCS 10),'        biggest = heap[[0]];',(⎕UCS 10),'        heap = FixHeap(heap,v,0,heap[[heapsize]],heapsize);',(⎕UCS 10),'        heap[[heapsize]] = biggest;',(⎕UCS 10),'  }',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}',(⎕UCS 10 10),'inline int[.] FixHeap(int[.] heap, $YTYPE[+] v, int root, ',(⎕UCS 10),'        int heapitem, int heapsize)',(⎕UCS 10),'{ /* Restore heap invariant: parent>= both children */',(⎕UCS 10),' vacant = root;',(⎕UCS 10),' lchild = 1+vacant+vacant;',(⎕UCS 10),' while( lchild < heapsize) {',(⎕UCS 10),'        bigC = lchild;      /* Identify larger child, if any */',(⎕UCS 10),'        rchild = lchild+1;',(⎕UCS 10),'        if ((lchild<(heapsize-1))){',(⎕UCS 10),'                li = heap[[lchild]];',(⎕UCS 10),'                ri = heap[[rchild]]; ',(⎕UCS 10),'                if ((GradeGT(v[[ri]],v[[li]])) | ',(⎕UCS 10),'                        (match(v[[ri]], v[[li]]) & (ri>li))){ /* Stability */',(⎕UCS 10),'                bigC = rchild; /* right child larger */',(⎕UCS 10),'                }',(⎕UCS 10),'        }',(⎕UCS 10),'        /* parent vs big kid*/',(⎕UCS 10),'        li = heap[[bigC]];',(⎕UCS 10),'        if ((GradeGT( v[[li]], v[[heapitem]])) |',(⎕UCS 10),'                (match(v[[li]], v[[heapitem]]) & (li>heapitem))) {',(⎕UCS 10),'                        heap[[vacant]] = heap[[bigC]];',(⎕UCS 10),'                        vacant = bigC;',(⎕UCS 10),'                        lchild = 1+vacant+vacant;',(⎕UCS 10),'        } else lchild = heapsize;   /* exitloop */',(⎕UCS 10),' }',(⎕UCS 10),' heap[[vacant]] = heapitem;',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}               ',(⎕UCS 10),'%Generate , GradeGT, $YT$YTB, 000, ., $CT',(⎕UCS 10),'%Generate , GradeGT, $YT$YTB, **0, ., $CT',(⎕UCS 10 10),'%Fragment GradeGT 000 i i b .',(⎕UCS 10),'inline bool GradeGT(int x, int y)',(⎕UCS 10),'{ /* Integer Comparator for upgrade */',(⎕UCS 10),' return(x>y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment GradeGT 000 b b b .',(⎕UCS 10),'inline bool GradeGT(bool x, bool y)',(⎕UCS 10),'{ /* Boolean Comparator for upgrade */',(⎕UCS 10),' return(x & !y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment GradeGT 000 d d  b .',(⎕UCS 10),'inline bool GradeGT(double x, double y)',(⎕UCS 10),'{ /* Double Comparator for upgrade */',(⎕UCS 10),' return(x>y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment GradeGT 000 c c  b .',(⎕UCS 10),'inline bool GradeGT(char x, char y)',(⎕UCS 10),'{ /* Char Comparator for upgrade */',(⎕UCS 10),' return(x>y);',(⎕UCS 10),'}',(⎕UCS 10 10 10),'%Fragment GradeGT **0 b b b .',(⎕UCS 10),'inline bool GradeGT(bool[+] x, bool[+] y)',(⎕UCS 10),'{ /* Boolean Array Comparator for upgrade */',(⎕UCS 10),'  /* The ravels of the two arrays are compared.  */',(⎕UCS 10),' z = with {',(⎕UCS 10),'       (0*shape(x) <= iv < shape(x))',(⎕UCS 10),'                : x[iv] > y[iv];',(⎕UCS 10),'        }: foldfix( &, true,false);',(⎕UCS 10 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment GradeGT **0 c c b .',(⎕UCS 10),'inline bool GradeGT(char[+] x, char[+] y)',(⎕UCS 10),'{ /* Char Array Comparator for upgrade */',(⎕UCS 10),'  /* The ravels of the two arrays are compared.  */',(⎕UCS 10),' z = with {',(⎕UCS 10),'       (0*shape(x) <= iv < shape(x))',(⎕UCS 10),'                : x[iv] > y[iv];',(⎕UCS 10),'        }: foldfix( &, true,false);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment GradeGT **0 i i b .',(⎕UCS 10),'inline bool GradeGT(int[+] x, int[+] y)',(⎕UCS 10),'{ /* Integer Array Comparator for upgrade */',(⎕UCS 10),'  /* The ravels of the two arrays are compared.  */',(⎕UCS 10),' z = with {',(⎕UCS 10),'       (0*shape(x) <= iv < shape(x))',(⎕UCS 10),'                : x[iv] > y[iv];',(⎕UCS 10),'        }: foldfix( &, true,false);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment GradeGT **0 d d b .',(⎕UCS 10),'inline bool GradeGT(double[+] x, double[+] y)',(⎕UCS 10),'{ /* Double Array Comparator for upgrade */',(⎕UCS 10),'  /* The ravels of the two arrays are compared.  */',(⎕UCS 10),' z = with {',(⎕UCS 10),'       (0*shape(x) <= iv < shape(x))',(⎕UCS 10),'                : x[iv] > y[iv];',(⎕UCS 10),'        }: foldfix( &, true,false);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment dgrd x** x bidc i    .  ',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($YTYPE[+] y, int QUADio)',(⎕UCS 10),'{ /* Do APL downgrade of array y using heapsort. */',(⎕UCS 10),' z = QUADio + DowngradeHeap( y);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , DowngradeHeap, X$YTI, X**, ., $CT',(⎕UCS 10 10),'%Fragment DowngradeHeap x** x bidc i    .  ',(⎕UCS 10),'inline $ZTYPE[.] DowngradeHeap($YTYPE[+] y)',(⎕UCS 10),'{ /* Do APL downgrade of array y using heapsort.',(⎕UCS 10),'      This is a sub-function shared by upgrade/downgrade/indexof, etc.',(⎕UCS 10),'     This version adapted from the Sara Baase "Computer Algorithms"',(⎕UCS 10),'     version of heapsort.',(⎕UCS 10),'     Knuth, Vol. III, pp. 145-148 gives a good example. ',(⎕UCS 10),'     APL model: (See workspace apex2003/benchmks/UTGrade or',(⎕UCS 10),'                 apex2003/wif/upgrade)',(⎕UCS 10),'*/',(⎕UCS 10 10),' N = shape(y)[[0]];',(⎕UCS 10),' if (N <= 1)',(⎕UCS 10),'        z = iota(N); ',(⎕UCS 10),' else{',(⎕UCS 10),'        heap = MakeDHeap(y);',(⎕UCS 10),'        z = UnDHeap(heap,y);',(⎕UCS 10),' }',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10 10),'inline int[.] MakeDHeap($YTYPE[+] v)',(⎕UCS 10),'{ /* Build downgrade heap from v. v has at least two elements */',(⎕UCS 10),' n = shape(v)[[0]];',(⎕UCS 10),' heap = iota(n);',(⎕UCS 10),' lim = n/2;',(⎕UCS 10),' for(i=lim-1; i>=0; i--) {',(⎕UCS 10),'        heap = FixDHeap(heap, v, i, heap[[i]], n);',(⎕UCS 10),' }',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}',(⎕UCS 10 10),'inline int[.] UnDHeap(int[.] heap, $YTYPE[+]v)',(⎕UCS 10),'{ /* Extract heap elements in top-to-bottom order */',(⎕UCS 10),'  n = shape(v)[[0]];',(⎕UCS 10),'  for(heapsize= n-1; heapsize>0; heapsize--){',(⎕UCS 10),'        biggest = heap[[0]];',(⎕UCS 10),'        heap = FixDHeap(heap,v,0,heap[[heapsize]],heapsize);',(⎕UCS 10),'        heap[[heapsize]] = biggest;',(⎕UCS 10),'  }',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}',(⎕UCS 10 10),'inline int[.] FixDHeap(int[.] heap, $YTYPE[+] v, int root, ',(⎕UCS 10),'        int heapitem, int heapsize)',(⎕UCS 10),'{ /* Restore heap invariant: parent<= both children */',(⎕UCS 10),' vacant = root;',(⎕UCS 10),' lchild = 1+vacant+vacant;',(⎕UCS 10),' while( lchild < heapsize) {',(⎕UCS 10),'        bigC = lchild;      /* Identify larger child, if any */',(⎕UCS 10),'        rchild = lchild+1;',(⎕UCS 10),'        if ((lchild<(heapsize-1))){',(⎕UCS 10),'                li = heap[[lchild]];',(⎕UCS 10),'                ri = heap[[rchild]]; ',(⎕UCS 10),'                if ((GradeGT(v[[li]], v[[ri]])) | ',(⎕UCS 10),'                        (match(v[[ri]],v[[li]])) & (ri>li)){ /* Stability */',(⎕UCS 10),'                bigC = rchild; /* right child larger */',(⎕UCS 10),'                }',(⎕UCS 10),'        }',(⎕UCS 10),'        /* parent vs big kid*/',(⎕UCS 10),'        li = heap[[bigC]];',(⎕UCS 10),'        if ((GradeGT( v[[heapitem]], v[[li]])) |',(⎕UCS 10),'                (match(v[[li]], v[[heapitem]]) & (li>heapitem))) {',(⎕UCS 10),'                        heap[[vacant]] = heap[[bigC]];',(⎕UCS 10),'                        vacant = bigC;',(⎕UCS 10),'                        lchild = 1+vacant+vacant;',(⎕UCS 10),'        } else lchild = heapsize;   /* exitloop */',(⎕UCS 10),' }',(⎕UCS 10),' heap[[vacant]] = heapitem;',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}               ',(⎕UCS 10),'%Generate , GradeGT, $YT$YTB, 000, ., $CT',(⎕UCS 10),'%Generate , GradeGT, $YT$YTB, **0, ., $CT',(⎕UCS 10 10))
