'%  Monadic query (roll) and Dyadic query (deal)',(⎕UCS 10),'%',(⎕UCS 10),'% Robert Bernecky 2006-07-27',(⎕UCS 10),'% SAC code generator',(⎕UCS 10),'%',(⎕UCS 10 10),'%Fragment quer X00 x bid i .',(⎕UCS 10),'inline $ZTYPE, int $FNAME($YTYPE y, int QUADio, int QUADrl)',(⎕UCS 10),'{ /* Monadic query (roll) -  scalar */',(⎕UCS 10),' inty = toi(y);',(⎕UCS 10),' if (inty <= 0) print(tochar("roll domain error"));',(⎕UCS 10),' QUADrl = Lehmer(QUADrl);',(⎕UCS 10),' z = (tod(QUADrl) * tod(inty)) / tod(2147483647);',(⎕UCS 10),' return(toi(z) + QUADio, QUADrl);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , Lehmer, $XT$YT$ZT, X00, ., I',(⎕UCS 10 10 10),'%Fragment quer X** x bid i .',(⎕UCS 10),'inline $ZTYPE[+], int $FNAME($YTYPE[+] y, int QUADio, int QUADrl)',(⎕UCS 10),'{ /* Monadic query (roll) - non=scalar */',(⎕UCS 10),' zxrho = prod(shape(y));',(⎕UCS 10),' ravely = reshape([zxrho], y);',(⎕UCS 10),' inty = toi(y);',(⎕UCS 10),' if (any(inty <= 0)) print(tochar("roll domain error"));',(⎕UCS 10),' /* The following presumes ordering, so we use FOR loop. Sorry */',(⎕UCS 10),' z = genarray([zxrho], -1);',(⎕UCS 10),' for (i=0; i<zxrho; i++) {',(⎕UCS 10),'        QUADrl = Lehmer(QUADrl);',(⎕UCS 10),'        val = (tod(QUADrl) * tod(ravely[[i]])) / tod(2147483647);',(⎕UCS 10),'        z[[i]] =  QUADio + toi(val);',(⎕UCS 10),' }',(⎕UCS 10),' z = reshape(shape(y), z);',(⎕UCS 10),' return(z, QUADrl);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , Lehmer, $XT$YT$ZT, X00, ., I',(⎕UCS 10 10 10),'%Fragment quer 001  bid bid i .',(⎕UCS 10),'inline $ZTYPE[.], int $FNAME($XTYPE x, $YTYPE y, int QUADio, int QUADrl)',(⎕UCS 10),'{ /* Dyadic query (deal) - scalar */',(⎕UCS 10),'  /* This allocates an array of shape y. If this',(⎕UCS 10),'   * causes you memory grief, use the algorithm in workspace 42 query,',(⎕UCS 10),'   * or use smaller y!',(⎕UCS 10),'   */',(⎕UCS 10),' intx = toi(x);',(⎕UCS 10),' inty = toi(y);',(⎕UCS 10),' shpz = toi(x);',(⎕UCS 10),' z = iota (inty);',(⎕UCS 10 10),' for( i=0; i<intx; i++) {',(⎕UCS 10),'        /* Interchange z[i] with z[i + ? y - i] */',(⎕UCS 10),'        rand, QUADrl = querXII(inty -i, 0, QUADrl);',(⎕UCS 10),'        c = i + rand;',(⎕UCS 10),'        if ( c < shpz) {',(⎕UCS 10),'                tmp    = z[[c]];',(⎕UCS 10),'                z[[c]] = z[[i]]; ',(⎕UCS 10),'                z[[i]] = tmp;',(⎕UCS 10),'        }',(⎕UCS 10),' }      ',(⎕UCS 10),' z = take([intx], z);',(⎕UCS 10),' return(z + QUADio, QUADrl);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , quer, X$YT$ZT, X00, ., I ',(⎕UCS 10 10),'%Fragment quer 111  bid bid i .',(⎕UCS 10),'inline $ZTYPE[.], int $FNAME($XTYPE[.] x, $YTYPE[.] y, int QUADio, int QUADrl)',(⎕UCS 10),'{ /* Dyadic query (deal) - non-scalar */',(⎕UCS 10),' /* need length error check FIXME */',(⎕UCS 10),' return(querIII(x[0],y[0],QUADio,QUADrl));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , quer, III, 000, ., I ',(⎕UCS 10 10),'%Fragment quer 011  bid bid i .',(⎕UCS 10),'inline $ZTYPE[.], int $FNAME($XTYPE x, $YTYPE[.] y, int QUADio, int QUADrl)',(⎕UCS 10),'{ /* Dyadic query (deal) - non-scalar */',(⎕UCS 10),' /* need length error check FIXME */',(⎕UCS 10),' return(querIII(x,y[0],QUADio,QUADrl));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , quer, III, 000, ., I ',(⎕UCS 10 10),'%Fragment quer 101  bid bid i .',(⎕UCS 10),'inline $ZTYPE[.], int $FNAME($XTYPE[.] x, $YTYPE y, int QUADio, int QUADrl)',(⎕UCS 10),'{ /* Dyadic query (deal) - non-scalar */',(⎕UCS 10),' /* need length error check FIXME */',(⎕UCS 10),' return(querIII(x[0],y,QUADio,QUADrl));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , quer, III, 000, ., I ',(⎕UCS 10)
