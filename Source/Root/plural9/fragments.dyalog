⌷fragments←
<array><shape>32</shape>
<array><shape>4365</shape><string>% Catenate code fragments£%A;% Robert Bernecky 2007-05-14£%A;% SAC code generator£%A;%£%A;% Fragment header:  jsymbol ranks(x,y,z) nil nil nil comments£%A;% * in rank specifier means any rank&gt;1£%A;£%A;£%A;%Fragment coma 001 bidc bidc bidc .£%A;%Fragment comb 001 bidc bidc bidc .£%A;inline $ZTYPE[2] $FNAME($XTYPE x, $YTYPE y)£%A;{/* SxS catenate first (or last) axis */£%A; return([to$CT(x)]++[to$CT(y)]);£%A;}£%A;£%A;%Fragment coma 011 bidc bidc bidc .£%A;%Fragment comb 011 bidc bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE[.] y)£%A;{/* SxV catenate first (or last) axis */£%A; return([to$CT(x)]++to$CT(y));£%A;}£%A;£%A;%Fragment coma 101 bidc bidc bidc .£%A;%Fragment comb 101 bidc bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{/* VxS catenate first (or last) axis */£%A; return(to$CT(x)++[to$CT(y)]);£%A;}£%A;£%A;%Fragment coma 111 bidc bidc bidc .£%A;%Fragment comb 111 bidc bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE[.] y)£%A;{ /* VxV catenate first or last axis */£%A; return(to$CT(x)++to$CT(y));£%A;}£%A;£%A;%Fragment comb 1** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{/* VxA first axis catenate */£%A; return(to$CT([x])++to$CT(y));£%A;}£%A;£%A;%Fragment comb *1* bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[.] y)£%A;{/* AxV first axis catenate */£%A; return(to$CT(x)++to$CT([y]));£%A;}£%A;£%A;%Fragment coma 0** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* S,A last-axis catenate */£%A; frame = drop([-1],shape(y));£%A; cell = genarray([1+shape(y)[dim(y)-1]],$OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: [to$CT(x)]++to$CT(y[iv]);£%A;£%9;}: genarray ( frame, cell);£%A; return(z);£%A;} £%A;£%A;%Fragment coma *0* bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE y)£%A;{ /* A,S last-axis catenate */£%A; frame = drop([-1],shape(x));£%A; cell = genarray([1+shape(x)[dim(x)-1]],$OTFILL);£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: to$CT(x[iv])++[to$CT(y)];£%A;£%9;}: genarray(frame, cell);£%A; return(z);£%A;} £%A;£%A;£%A;%Fragment coma 1** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* VxA last-axis catenate */£%A; z=TRANSPOSE(to$CT([x])++TRANSPOSE(to$CT(y)));£%A; return(z);£%A;} £%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;%Fragment coma *1* bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[.] y)£%A;{ /* AxV last-axis catenate */£%A; z=TRANSPOSE(TRANSPOSE(to$CT(x))++to$CT([y]));£%A; return(z);£%A;} £%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;%Fragment coma *** bidc bidc bidc LG£%A;inline $ZTYPE[+] $FN$XT$YT$ZTLG($XTYPE[+] x, $YTYPE[+] y)£%A;{/* AxA last axis catenate. Left rank greater */£%A; frameshape = drop([-1],shape(x));£%A; cellshape  = take([-1],shape(x)) + [1];£%A; cell = genarray(cellshape, $OTFILL);£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .) £%A;£%9;£%9;: to$CT(x[iv])++to$CT([y[iv]]);£%A;£%9;}: genarray(frameshape, cell);£%A; return(z);£%A;}£%A;£%A;%Fragment coma *** bidc bidc bidc RG£%A;inline $ZTYPE[+] $FN$XT$YT$ZTRG($XTYPE[+] x, $YTYPE[+] y)£%A;{/* AxA last axis catenate. Right rank greater */£%A; frameshape = drop([-1],shape(y));£%A; cellshape  = take([-1],shape(y)) + [1];£%A; cell = genarray(cellshape, $OTFILL);£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .) £%A;£%9;£%9;: to$CT(x[iv])++to$CT([y[iv]]);£%A;£%9;} : genarray(frameshape, cell);£%A; return(z);£%A;}£%A;£%A;%Fragment coma *** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[+] y)£%A;{/* AxA last axis catenate. Ranks match */£%A; cellshape = (take([-1],shape(x)))+take([-1],shape(y));£%A; cell = genarray(cellshape, $OTFILL);£%A; z = with {£%A;£%9; (. &lt;= iv &lt;= .) £%A;£%9;£%9;: to$CT(x[iv])++to$CT(y[iv]);£%A;£%9;} : genarray(drop([-1], shape(x)), cell);£%A; return(z);£%A;}£%A;£%A;%%%%%%%%%%%%%%%%%%%%%%%%% first axis catenate %%%%%%%%%%%%%%%%%£%A;£%A;%Fragment comb 0** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* SxA first-axis catenate */£%A;  cell = genarray([1]++drop([1],shape(y)),to$CT(x));£%A;  return(cell++to$CT(y));£%A;}£%A;£%A;%Fragment comb *0* bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE y)£%A;{ /* AxS first-axis catenate */£%A;  cell = genarray([1]++drop([1],shape(x)),to$CT(y));£%A;  return(to$CT(x)++cell);£%A;}£%A;£%A;%Fragment comb *** bidc bidc bidc LG£%A;inline $ZTYPE[+] $FN$XT$YT$ZTLG($XTYPE[+] x, $YTYPE[+] y)£%A;{/* AxA first axis catenate. Left rank greater */£%A; return(to$CT(x)++to$CT([y]));£%A;}£%A;%Fragment comb *** bidc bidc bidc RG£%A;inline $ZTYPE[+] $FN$XT$YT$ZTRG($XTYPE[+] x, $YTYPE[+] y)£%A;{/* AxA first axis catenate. Right rank greater */£%A; return(to$CT([x])++to$CT(y));£%A;}£%A;%Fragment comb *** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[+] y)£%A;{/* AxA first axis catenate. Ranks match */£%A; return(to$CT(x)++to$CT(y));£%A;}£%A;£%A;</string></array>
<array><shape>780</shape><string>% Fragments for cut. £%A;% See compose for compositions£%A;% See rank for rank operator£%A;%£%A;% Robert Bernecky 1995-02-16£%A;%£%A;% Attempt to remove loop fusion inhibitions 1996-03-26 /rbe£%A;% Supports arbitrary user array index origin  1996-03-26 /rbe£%A;%Fragment 3nuax 111 bidc bidc bidc 3cut£%A;inline function $FNAME(x1: array[$XTYPE];£%A;              y1: array[$YTYPE]£%A;              returns array[$ZTYPE])£%A;% This is overlapping windows with slices of length y1, no shards£%A;% e.g., convolution£%A;% One-element window size, please£%A;%£%A;let £%A; qio := array_liml(x1);£%A; x0 := x1[ConformSame(qio,array_limh(x1))];£%A;in£%A;  for i in qio,1+array_limh(y1)-x0£%A;   S := array_setl(for j in i,i+x0-1£%A;        returns array of y1[j]£%A;        end for,qio) £%A;   returns array of $FRVALUE{{}{S}}£%A;  end for£%A;end let £%A;end function£%A;£%A;</string></array>
<array><shape>1865</shape><string>% SAC 2006-01-30 RBernecky£%A;% Code fragments for dyadic derived adverbs. £%A;% At present, this is only window reduction.£%A;£%A;%Fragment sl 011 bid bid bid .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE[.] y)£%A;{ /* Scalar window-reduce vector producing vector result */£%A;  /* FIXME: Need checks on x range and shape */ £%A; rev = toi(x) &lt; 0;  £%9;/* Reverse cell? */£%A; wid = [abs(toi(x))];£%A; shp = 1+shape(y)-wid;£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;cell = to$CT(tile( wid, iv, y));£%A;£%9;£%9;cell = rev ? reverse(cell) : cell;£%A;£%9;£%9;} : $FLVALUE$FRVALUEX$YT$ZT(cell);£%A;£%9;} : genarray(shp);£%A; return(z);£%A;}£%A;%Generate $FLVALUE, $FN, X$YT$ZT, x10, ., $CT£%A;£%A;%Fragment sl 011 bid bid bid WIDTH2£%A;inline $ZTYPE[.] $FNAMEWIDTH2($XTYPE x, $YTYPE[.] y)£%A;{ /* Width-2 window-reduce vector */£%A;  /* FIXME: Need checks on x range */ £%A; shp = shape(y)-1;£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;xel = to$CT(y[iv]);£%A;£%9;£%9;yel = to$CT(y[iv + 1]);£%A;£%9;£%9;} : $FLVALUE$CT$CT$ZT(xel,yel);£%A;£%9;} : genarray(shp);£%A; return(z);£%A;}£%A;%Generate , $FLVALUE, $CT$CT$ZT, 000, ., $CT£%A;£%A;%Fragment sl 011 bid bid bid WIDTHN2£%A;inline $ZTYPE[.] $FNAMEWIDTHN2($XTYPE x, $YTYPE[.] y)£%A;{ /* Width-minus-2 window-reduce vector */£%A;  /* FIXME: Need checks on x range */ £%A; shp = shape(y)-1;£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;xel = to$CT(y[iv]);£%A;£%9;£%9;yel = to$CT(y[iv + 1]);£%A;£%9;£%9;} : $FLVALUE$CT$CT$ZT(yel,xel);£%A;£%9;} : genarray(shp);£%A; return(z);£%A;}£%A;%Generate , $FLVALUE, $CT$CT$ZT, 000, ., $CT£%A;£%A;%Fragment sl 111 bid bid bid ONEEL£%A;inline $ZTYPE[.] $FNAMEONEEL($XTYPE[1] x, $YTYPE[.] y)£%A;{ /* One-element vector window-reduce vector */£%A;  /* FIXME: Need checks on x range */ £%A; rev = [toi(toi(x) &lt; 0)]; /* Reverse cell? */£%A; wid = [abs(toi(x))];£%A; shp = [1]+shape(y)-wid;£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;cell = to$CT(tile( wid, iv, y));£%A;£%9;£%9;  if (rev)£%A;£%9;£%9;£%9;cell = reverse(cell);£%A;£%9;}£%A;£%9;£%9;$FLVALUE$FRVALUEX$YT$ZT(cell);£%A;£%9;} : genarray(shp);£%A; return(z);£%A;}£%A;%Generate $FLVALUE, $FN, X$YT$ZT, x10,.,  $CT£%A;</string></array>
<array><shape>10295</shape><string>% SAC Code fragments for dyadic conjunctions, such as x +.* y£%A;% Robert Bernecky 2007-05-08£%A;£%A;% ALL code requires checks for length error!! rbe 2005-09-05£%A;£%A;% For the non-trivial cases of inner product, we£%A;% define several algorithms, roughly in order of decreasing best-case£%A;% performance on x f.g y:£%A;%£%A;%£%9;STAR:   performs z[i;]&lt;- z[i;] f x[i;j] g y[j;]£%A;%               This fetches each x-element exactly once, so it£%A;%               saves type-coercion time on x. It also operates£%A;%               in scalar-vector mode on g, stride-1, and in£%A;%               vector-vector mode on f, also stride-1. The first£%A;%               iteration can be peeled to initialize each row of z,£%A;%               or z can be initialized to the identity element for f.£%A;%  £%A;%£%9;        Furthermore, we can use knowledge of f and g to £%A;%£%9;        eliminate the above iteration step any time that:£%A;%£%9;£%9;x[i;j] g anything£%A;%£%9;        produces a left identity for f. E.g., in x OR.AND y,£%A;%               if x[i;j] is zero, then:£%A;%£%9;£%9;  x[i;j] AND  y[j;] £%A;%£%9;        is all zeros, and since zero is an identity element £%A;%               for f (OR), then the above computation step does not£%A;%               affect the final result, so it can be ignored.£%A;%               This also helps plain, old PLUS.TIMES, when the left£%A;%               argument has a lot of zeros. See Robert Bernecky's MSc£%A;%               thesis (APEX) for more details.£%A;%£%A;%£%9;£%9;A typical use would be using OR.AND to compute a £%A;%£%9;£%9;transitive closure step in a Boolean graph.£%A;%£%A;%£%9;STARLIKE: £%A;%£%9;£%9;Same as STAR, except that if x[i;j] is an identity£%A;%£%9;£%9;for g, we skip the scalar-vector computation of:£%A;%£%9;£%9;£%9;x[i;j] g y[j;]£%A;%£%9;£%9;and merely reduce y[j;] into the result:£%A;%£%9;£%9;£%9;z[i;]&lt;-z[i;] f y[j;]£%A;%£%A;%£%9;QUICKSTOP0, QUICKSTOP1:£%A;%£%9;£%9;These algorithms are a special case of TRANSPOSE,£%A;%£%9;£%9;except that the vector-vector dot product of a result element£%A;%               will stop short when one of the computations on g£%A;%               produces a result that fixes the result of f on that£%A;%£%9;£%9;element. The most common example of this is:£%A;%£%9;£%9;£%9;z&lt;-x AND.EQUALS y£%A;%£%9;£%9;typically on text matrices. If any character x[i;k]£%A;%£%9;£%9;does not match its corresponding character y[k;j], £%A;%£%9;£%9;then the result element z[i;k] must be zero, so £%A;%£%9;£%9;further computation of that result element halts.£%A;%£%9;£%9;The algorithms differ only in their halting criteria£%A;%£%9;£%9;being zero or one. There may be room for more general£%A;%£%9;£%9;halting values, but I couldn't think of one in more£%A;%£%9;£%9;than 30 seconds of thought.£%A;%£%A;%£%9;TRANSPOSE: £%A;%£%9;£%9;This is the most generic case. £%A;%£%9;£%9;It merely transposes the right argument before£%A;%£%9;£%9;performing the classical linear algebra algorithm.£%A;%£%9;£%9;This makes the repeated accesses to the right argument£%A;%£%9;£%9;stride-1 (after the transpose, anyway).£%A;% £%A;£%A;%Fragment dot 000 bidc bidc bidc .£%A;%Fragment dot 000 bidc bidc bidc STAR£%A;%Fragment dot 000 bidc bidc bidc TRANSPOSE£%A;inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Scalar-Scalar inner product */ £%A;  z =  $FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;} £%A;%Generate , $FRVALUE, $CT$XT$GZT, 000, ., $CT£%A;£%A;%Fragment dot 010 bidc bidc bidc .£%A;%Fragment dot 010 bidc bidc bidc STAR£%A;%Fragment dot 010 bidc bidc bidc TRANSPOSE£%A;inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Scalar-Vector inner product */ £%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;} £%A;%Generate , $FRVALUE, $XT$CT$GCT, 011, ., $CT£%A;%Generate $FNM,£%9;sl,£%9; X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;%Fragment dot 100 bidc bidc bidc .£%A;%Fragment dot 100 bidc bidc bidc STAR£%A;%Fragment dot 100 bidc bidc bidc TRANSPOSE£%A;inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Vector-Scalar inner product */ £%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;} £%A;%Generate , $FRVALUE, $CT$CT$GZT, 101, ., $CT£%A;%Generate $FNM,£%9;sl,£%9; X$GZT$ZT,   X10, $SPECRED, $CT£%A;£%A;%Fragment dot 110 bidc bidc bidc .£%A;%Fragment dot 110 bidc bidc bidc STAR£%A;%Fragment dot 110 bidc bidc bidc TRANSPOSE£%A;inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Vector-Vector inner product */ £%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZTsl(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;} £%A;%Generate , $FRVALUE, $CT$CT$GZTsl, 111, ., $CT£%A;%Generate $FNM,£%9;sl,£%9; X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;%Fragment dot 0** bidc bidc bidc .£%A;%Fragment dot 0** bidc bidc bidc TRANSPOSE£%A;inline $ZTYPE[*] $FNAME$IPALG($XTYPE x, $YTYPE[*] y$SYSVARFGDECL)£%A;{ /* TRANSPOSE case of inner product z = scalar f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1], shape(yt));£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;vy = yt[iv];£%A;£%9; } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZTsl(xct,vy$SYSVARGKER)$SYSVARFKER);£%A;£%9;} : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate , £%9;TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate , £%9;$FRVALUE, $GCT$GCT$GZTsl, 011, ., $GCT£%A;%Generate $FNM,£%9;sl,£%9; X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;%Fragment dot *0* bidc bidc bidc .£%A;%Fragment dot *0* bidc bidc bidc STAR£%A;%Fragment dot *0* bidc bidc bidc TRANSPOSE£%A;inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Inner product z =  f.g scalar-y */£%A; shp = drop([-1], shape(x));£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;} : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZTsl(to$GCT(x[iv]),to$GCT(y)$SYSVARGKER)$SYSVARFKER);£%A;£%9;} : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate , £%9;$FRVALUE, $GCT$GCT$GZTsl, 101, ., $GCT£%A;%Generate $FNM,£%9;sl,£%9; X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;£%A;%Fragment dot 1** bidc bidc bidc TRANSPOSE£%A;inline $ZTYPE[*] $FNAME$IPALG($XTYPE[.] x, $YTYPE[*] y$SYSVARFGDECL)£%A;{ /* TRANSPOSE case of inner product z = vector_f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; /* if (1 != shape(xct)[[0]]) FIXME; length error check */£%A; £%A; shp = drop([-1],shape(xct)) ++ drop([1], shape(y));£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;vx = xct[take([dim(x)-1], iv)];£%A;£%9;£%9;vy = yt[ reverse(take([1-dim(y)], iv))];£%A;£%9;} : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZTsl(vx,vy$SYSVARGKER)$SYSVARFKER);£%A;£%9;} :genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate , £%9;TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate , £%9;$FRVALUE, $GCT$GCT$GZTsl, 111, ., $GCT£%A;%Generate $FNM, sl, X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;%Fragment dot *1* bidc bidc bidc STAR£%A;%Fragment dot *2* bidc bidc bidc STAR£%A;inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)£%A;{ /* CDC STAR-100 APL Algorithm for inner product */£%A;  £%A; /* This computes, for z=x f.g y,£%A;  *£%9;£%9;z[i;] = z[i;]f x[i;j]g y[j;]£%A;  *  Thus, it runs stride-1, and we only fetch left argument£%A;  *  elements once. It includes skipping a g row iteration and£%A;  *  an f row-reduce iteration when x[i;j] generates an identity for f.£%A;  *  R. Bernecky 2005-11-24£%A;  */£%A;  rowsx = drop([-1],shape(x));£%A;  colsx = shape(x)[[dim(x)-1]];£%A;  colsy = shape(y)[[dim(y)-1]];£%A;  Zrow = genarray([colsy],$OTFILL);£%A;  /* Parallel over rows of x */£%A;  z = with {£%A;£%9;(. &lt;= row &lt;= .) {£%A;        £%9;Crow = Zrow;£%A;        £%9;for (colx=0; colx&lt;colsx; colx++) {£%A;£%9;£%9;£%9;xrow = x[row];£%A;£%9;£%9;£%9;xel = to$GCT(xrow[[colx]]);£%A;£%9;£%9;£%9;if (to$GCT($FGID) != xel) { /* Skip iteration if it's an identity */£%A;        £%9;£%9;£%9;VEC = $FRVALUE$GCT$GCT$GZT(xel,to$GCT(y[[colx]])$SYSVARGKER);£%A;        £%9;£%9;£%9;Crow = $FNM$ZT$ZT$ZTsl(Crow,to$CT(VEC)$SYSVARFKER);£%A;£%9;£%9;£%9;}£%A;      £%9;£%9;}£%A;£%9;} : Crow;£%A;   £%9;} : genarray( rowsx, Zrow);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT£%A;% sl in next line is "same length", not slash!£%A;%Generate , $FNM,£%9; $ZT$ZT$ZTsl,  111 , ., $CT£%A;£%A;%Fragment dot *1* bidc bidc bidc STARLIKE£%A;%Fragment dot *2* bidc bidc bidc STARLIKE£%A;inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)£%A;{ /* CDC STAR-100 APL Algorithm for inner product */£%A; /* This computes, for z=x f.g y,£%A;  *£%9;£%9;z[i;] = z[i;]f x[i;j]g y[j;]£%A;  *  Thus, it runs stride-1, and we only fetch left argument£%A;  *  elements once. It is similar to dotSTAR, except that:£%A;  *   1. "f" is such that we can't avoid the reduce step. £%A;  *   2. "x[i;j] f" is such that it may produce an identity on y[j;].£%A;  *      If so, we don't apply f to that row.£%A;  *  R. Bernecky 2005-11-24£%A;  */£%A;  rowsx = drop([-1],shape(x));£%A;  colsx = shape(x)[[dim(x)-1]];£%A;  colsy = shape(y)[[dim(y)-1]];£%A;  Zrow = genarray([colsy],$OTFILL);£%A;  /* Parallel over rows of x */£%A;  z = with {£%A;£%9; (. &lt;= row &lt;= .) {£%A;        £%9;Crow = Zrow;£%A;        £%9;for (colx=0; colx&lt;colsx; colx++) {£%A;£%9;£%9;£%9;xrow = x[[row]];£%A;£%9;£%9;£%9;xel = to$GCT(xrow[[colx]]);£%A;£%9;£%9;£%9;if (to$GCT($FGID) != xel) { /* Skip iteration if it's an identity */£%A;        £%9;£%9;£%9;VEC = $FRVALUE$GCT$GCT$GZT(xel,to$CT(y[[colx]])$SYSVARGKER);£%A;        £%9;£%9;£%9;Crow = $FLVALUE(Crow,VEC$SYSVARFKER);£%A;£%9;£%9;£%9;} else {£%A;£%9;        £%9;£%9;Crow = $FLVALUE(Crow,to$CT(y[[colx]])$SYSVARFKER);£%A;£%9;£%9;£%9;}£%A;£%A;      £%9;£%9;};£%A;£%9; } : Crow;£%A;   }: genarray( rowsx, Zrow);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT£%A;%Generate , $FLVALUE, X$GZT$GZT, 111, ., $CT£%A;£%A;£%A;%Fragment dot *** bidc bidc bidc QUICKSTOP0£%A;inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* QUICKSTOP0 case of inner product z = matrix f.g matrix */£%A;  /* The reduction quick-stops if any of its results are zero */£%A;  /* E.g., char ∧.= char */£%A;£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1],shape(x)) ++ drop([1], shape(y));£%A; z = with {£%A;        (. &lt;= iv &lt;= .) {£%A;                vx = xct[take([dim(x)-1], iv)];£%A;                vy = yt[ reverse(take([1-dim(y)], iv))];£%A;        £%9;} : $FNMslX$GZT$ZTQUICKSTOP($FRVALUE$GCT$GCT$GZTsl(vx,vy$SYSVARGKER)$SYSVARFKER);£%A;        } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate , £%9;TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate , $FRVALUE, $GCT$GCT$GZTsl, 111, ., $GCT£%A;%Generate $FNM,£%9;sl,£%9; X$GZT$ZT,   X10, QUICKSTOP, $ZT£%A;£%A;%Fragment dot *** bidc bidc bidc TRANSPOSE£%A;%Fragment dot *** bidc bidc bidc STAR£%A;%Fragment dot *** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* Generic case of inner product z = x f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1],shape(x)) ++ drop([1], shape(y));£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;vx = xct[take([dim(x)-1], iv)];£%A;£%9;£%9;vy = yt[ reverse(take([1-dim(y)], iv))];£%A;£%9;} : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZTsl(vx,vy$SYSVARGKER)$SYSVARFKER);£%A;£%9;} : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate , £%9;TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate , £%9;$FRVALUE, $GCT$GCT$GZTsl, 111, ., $GCT£%A;%Generate $FNM, sl      , X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>858</shape><string>% SAC Code fragments for dyadic upgrade, downgrade£%A;% Robert Bernecky 2005-11-17£%A;£%A;%Fragment ugrd 1** c c i .£%A;inline $ZTYPE[.] $FNAME($XTYPE[256] x, $YTYPE[+] y, int QUADio)£%A;{ /* Quadav-upgrade on character non-vector */£%A;z = QUADio + UpgradeHeap(y);£%A; return( z);£%A;}£%A;%Generate , UpgradeHeap, X$YTI, X**, ., $CT£%A;£%A;%Fragment dgrd 1** c c i .£%A;inline $ZTYPE[.] $FNAME($XTYPE[256] x, $YTYPE[+] y, int QUADio)£%A;{ /* Quadav-downgrade on character non-vector */£%A;z = QUADio + DowngradeHeap(y);£%A; return( z);£%A;}£%A;%Generate , DowngradeHeap, X$YTI, X**, ., $CT£%A;£%A;£%A;%Fragment ugrd 1** c c i .£%A;inline $ZTYPE[.] $FNAME($XTYPE[256] x, $YTYPE[+] y, int QUADio)£%A;{ /* Generic dyadic upgrade on character non-vector */£%A; fixme £%A;}£%A;£%A;%Fragment dgrd 1** c c i .£%A;inline $ZTYPE[.] $FNAME($XTYPE[256] x, $YTYPE[+] y, int QUADio)£%A;{ /* Generic dyadic downgrade on character non-vector */£%A; fixme £%A;}£%A;£%A;</string></array>
<array><shape>5609</shape><string>% Dyadic Miscellaneous function code fragments£%A;% Handles matrix divide, deal, base value, £%A;% representation, dyadic thorn, match£%A;%£%A;% Robert Bernecky 2006-02-10£%A;% SAC code generator£%A;%£%A;% --------------- Base value fragments ----------------------------£%A;%Fragment dtak 000  bid bid bid .£%A;% There has to be a£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* Scalar basevalue Scalar */£%A; return(y);£%A;}£%A;£%A;%Fragment dtak 010 bid bid bid .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE[.] y)£%A;{ /* Scalar basevalue vector */£%A; ycols=shape(y);£%A; weights = genarray(ycols, to$CT(1));£%A; for (i=ycols[[0]]-2; i&gt;=0; i--)£%A;        weights[[i]] = weights[[i+1]]*to$CT(x);£%A; /* Now, we just do weights +.* y */£%A; z = with {£%A;£%9;([0] &lt;= iv &lt; ycols)£%A;£%9;£%9;: weights[iv] * to$CT(y[iv]);£%A;£%9;} : fold(+, $OTFILL);£%A; return(z);£%A;}£%A;£%A;%Fragment dtak 0** bid bid bid .£%A;inline $ZTYPE[*] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Scalar basevalue rank&gt;1 */£%A; yt = TRANSPOSE(y); /* Dumb, but easy */£%A; frameshape = drop([-1],shape(yt));£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9; £%9;: $FNAME(x, yt[iv]);£%A;£%9;} : genarray(frameshape, $OTFILL);£%A; return(TRANSPOSE(z));£%A;}£%A;%Generate , $FN, $XT$YT$ZT, 010, ., $CT£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;%Fragment dtak 110 bid bid bid .£%A;inline $ZTYPE $FNAME($XTYPE[.] x, $YTYPE[.] y)£%A;{ /* Vector basevalue vector */£%A;  /* 3 cases - all give 22200:£%A;   *    10 10 10 basevalue 200 200 200 £%A;   *    10 10 10 basevalue 200£%A;   *    (,10) basevalue 200 200 200 £%A;   */£%A; ycols = (shape(y))[[0]];£%A; if (1 == ycols){£%9;/* Maybe extend y */£%A;£%9;ycols = shape(x)[[0]];£%A;£%9;y = genarray([ycols],y[[0]]);£%A; }£%A; if (1 == shape(x)[[0]]){£%9;/* Maybe extend x */£%A;£%9;x = genarray([ycols], x[[0]]);£%A; }£%A; weights = genarray([ycols], to$CT(1));£%A; for (i=ycols-2; i&gt;=0; i--)£%A;£%9;weights[[i]]= weights[[i+1]]*to$CT(x[[i+1]]);£%A; z = with { £%A;£%9;([0] &lt;= iv &lt; [ycols])£%A;£%9;£%9;: weights[iv] * to$CT(y[iv]);£%A;£%9;} : fold(+, $OTFILL);£%A; return(z);£%A;}£%A;£%A;%Fragment dtak 1** bid bid bid .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* Vector basevalue rank&gt;1 */£%A; yt = TRANSPOSE(y); /* Dumb, but easy */£%A; frameshape = drop([-1],shape(yt));£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNAME(x, yt[iv]);£%A;£%9;} : genarray(frameshape, $OTFILL); £%A; return(TRANSPOSE(z));£%A;}£%A;%Generate , $FN, $XT$YT$ZT, 110, ., $CT£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;% --------------- Represent fragments ----------------------------£%A;% These cases of Boolean result are detected by dfa; code£%A;% generator picks then up by result type(ctl FindType fns).£%A;£%A;%Fragment utak 101 bid bid b .£%A;inline bool[.] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{ /* Vector-of-twos represent scalar */£%A;/*   £%A;% This could be any mix of powers-of-two with a bit of work.£%A;% The guts of represent on Booleans£%A;*/£%A;   cell = 0;£%A;   k = shape(x)[[0]]-1;£%A;   z = with { £%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: BitAND(1,BitShiftRight(k-iv[0],toi(y)));£%A;£%9;} : genarray(shape(x), cell);£%A;  return(tob(z));£%A;}£%9;£%9;£%A;£%A;%Fragment utak 1**  bid bid b .£%A;inline bool[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* Vector-of-twos represent non-scalar */£%A;/*   £%A;   % This could be any mix of powers-of-two with a bit of work.£%A;   % The guts of represent on Booleans£%A;*/£%A; cell = genarray(shape(x),false);£%A; yt = TRANSPOSE(y);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNAME(x, yt[iv]);£%A;£%9;} : genarray(shape(yt), cell);£%A; return(TRANSPOSE(z));£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 101, ., $CT£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;£%A;%Fragment utak 101 bi bi bi .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{ /* Non-floating Vector represent scalar */£%A;  /* Taken from ISO Extended APL standard Draft N93.03, page 155 */£%A;  wts = genarray(shape(x),to$CT(1));£%A;  for(i=shape(x)[[0]]-2; i&gt;=0; i--)£%A;£%9;wts[[i]] = wts[[i+1]] * to$CT(x[[i+1]]);£%A;  z = genarray(shape(x),$OTFILL);£%A;  cy = to$CT(y);£%A;  for(i=shape(x)[[0]]-1; i&gt;=0; i--){£%A;£%9;z[[i]] = mod$CT$CT$ZT(to$CT(x[[i]]),cy/wts[[i]]);£%A;£%9;/* Must use fuzz-less call to mod!! */£%A;£%9;/* Represent is NOT fuzzy (SAPL Ref Man p.6-47, 1991 */£%A;£%9;cy = cy - z[[i]] * wts[[i]];£%A;  }£%A; return(z);£%A;}£%A;%Generate , mod, $CT$CT$ZT, 000, ., $CT£%A;£%A;£%A;%Fragment utak 101 bid bid bid .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{ /* Floating Vector represent scalar */£%A;  /* Taken from ISO Extended APL standard Draft N93.03, page 155 */£%A;  wts = genarray(shape(x),to$CT(1));£%A;  for(i=shape(x)[[0]]-2; i&gt;=0; i--)£%A;£%9;wts[[i]] = wts[[i+1]] * to$CT(x[[i+1]]);£%A;  z = genarray(shape(x),$OTFILL);£%A;  cy = to$CT(y);£%A;  for(i=shape(x)[[0]]-1; i&gt;=0; i--){£%A;£%9;z[[i]] = mod$CT$CT$ZT(to$CT(x[[i]]),cy/wts[[i]],0.0);£%A;£%9;/* Must use zero-fuzz call to mod!! */£%A;£%9;/* Represent is NOT fuzzy (SAPL Ref Man p.6-47, 1991 */£%A;£%9;cy = cy - z[[i]] * wts[[i]];£%A;  }£%A; return(z);£%A;}£%A;%Generate , mod, $CT$CT$ZT, 000, ., $CT£%A;£%A;%Fragment utak 1** bid  bid bid .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* Vector represent non-scalar */£%A; yt = TRANSPOSE(y);£%A; cell = genarray(shape(x),$OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNAME(x,yt[iv]);£%A;£%9;} : genarray(shape(yt), cell);£%A; return(TRANSPOSE(z));£%A;}£%A;%Generate , $FN, $XT$YT$ZT, 101, ., $CT£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;% --------------- MATCH fragments ----------------------------£%A;£%A;%Fragment same 000 bidc bidc b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y$SYSVARGDECL)£%A;{ /* Scalar match scalar */£%A;  z = to$CT(x) == to$CT(y);£%A; return(z);£%A;}£%A;£%A;%Fragment same 0*0  bidc bidc b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* Scalar match non-scalar */£%A; return(false);£%A;}£%A;£%A;%Fragment same *00  bidc bidc b .£%A;inline $ZTYPE $FNAME($XTYPE[+] x, $YTYPE y$SYSVARGDECL)£%A;{ /* Non-scalar match scalar */£%A; return(false);£%A;}£%A;£%A;%Fragment same **0 bidc bidc b .£%A;inline $ZTYPE $FNAME($XTYPE[+] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* Non-scalar match non-scalar */£%A; return(match(to$CT(x),to$CT(y)));£%A;}£%A;£%A;£%A;</string></array>
<array><shape>763</shape><string>% SAC Code fragments for rank conjunctions£%A;% Robert Bernecky 2006-02-13£%A;£%A;% ALL code requires checks for length error!! rbe 2005-09-05£%A;£%A;%Fragment nuax 000 bidc bidc bidc .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y$SYSVARFGDECL)£%A;{ /* SxS rank conj */ £%A;  z =  $FNM$CT$CT$ZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;} £%A;%Generate , $FNM, $CT$XT$ZT, 000, ., $CT£%A;£%A;%Fragment nuax *** bidc bidc bidc .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, int xrank, int yrank$SYSVARFGDECL)£%A;{ /* AxA rank conj */ £%A; frameshapex =  max(0, dim(x) - xrank); £%A; frameshapey =  max(0, dim(y) - yrank);£%A; frameshape = £%A; z = with (. &lt;= iv &lt;= .)£%A;£%9;genarray(frameshape, $FNM$CT$CT$ZT(£%A; £%A;£%A;  z =  $FNM$CT$CT$ZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;} £%A;%Generate , $FNM, $CT$XT$ZT, 000, ., $CT£%A;</string></array>
<array><shape>6977</shape><string>% Dyadic Scalar function definitions £%A;% R. Bernecky 2006-01-05£%A;%£%A;% Header notes:£%A;%    percentFragment  marks the beginning of each entry£%A;%    Fields are delimited by blanks.£%A;%    Field 1: primitive function jsymbol£%A;%    Field 2: acceptable left argument types£%A;%    Field 3: acceptable right argument types£%A;%    Field 4: Result type for fragment£%A;%    Field 5: ifergit£%A;%£%A;% Header ordering may be critical in the case where two £%A;% fragments would both work. This is important in epio, for£%A;% example, where a special case (e.g., charvec iota charvec)£%A;% must be chosen in preference to the general case. £%A;% Or, here, where we can use a fast Boolean-mod-Boolean, rather£%A;% than general mod code.£%A;%£%A;%Fragment plus 000 bid bid bid .£%9;£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(to$CT(x)+to$CT(y));£%A;}£%A;£%A;%Fragment bar 000 bid bid bid .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(to$CT(x)-to$CT(y));£%A;}£%A;£%A;%Fragment mpy 000 b b b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(tob(x) &amp; tob(y));£%A;}£%A;£%A;%Fragment mpy 000 bid bid bid .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(to$CT(x)*to$CT(y));£%A;}£%A;£%A;%Fragment div 000 bid bid d .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ dx = tod(x);£%A;  dy = tod(y);£%A; if (dx == dy) £%A;£%9;z = 1.0d;£%A;  else £%A;£%9;z = dx/dy;£%A;  return(z);£%A;}£%A;£%A;%Fragment min 000 b b b£%9;.£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return (x&amp;y);£%A;}£%A;£%A;%Fragment min 000 idc idc idc .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* x min y */£%A; return (min(to$CT(x),to$CT(y)));£%A;}£%A;£%A;%Fragment max 000 b b b£%9;.£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return (x&amp;y);£%A;}£%A;£%A;%Fragment max 000 bidc bidc idc£%9;.£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* x max y */ £%A; return (max(to$CT(x),to$CT(y)));£%A;}£%A;£%A;%Fragment mod 000 b b b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return((!x)&amp;y);£%A;}£%A;£%A;%Fragment mod 000 bi bi bi .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* SxS residue (aka modulo) */£%A;  /* This definition is taken from SHARP APL Refman May 1991, p.6-26.£%A;   * It extends the definition of residue to fractional right arguments£%A;   * and to zero, negative and fractional left arguments.£%A;   * r= y-x times floor y divide x+0=x£%A;   * See also APL model in workspace 43 UTDScalarI. £%A;   */£%A; xi = toi(x);£%A; yi = toi(y);£%A; if (0 != xi){£%A;  q = yi/xi;£%A;  z = yi-(xi*q);£%A; }£%A; else£%A;  z = yi;£%A;  nx = xi &lt; 0;£%A;  ny = yi &lt; 0;£%A; if ((0 != z) &amp;&amp; (nx != ny))£%A;  z = z + xi;£%A; return(z);£%A;} £%A;£%A;%Fragment mod 000 bid bid bid .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* Double residue double */£%A;  /* See Iresidue for definition */£%A;  if (0.0 == to$CT(x))£%A;        nx = 1.0;£%A;  else£%A;        nx = to$CT(x);£%A;  z = to$CT(y) - to$CT(x) * tod(DFLOOR(to$CT(y)/nx, QUADct));£%A;  return(z);£%A;}£%A;%Generate , DFLOOR, X$YT$ZT, X00, ., $CT£%A;£%A;%Fragment star 000 b b b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(x | !y);£%A;}£%A;£%A;%Fragment star 000 bid b bid .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ if (tob(y))£%A;£%9;z = to$ZT(x);£%A; else£%A;£%9;z = to$ZT(1);£%A; return(z);£%A;}£%A;£%A;%Fragment star 000 bid bid d .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(pow(tod(x),tod(y)));£%A;}£%A;£%A;%Fragment log  000 bid bid d .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(log(tod(y))/log(tod(x)));£%A;}£%A;£%A;%Fragment lt 000 b b b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return((!x)&amp;y);£%A;}£%A;£%A;/* NB.  APEX Extension of ISO APL to allow comparison of characters */£%A;/* relationals */£%A;%Fragment lt 000 bic bic b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A&lt;B on Boot/Int/Char */£%A;  return(to$CT(x)&lt;to$CT(y));£%A;}£%A;£%A;%Fragment lt 000 bi bi b i £%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* Boolean/Integer less than */£%A; return(to$CT(x)&lt;=to$CT(y));£%A;£%A;%Fragment lt 000 bid bid b d£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* Fuzzy less than */£%A; return((to$CT(x)&lt;to$CT(y)) &amp; !APEXFUZZEQ(to$CT(x),to$CT(y),QUADct));£%A;}£%A;%Generate , APEXFUZZEQ, $XT$YTB, 000, ., D£%A;£%A;%Fragment le 000 b b b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A&lt;=B on Boolean */£%A; return((!x)|y);£%A;}£%A;£%A;%Fragment le 000 bic bic b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A&lt;=B on Boolean,int, char */£%A; return(to$CT(x) &lt;= to$CT(y));£%A;}£%A;£%A;%Fragment le 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* Fuzzy &lt;= */£%A; return((to$CT(x)&lt;to$CT(y)) | APEXFUZZEQ(to$CT(x),to$CT(y),QUADct));£%A;}£%A;%Generate , APEXFUZZEQ, DDB, 000, ., D£%A;£%A;%Fragment eq 000 bic bic b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A=B on non-doubles */£%A; return(to$CT(x) == to$CT(y));£%A;}£%A;£%A;%Fragment eq 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* A=B on doubles */£%A; return((to$CT(x) == to$CT(y)) || APEXFUZZEQ(to$CT(x),to$CT(y),QUADct));£%A;}£%A;%Generate , APEXFUZZEQ, DDB, 000, ., D£%A;£%A;%Fragment ne 000 bic bic b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{/* A !=B on non-doubles */£%A; return(to$CT(x) != to$CT(y));£%A;}£%A;£%A;%Fragment ne 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* A!=B on doubles */£%A; return((to$CT(x) != to$CT(y)) &amp;&amp; !APEXFUZZEQ(to$CT(x),to$CT(y),QUADct));£%A;}£%A;%Generate , APEXFUZZEQ, DDB, 000, ., D£%A;£%A;%Fragment gt 000 b b b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A&gt;B on non-doubles */£%A; return(x &amp; !y);£%A;}£%A;£%A;%Fragment gt 000 bic bic b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A&gt;B on Booleans */£%A; return(to$CT(x) &gt; to$CT(y));£%A;}£%A;£%A;%Fragment gt 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* A&gt;B on doubles */£%A; return((to$CT(x) &gt; to$CT(y)) &amp;&amp; !APEXFUZZEQ(to$CT(x),to$CT(y),QUADct));£%A;}£%A;%Generate , APEXFUZZEQ, DDB, 000, ., D£%A;£%A;%Fragment ge 000 b b b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A&gt;=B on Booleans */£%A; return(x | !y);£%A;}£%A;£%A;%Fragment ge 000 bic bic b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* A&gt;=B on non-Doubles */£%A; return(to$CT(x) &gt;= to$CT(y));£%A;}£%A;£%A;%Fragment ge 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)£%A;{ /* A&gt;=B on doubles */ £%A; return((to$CT(x) &gt;= to$CT(y)) || APEXFUZZEQ(to$CT(x),to$CT(y),QUADct));£%A;}£%A;%Generate , APEXFUZZEQ, DDB, 000, ., D£%A;£%A;%Fragment and 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(tob(x)&amp;tob(y));£%A;}£%A;£%A;%Fragment or 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(tob(x)|tob(y));£%A;}£%A;£%A;%Fragment nand 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(!(to$CT(x)&amp;to$CT(y)));£%A;}£%A;£%A;%Fragment nor 000 bid bid b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ return(!(to$CT(x)|to$CT(y)));£%A;}£%A;£%A;%Fragment circ 000 bid bid bid .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* Circle functions */£%A; xi = toi(x);£%A; if£%9; (1 == xi)£%A;£%9;z = sin(toD(y));£%A; else if (2 == xi)£%A;£%9;z = cos(toD(y));£%A; else if (3 == xi)£%A;£%9;z = tan(toD(y));£%A; else if (4 == xi)£%A;£%9;z = pow(1.0+(toD(y)*toD(y)),0.5);£%A; else £%A;£%9;z = 42.0; /* Should be domain error or something */£%A; return(z); £%A;}£%A;£%A;</string></array>
<array><shape>3143</shape><string>% APEX code fragments for dyadic scalar functions.£%A;% R. Bernecky 2005-10-07 £%A;%  £%A;%  We can not, in general, provide full support for singleton£%A;%  extension. Consider the (1 1 1 rho 2)+ iota n.£%A;%  If n&gt;1 then the result is a vector. £%A;%  If n=1, the result is a tensor!£%A;%  Hence, we should forbid ALL singletons of rank&gt;1. £%A;£%A;%  We SHOULD forbid£%A;%  vector singletons as well (things would run faster), but £%A;%  there is too much code that depends on this behavior. 1996-05-04£%A;£%A;% There is some redundancy in the code fragments below, because,£%A;% e.g., we may mark a SxS operation as sx, sy, or neither...£%A;%£%A;% $FNAME: Name of the scalar function iterator we are building,£%A;%£%9;e.g., plusBII£%A;% $FN: Name of the scalar-scalar function itself,£%A;%       e.g., dplus£%A;%      This will have types appended to it, to give complete name,£%A;%       e.g., dplusBII£%A;% $SYSVARIN: string appended to function header for input system vars.£%A;% $SYSVARG: string appended to scalar fn kernel call for system vars.£%A;% $SYSVAROUT: string appended to function header for output system vars.£%A;% $XT: type of x as BIDC.£%A;% $YT: type of y as BIDC.£%A;% $CT: compute type as BIDC.£%A;% $ZT: result type as BIDC.£%A;% $XTYPE: type of x as SAC name, e.g., bool, int, double, char£%A;% $YTYPE: type of y as SAC name, e.g., bool, int, double, char£%A;% $ZTYPE: result type as SAC name, e.g., bool, int, double, char £%A;£%A;%Fragment dsfctl   0**  bidc bidc bidc .£%A;%Fragment dsfctlsx 0**  bidc bidc bidc . £%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* SxA scalar function */£%A;  xel = to$CT(x);£%A;  z = with {£%A;£%9;( . &lt;= iv &lt;= .) {£%A;        £%9;yel = to$CT(y[iv]);£%A;      £%9;£%9;} : $FN$CT$CT$ZT(xel,yel$SYSVARGKER);£%A;£%9;} : genarray(shape(y), $OTFILL);£%A;  return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 000, ., $CT£%A;£%A;%Fragment dsfctl   *0* bidc bidc bidc .£%A;%Fragment dsfctlsy *0* bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE y$SYSVARGDECL)£%A;{ /* AxS scalar function */£%A;  yel = to$CT(y);£%A;  z = with { £%A;£%9;( . &lt;= iv &lt;= .) {£%A;£%9;£%9;xel = to$CT(x[iv]);£%A;£%9;} : $FN$CT$CT$ZT(xel,yel$SYSVARGKER);£%A;£%9;} : genarray( shape(x), $OTFILL);£%A;  return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 000, ., $CT£%A;£%A;%Fragment dsfctlsl *** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAMEsl($XTYPE[+] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* AxA Dyadic scalar fn, shapes unknown, but known to match */£%A;  z = with {£%A;£%9;( . &lt;= iv &lt;= .) {£%A;£%9;£%9;xel = to$CT(x[iv]);£%A;£%9;£%9;yel = to$CT(y[iv]);£%A; £%9;}: £%9;$FN$CT$CT$ZT(xel,yel$SYSVARGKER);£%A;        genarray(shape(x), $OTFILL);£%A;  return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 000, ., $CT£%A;£%A;%Fragment dsfctl *** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* AxA Dyadic scalar fn, shapes may or may not match */£%A;£%9;sx = DSFLenErrorCheck(shape(x), shape(y),tochar("$FNAME($XTYPE[+],$YTYPE[+]"));£%A;£%9;z = with {£%A;£%9;£%9;( . &lt;= iv &lt;= .) {£%A;£%9;£%9;£%9;xel = to$CT(x[iv]);£%A;£%9;£%9;£%9;yel = to$CT(y[iv]);£%A;£%9;£%9;} : $FN$CT$CT$ZT(xel,yel$SYSVARGKER);£%A;        } : genarray(sx, $OTFILL);£%A;  return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 000, ., $CT£%A;%Generate , $FN, $CT$CT$ZT, 0**, ., $CT£%A;%Generate , $FN, $CT$CT$ZT, *0*, ., $CT£%A;%Generate , coma, X$XT$XT, X*1, ., $XT £%A;%Generate , coma, X$YT$YT, X*1, ., $YT £%A;%Generate , DSFLenErrorCheck, III, ***, ., I£%A;£%A;</string></array>
<array><shape>4338</shape><string>% Code fragments for dyadic structural functions£%A;%£%A;% Robert Bernecky 2005-12-03£%A;%£%A;%Fragment rotr 000  bid bidc bidc .£%A;%Fragment rot1 000  bid bidc bidc .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* Scalar rotate scalar, any axis */£%A; return(y);£%A;}£%A;£%A;%Fragment rotr 011  bid bidc bidc .£%A;%Fragment rot1 011  bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Scalar rotate first/last axis vector */£%A; ix = toi(x);£%A; rows = shape(y)[0];£%A; k = VectorRotateAmount(ix,rows); /* Normalize rotate count */£%A; z = with {£%A;£%9; (. &lt;= [i] &lt;= .)£%A;£%9; { idx = (i+k) &lt; rows ? (i+k) : (i+k) - rows;£%A;£%9; } : y[[idx]];£%A;£%9;} : genarray([rows], $OTFILL);£%A; return(z);£%A;}£%A;%Generate , VECTORROTATEAMOUNT, III, 000, ., I £%A;£%A;£%A;£%A;%Fragment rot1 0**  bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Scalar rotate first axis non-scalar */£%A; ix = toi(x);£%A; rows = shape(y)[0];£%A; cellshape = drop([1], shape(y));£%A; defcell = genarray(cellshape, $OTFILL);£%A; k = VectorRotateAmount(ix,rows); /* Normalize rotate count */£%A; z = with {£%A;£%9;(. &lt;= [i] &lt;= .)£%A;£%9; { idx = (i+k) &lt; rows ? (i+k) : (i+k) - rows;£%A;£%9; } : y[[idx]];£%A;£%9;} : genarray([rows], defcell);£%A; return(z);£%A;}£%A;%Generate , VECTORROTATEAMOUNT, III, 000, ., I £%A;   £%A;%Fragment rotr 0**  bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Scalar rotate matrix last axis */£%A; cols = shape(y)[[dim(y)-1]];£%A; ix = toi(x);£%A; k = VectorRotateAmount(ix,cols); /* Normalize rotate count */£%A; y2d = reshape([prod(drop([-1],shape(y))), cols], y);£%A; z = with {£%A;£%9;(. &lt;= [i,j] &lt;= .)£%A;£%9; { idx = (j+k) &lt; cols ? (j+k) : (j+k) - cols;£%A;£%9; } : y2d[[ i, idx]];£%A;£%9;} : genarray(shape(y2d), $OTFILL);£%A; z = reshape(shape(y),z);£%9;£%A; return (z);£%A;}£%A;%Generate , VECTORROTATEAMOUNT, III, 000, ., I £%A;£%A;%Fragment rotr ***  bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE [+] x, $YTYPE[+] y)£%A;{ /* Non-scalar rotate matrix last axis */£%A;/* FIXME - needs validation of left rank vs right rank,£%A; * etc. rbe 2004-09-18 £%A; */£%A; cols = shape(y)[[dim(y)-1]];£%A; cell= genarray([cols],$OTFILL);£%A; ix = toi(x);£%A; k = VectorRotateAmount(ix,cols); /* Normalize rotate count */£%A; y2d = reshape([prod(drop([-1],shape(y))), cols], y);£%A; z = with {£%A;£%9;(. &lt;= [i,j] &lt;= .)£%A;£%9; { idx = (j+k[[i]]) &lt; cols ? (j+k[[i]]) : (j+k[[i]]) - cols;£%A;£%9; } : y2d[[ i, idx]];£%A;£%9;} : genarray(shape(y2d), $OTFILL);£%A; z = reshape(shape(y),z);£%9;£%A; return(z);£%A;}£%A;%Generate , VECTORROTATEAMOUNT, III, *0*, ., I £%A;£%A;%Fragment tran 100  bid bidc bidc .£%A;inline $ZTYPE $FNAME($XTYPE[0] x,  $YTYPE y)£%A;{ /* Dyadic transpose of scalar */£%A;  return(y);£%A;}£%A;£%A;%Fragment tran 111  bid bidc bidc .£%A;inline $ZTYPE $FNAME($XTYPE[1] x, $YTYPE y)£%A;/* Left argument must be index origin */£%A;/* FIXME */£%A;{ /* dyadic tranpose of vector */£%A; return(y);£%A;}£%A;£%A;%Fragment tran 122 bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[2] x, $YTYPE[.,.] y)£%A;{ /* Vector (no dups!) transpose rank-2 matrix */£%A; ix=toi(x);£%A; if ((0 == x[[0]]) &amp;&amp; (1 == x[[1]]))£%A;£%9;z = y;£%A; else if ((1 == x[[0]]) &amp;&amp; (0 == x[[1]]))£%A;£%9;z = TRANSPOSE(y);£%A; else £%A;£%9;z= (reshape(shape(y)/0,y); /* Domain error */£%A; return(z);£%A;}£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;%Fragment tran 1** bid bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE[*] y)£%A;{ /* General case of dyadic transpose  */£%A;/* Someone has to validate x here! FIXME */£%A; shpy = shape(y);£%A; wts = drop([1],shpy)++[1];£%A; rankz = -1;£%A; for(i=shape(shpy)[[0]]-2; i&gt;=0; i--){ /* times scan the hard way */£%A;  wts[[i]] = wts[[i+1]]*wts[[i]];£%A;  rankz = max(rankz,x[[i]]);£%A; }£%A; shpz = genarray([1+rankz],-1); £%A; weights = genarray([1+rankz],0);£%A; for(i=dim(y)-1; i&gt;=0; i--){£%A;£%9;shpz[[x[[i]]]] = shpy[[i]];£%A;£%9;weights[[x[[i]]]] = weights[[x[[i]]]]+wts[[i]];£%A; }£%A;£%A; cp = CartProdPlus(weights, shpz);£%A; ry = comaX$YT$ZT(y);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: ry[[cp[iv]]];£%A;£%9;} : genarray(shape(cp), $OTFILL);£%A; z = reshape(shpz,z);£%A; return(z);£%A;}£%A;£%A;inline int[.] CartProdPlus(int[.] weights, int[.] lengths)£%A;{ /* Cartesian product, sum-like, for weights+each iota each lengths */£%A;  /* Weight and length vectors must be same length, and non-empty */£%A; s = shape(weights)[[0]];£%A; if (0 == s)£%A;  z = s;£%A; else£%A;  z = weights[[0]] * iotaXII(lengths[[0]],0);£%A;  for(i=1; i&lt;s; i++){£%A;   t = weights[[i]] * iotaXII(lengths[[i]],0);£%A;   z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: z[iv] + t;£%A;£%9;} : genarray(shape(z), t);£%A;   z = comaXII(z);£%A;  }£%A; return(z);£%A;}£%A;%Generate , iota, XII, X01, ., I£%A;%Generate , coma, X$YT$YT, X*1, ., $CT £%A;%Generate , coma, XII, X*1, ., I £%A;</string></array>
<array><shape>11400</shape><string>% Code fragments for search functions£%A;% These include x iota y, x epsilon y, x epsbar y£%A;%£%A;% Rewritten for SAC 2006-11-14 Robert Bernecky£%A;£%A;£%A;%Fragment iota 111 bi bi i PV£%A;inline $ZTYPE $FNAMEPV($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)£%A;{£%A;/* FIXME! How does a PV interact with QUADIO? */£%A;/* Build the index table. This is lots faster than an upgrade,£%A; *  and we also do not have to do binary search.£%A; * We make the table one element bigger than needed, and£%A; * put the not-found index in it.£%A; */£%A;£%A; /* Build table as: tbl[i] = x iota i  */£%A; tbl = with {£%A;£%9; ( . &lt;= iv &lt;= .)£%A;£%9;£%9;: shape(x)[[0]]+QUADio;£%A;£%9;} : genarray([1]+shape(x));£%A; tbl = with { £%A;£%9;( . &lt;= iv &lt;= .)£%A;£%9;£%9;: y[iv];£%A;£%9;}: modarray(shape(x), iv[[0]]);£%A;£%A;/* Now, we can index the table with elements of the£%A; * right argument, giving their location in x.£%A; * We need a range check, though...£%A; */£%A;£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;v = max(to$CT(y[iv]),0);£%A;£%9;£%9;v = min(v,shape(x)); /* Note that tbl is 1 element£%A;£%9;£%9;£%9;£%9;        than x, so this is OK.  */£%A;£%9;£%9;} : tbl[[v]];£%A;£%9;} : genarray(shape(y)l);£%A; return(z);£%A;}£%A;£%A;%Fragment iota 100  bic bic i .£%A;inline $ZTYPE $FNAME($XTYPE[.] x, $YTYPE y$SYSVARGDECL)£%A;{ /* Non-fuzzy Vector iota Scalar */£%A; sx = shape(x)[[0]];£%A; z = sx;£%A; for(i=0; i&lt;sx; i++) {£%A;£%9;if (to$CT(x[[i]]) == to$CT(y)){£%A;£%9;£%9;z = i;£%A;£%9;£%9;i = sx;£%A;£%9;}£%A; }£%A; return(z+QUADio);£%A;}£%A;£%A;%Fragment iota 100  d d i .£%A;inline $ZTYPE $FNAME($XTYPE[.] x, $YTYPE y$SYSVARGDECL)£%A;{ /* Fuzzy Vector iota Scalar */£%A; sx = shape(x)[[0]];£%A; z = sx;£%A; for(i=0; i&lt;sx; i++) {£%A;£%9;if (eqDDB(to$CT(x[[i]]),to$CT(y),QUADct)){£%A;£%9;£%9;z = i;£%A;£%9;£%9;i = sx;£%A;£%9;}£%A; }£%A; return(z+QUADio);£%A;}£%A;%Generate , eq, DDB, 000, ., $CT£%A;£%A;%Fragment iota 1** b bid i .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* Boolean iota number */£%A;  /* Right argument almost always scalar */£%A;  /* However, we'll do more work for the nonce, because it's easy */£%A;  sx = shape(x)[[0]];£%A;  table = [sx, sx, sx];£%A;  table[[0]] = BooleanIotaScalar(x, false);£%A;  table[[1]] = BooleanIotaScalar(x, true);£%A;  z = with {£%A;£%9;(. &lt;= iv &lt;= .){ £%A;£%9;£%9;if (toi( y[iv]) == 0) {£%A;£%9;£%9;£%9;index = 0;£%A;£%9;£%9;} else if (toi( y[iv]) == 1) {£%A;£%9;£%9;£%9;index = 1;£%A;£%9;£%9;} else {£%A;£%9;£%9;£%9;index = 2;£%A;£%9;£%9;}£%A;£%9;£%9;} : table[[index]];£%A;£%9;} : genarray( shape(y));£%A;  return(z + QUADio);£%A;}£%A;%Generate , BooleanIotaScalar , BBI, 1**, ., $CT£%A;£%A;%Fragment BooleanIotaScalar 1** b b i .£%A;inline int  BooleanIotaScalar( bool[.] x, bool y)£%A;{ £%A; sx = (shape(x))[[0]];£%A; z = sx;£%A; for (i=0; i&lt;sx; i++) {£%A;£%9;if ( x[[i]] == y) {£%A;£%9;£%9;z = i;£%A;£%9;£%9;i = sx;£%A;£%9;}£%A; } £%A;  return(z);£%A;}£%A;£%A;%Fragment iota 100 c c i QUADAV£%A;inline $ZTYPE[*] $FNAMEQUADAV($XTYPE[256] x, $YTYPE y$SYSVARGDECL)£%A;{ /* QUADav iota character scalar */£%A; return(toi(y)+QUADio);£%A;}£%A;£%A;%Fragment iota 1** c c i QUADAV£%A;inline $ZTYPE[*] $FNAMEQUADAV($XTYPE[256] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* QUADav iota character non-scalar */£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: toi(y[iv]);£%A;£%9;} : genarray(shape(y), 0);£%A; return(z+QUADio);£%A;}£%A;£%A;%Fragment iota 1** c c i .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* Character vector iota character non-scalar */£%A; table = genarray([256],shape(x)[[0]]); /* Not found */£%A; for(i=shape(x)[[0]]-1; i&gt;=0; i--)£%A;£%9;table[toi(x[[i]])] = i;£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: table[[toi(y[iv])]];£%A;£%9;}: genarray(shape(y), 0);£%A; return(z+QUADio);£%A;}£%A;£%A;%Fragment iota 1** bid bid i .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)£%A;{£%A;/* General case uses HeapGrade */£%A; sx = (shape(x))[[0]];£%A; PV = UpgradeHeap(x); /* faster to search x if its sorted! */£%A; PV = EPIORemoveDups(x, PV); /* This could be in UpgradeHeap, probably */ £%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;P = BinarySearch(x, y[iv], PV);£%A;£%9;£%9;/* following for real/complex when quadct != 0 £%A;£%9;£%9;}: (P == sx) ? sx : PV[[ MinMatch( x, PV, P)]];£%A;£%9;£%9;*/£%A;£%9;£%9;}: (P == sx) ? sx : PV[[P]];£%A;£%9;}: genarray( shape(y), sx);£%A; return(z+QUADio);£%A;}£%A;%Generate , UpgradeHeap , X$YTI,   X10, ., $CT£%A;%Generate , BinarySearch, $XT$YTI, 110, ., $CT£%A;%Generate , MinMatch    , $XT$YTI, 110, ., $CT£%A;%Generate , EPIORemoveDups    , $XT$YTI, 110, ., $CT£%A;£%A;%Fragment EPIORemoveDups 110 bidc bidc i .£%A;inline int[.] EPIORemoveDups ($XTYPE[+] x, int[.] PV)£%A;{ /* Remove dups from PV of sorted left argument to indexof(right arg of membership */£%A; z = PV; £%A; shp = (shape(PV))[[0]];£%A; if (0 != shp) {£%A;£%9;sink = 0;£%A;£%9;source = 1;£%A;£%9;while (source &lt; shp) {£%A;£%9;£%9;if ( x[[z[[sink]]]] != x[[PV[[source]]]]) {£%A;£%9;£%9;£%9;sink++;£%A;£%9;£%9;£%9;z[[sink]] = PV[[source]];£%A;£%9;£%9;}£%A;£%9;£%9;source++;£%A;£%9;}£%A; z = take([sink+1], z);£%A; }£%A; return(z);£%A;}£%A;£%A;%Fragment BinarySearch 110 bidc bidc i . £%A;inline int BinarySearch($XTYPE[+] x, $YTYPE y, int[.] PV)£%A;{ /* Binary search x[PV] for y£%A;   * PV is a permutation vector guaranteed to bring y into£%A;   * non-descending order£%A;   * If not-found, result is shape(x) £%A;   */£%A; found = false;£%A; first = 0;£%A; sx  = (shape(PV))[[0]];£%A; indx = -1;                   /* Bobbo kant kode if this appears! */£%A; last = sx - 1;£%A; while ((first &lt;= last) &amp;&amp; !found) {£%A;£%9;indx = (first+last)/2;  /* index of middle entry */£%A;£%9;xval = to$CT(x[[PV[[indx]]]]);£%A;£%9;yval = to$CT(y); /* This is wrong - type coercion may fail! */£%A;        if (    yval == xval) {£%A;£%9;£%9;found = true;£%A;£%9;} else if (yval &lt; xval) {£%A;£%9;£%9;last = indx - 1;£%A;£%9;} else {£%A;£%9;£%9;first = indx + 1;£%A;£%9;}£%A; }£%A; z = found ? indx : sx;£%A; return(z);£%A;} £%A;£%A;%Fragment MinMatch 110 bidc bidc i .£%A;inline int MinMatch ($XTYPE[+] x, int[.] PV, int i)£%A;{ /* Search permutation vector for minimum match.£%A;   * i is an index into PV. PV is a permutation vector for£%A;   * x that places x in non-descending order.£%A;   *  We want minimum index into x that matches x[[PV[[i]]]]£%A;   *  Because upgrade is stable, we only have to look left£%A;   *  (except for real/complex x with non-zero {quad}ct)£%A;   */£%A; v = x[[PV[[i]]]];£%A; j = i - 1;£%A; r = i;£%A; while (j &gt;= 0) {£%A;£%9;if ( v == x[[PV[[j]]]]) {£%A;£%9;£%9;r = j;        /* new minimum index */£%A;£%9;} else {£%A;£%9;£%9;j = -1;       /* no more matches. Stop */  £%A;£%9;}£%A;£%9;j = j - 1;£%A; }£%9;£%A; return(r);£%A;}  £%A;£%A;%£%A;% -------------------- epsilon fragments -----------------------------£%A;%£%A;%Fragment eps 000 bi bi b .£%A;%Fragment eps 000 c  c  b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)£%A;{ /* Non-fuzzy membership SxS*/£%A; z = to$CT(x) == to$CT(y);£%A; return(z);£%A;}£%A;£%A;%Fragment eps 000 d d b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y$SYSVARGDECL)£%A;{ /* Fuzzy membership SxS */£%A; z = TEQ$CT(to$CT(x),to$CT(y)$SYSVARGKER);£%A; return(z);£%A;}£%A;£%A;%Fragment eps 010  bic bic b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE[.] y$SYSVARGDECL)£%A;{ /* Non-fuzzy membership SxA */£%A; z = with {£%A;        (0*shape(y) &lt;= iv &lt; shape(y))£%A;£%9;£%9;: to$CT(x) == to$CT(y[iv]);£%A;#ifdef FOLDFIXBUG£%A;/* foldfix kills sac2c with DFM bugs */£%A;        } : foldfix(|, false, true);£%A;#else£%A;        } : fold(|, false);£%A;#endif£%A; return(z);£%A;}£%A;£%A;%Fragment eps 010  d   d  b .£%A;%Fragment eps 010  bi  d  b .£%A;%Fragment eps 010  d  bi  b .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE[.] y$SYSVARGDECL)£%A;{ /* Fuzzy membership SxA*/£%A; z = with {£%A;        (0*shape(y) &lt;= iv &lt; shape(y))£%A;        £%9;: eqDDB(to$CT(x),to$CT(y[[i]]),QUADct);£%A;#ifdef FOLDFIXBUG£%A;/* foldfix kills sac2c with DFM bugs */£%A;        } : foldfix(|, false, true);£%A;#else£%A;        } : fold(|, false);£%A;#endif£%A; return(z);£%A;}£%A;%Generate , eq, DDB, 000, ., $CT£%A;£%A;%Fragment eps *0* bic bic b .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE y$SYSVARGDECL)£%A;{ /* Non-fuzzy membership AxS */£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) £%A;£%9;£%9;: (to$CT(x) == to$CT(y);£%A;#ifdef FOLDFIXBUG£%A;/* foldfix kills sac2c with DFM bugs */£%A;        } : foldfix(|, false, true);£%A;#else£%A;        } : fold(|, false);£%A;#endif£%A; return(z);£%A;}£%A;£%A;%Fragment eps *0* bid d b .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE y$SYSVARGDECL)£%A;{ /* Fuzzy membership AxS */£%A; z = with {£%A;        (0*shape(y) &lt;= iv &lt; shape(y))£%A;        £%9;: eqDDB(to$CT(x[iv]),to$CT(y),QUADct);£%A;#ifdef FOLDFIXBUG£%A;/* foldfix kills sac2c with DFM bugs */£%A;        } : foldfix(|, false, true);£%A;#else£%A;        } : fold(|, false);£%A;#endif£%A; return(z);£%A;}£%A;%Generate , eq, DDB, 000, ., $CT£%A;£%A;%Fragment eps *** c c b .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /* character membership AxA*/£%A; ry = ravel(y);£%A; tbl = genarray([256],false);£%A; for(i=0; i&lt;shape(ry)[[0]]; i++) {£%A;  tbl[[toi(ry[[i]])]] = true;£%A; }£%A;£%A; z = with { £%A;£%9;(. &lt;= iv &lt;= .)£%A; £%9;£%9;: tbl[[toi(x[iv])]];£%A;£%9;} : genarray(shape(x), false);£%A; return(z);£%A;}£%A; £%A;%Fragment eps *** c c b QUADAV£%A;inline $ZTYPE[*] $FNAMEQUADAV($XTYPE[*] x, $YTYPE[256] y$SYSVARGDECL)£%A;{ /* A member QUADav. This is kinda silly... */£%A; z = genarray(shape(x), true);£%A; return(z);£%A;}£%A;£%A;%Fragment eps *** bid c    b .£%A;%Fragment eps *** c   bid  b .£%A;inline $ZTYPE[*] $FNAME($XTYPE[*] x, $YTYPE[*] y$SYSVARGDECL)£%A;{ /* Char member non-char, and vice versa */£%A; z = genarray(shape(x), false);£%A; return(z);£%A;}£%A;£%A;%Fragment eps *** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[+] y$SYSVARGDECL)£%A;{ /*  Fuzzy, non-fuzzy Membership AxA*/£%A;/* General case: uses HeapGrade */£%A; sy = (shape(y))[[0]];£%A; PV = UpgradeHeap(y); /* faster to search y if its sorted! */£%A; PV = EPIORemoveDups(y, PV); /* This could be in UpgradeHeap, probably */ £%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9;£%9;P = BinarySearch(y, x[iv], PV);£%A;£%9;£%9;/* Binary search could quickstop on a match here... */£%A;   £%9; £%9;}: P != sy;£%A;£%9;}: genarray( shape(x), false);£%A; return(z);£%A;}£%A;%Generate , UpgradeHeap , X$YTI,   X10, ., $CT£%A;%Generate , BinarySearch, $XT$YTI, 110, ., $CT£%A;%Generate , MinMatch    , $XT$YTI, 110, ., $CT£%A;%Generate , EPIORemoveDups    , $XT$YTI, 110, ., $CT£%A;£%A;% ------------------ ebar fragments -------------------------------£%A;£%A;%£%A;%£%A;%Fragment epsb 111 bidc bidc b .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE[.] y$SYSVARGDECL)£%A;{£%A;WONTWORK£%A;}£%A;%£%A;function $FNAME(x1: array[$XTYPE]; £%A;                y1: array[$YTYPE]£%A;                returns array[boolean])£%A;£%A;% We look for the left arg in the right arg.£%A;% We should implement Boyer-Moore here, but time is£%A;% tight. 1996-02-12£%A;% This is OK for short phrases. Should have algorithm£%A;% selector in code generator for this.£%A;£%A;$SFCASES{{ % General case (0)£%A;MATCHRESTVECTOR($XTYPE,$YTYPE,$XT,$YT,$CT)£%A;£%A; if IsEmpty(x1) then array_fill(0,array_limh(y1),true) % x1 empty£%A; else£%A; let £%A;  lasti := array_limh(y1) - array_limh(x1); % Last y1 index where£%A;                                            % match can occur£%A; in£%A;   for y0 in y1 at i returns array of£%A;    if $XTto$CT(x1[0]) ~= $YTto$CT(y0) £%A;     % Quick out if no match on first character£%A;      | i &gt; lasti          % or past end of y1£%A;    then false£%A;    else MatchRestVector(x1,y1,i)£%A;    end if£%A;   end for£%A; end let£%A; end if£%A;end function£%A;}}£%A; £%A;%£%A;%Fragment epsb 122 bidc bidc b .£%A;%£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y$SYSVARGDECL)£%A;{£%A;}£%A;function $FNAME(x1: array[$XTYPE]; £%A;                y2: array[$YTYPE]£%A;                returns array[array[boolean]])£%A;£%A;% We look for the left arg in the right arg.£%A;% We should implement Boyer-Moore here, but time is£%A;% tight. 1996-02-12£%A;% This is OK for short phrases. Should have algorithm£%A;% selector in code generator for this.£%A;$SFCASES{{ % General case (0)£%A;£%A; MATCHRESTVECTOR($XTYPE,$YTYPE,$XT,$YT,$CT)£%A;£%A; if IsEmpty(x1) = 0 then £%A;     array_fill(array_fill(0,array_limh(y2),£%A;        % Stupid empty array kludge needed here£%A;          array_fill(0,array_limh(y2[0]),true) % x1 empty£%A; else£%A;  for y1 in y2 returns array of £%A;   let £%A;    lasti := array_limh(y1) - array_limh(x1); % Last y1 index where£%A;                                              % match can occur£%A;   in£%A;     for y0 in y1 at i returns array of£%A;      if $XTto$CT(x1[0]) ~= $YTto$CT(y0) £%A;       % Quick out if no match on first character£%A;        | i &gt; lasti          % or past end of y1£%A;      then false£%A;      else MatchRestVector(x1,y1,i)£%A;      end if£%A;     end for£%A;   end let£%A;  end for£%A; end if£%A;}}£%A;end function£%A;£%A;</string></array>
<array><shape>3791</shape><string>% Code fragments for indexed ref£%A;% 2005-10-17£%A;% Rewritten for SAC. rbe£%A;% And again, 2005-10-24 /rbe£%A;% And again, 2006-08-11 /rbe, after discovering how REALLY slow (1000X!) indrfr calls are.£%A;% $XTYPE: The type of lhs, e.g., double_real£%A;% $ZTYPE: The type of result, e.g., int£%A;% $OTFILL: The lhs fill element. Not used by indr; needed for SAC with-loop.£%A;£%A;% The idea here is an index reference of the form:£%A;%   X[i;j;k;l;m]  £%9;where index arrays (i,j,k,l,m...) may or£%A;%  £%9;£%9;£%9;not exist (E.g., X[i;k]),£%A;% can be written as compositions of indexing functions:£%A;%£%A;% indrfr(fr,i,X)£%9;Perform XX[i;...], where XX is the set of cells£%A;%                       formed by splitting XX on "Frame Rank" fr.£%A;% £%9;£%9;£%9;fr elements are numbered by the rank of the resulting£%A;%£%9;£%9;£%9;frame, e.g.,:£%A;%£%9;X[i;j;k;l;m...]£%A;%         0 1 2 3 4...£%A;% Result shape is ((i drop shape(X)),(shape(i)),(i+1)drop shape(x)).£%A;%£%A;% The key is to perform index operations from right to left, so that £%A;% axes inserted or deleted due to index array shapes. Hence, £%A;%£%9;z = X[i;;k;;m] £%A;%             0  2  4  fr values£%A;% can be written as:£%A;%£%9;TMP1 = indrfr(4,m,X);£%A;%£%9;TMP2 = indrfr(2,k,TMP1);£%A;%£%9;z    = indrfr(0,i,TMP2);£%A;% or:   z    = indrfr(0,i,indrfr(2,k,indrfr(4,m,X)));£%A;% with suitable coercions and QUADio subtractions for i,j,m.£%A;£%A;% rank indicators for Z&lt;- X[i;j;k] are  XxZijk. £%A;% Elided axes get x, e.g.:  X[;k2;] is  XxZx2x£%A;£%A;%Fragment indr *0*           nonscalarX[scalarI;;] £%A;%              XIZ after fns2 gets made £%A;inline $ZTYPE[*] indr($XTYPE[+] X, int I)£%A;{ /* X[scalarI;;;] */£%A;  /* Used only in conjunction with other indexing, e.g.,£%A;   * X[scalarI;;j;]£%A;   */£%A; z = X[[I]];£%A; return(z);£%A;}£%A;%Generate , ABC,    III,           *00, ., I £%A;%Generate , indrfr, $XTI$XT, ****, ., I£%A;%Generate , indrfr, $XTI$XT, *0*0, ., I£%A;£%A;%Fragment indr *x*           nonscalarX[;;;] £%A;%              XIZ after fns2 gets made £%A;inline $ZTYPE[*] indr($XTYPE[+] X)£%A;{ /* X[;;;] */£%A;  /* Used only in conjunction with other indexing, e.g.,£%A;   * X[;;j;]£%A;   */£%A; return(X);£%A;}£%A;%Generate , indrfr, $XTI$XT, ****, ., I£%A;%Generate , indrfr, $XTI$XT, *0*0, ., I£%A;£%A;%Fragment indr ***           nonscalarX[nonscalarI;;] £%A;inline $ZTYPE[*] indr($XTYPE[+] X, int[+] I)£%A;{ /* X[nonscalarI;;;] */£%A; defcell = genarray(drop([1],shape(X)),$OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: X[[I[iv]]];£%A;£%9;} : genarray(shape(I), defcell);£%A; return(z);£%A;}£%A;%Generate , ABC, III, ***, ., I £%A;%Generate , ABC, III, *00, ., I £%A;%Generate , indrfr, $XTI$XT, ****, ., I£%A;%Generate , indrfr, $XTI$XT, *0*0, ., I£%A;£%A;%Fragment indrfr *0*0           nonscalarX[;;scalarI;;] £%A;%                XIZ after fns2 gets made £%A;inline $ZTYPE[*] indrfr(int fr, $XTYPE[+] X, int I)£%A;{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */£%A;  /* This is actually "I from"fr X" */£%A; frameshape = take([fr], shape(X)); £%A; cellshape = drop([1+fr],shape(X));£%A; cell = genarray(cellshape,$OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: sel( I, X[iv]);£%A;£%9;} : genarray(frameshape, cell);£%A; return(z);£%A;}£%A;%Generate , ABC, III, ***, ., I £%A;£%A;%Fragment indrfr ****           nonscalarX[;;nonscalarI;;] £%A;%                XIZ after fns2 gets made £%A;inline $ZTYPE[*] indrfr(int fr, $XTYPE[+] X, int[+] I)£%A;{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */£%A;  /* This is actually "I from"fr X" */£%A;  frameshape = take([fr], shape(X));£%A;  cellshape =  shape(I)++drop([fr+1], shape(X));£%A;  cell = genarray(cellshape, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: indrfr0(X[iv], I);£%A;£%9;} : genarray(frameshape, cell);£%A; return(z);£%A;}£%A;£%A;inline $ZTYPE[*] indrfr0($XTYPE[+] X, int[+] I)£%A;{ /* X[I;;;] or    I from X */£%A;  cellshape =  drop([1], shape(X));£%A;  cell = genarray(cellshape, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: sel( I[iv], X);£%A;£%9;} : genarray(shape(I), cell);£%A; return(z);£%A;}£%A;%Generate , ABC, III, ***, ., I £%A;%Generate , ABC, III, *00, ., I £%A;£%A;</string></array>
<array><shape>3196</shape><string>% SAC Code fragments for indexed assign£%A;% R. Bernecky 2006-01-16£%A;% £%A;% All fragments are {QUAD}io=0; callers must subtract {QUAD}io from indices.£%A;£%A;% Also, as of 2005-11-02, support for removing 1's from the shape£%A;% vectors involved in the operation has not been implemented yet.£%A;£%A;% Related to that is FIXME: in X[i;j;k...]&lt;-Y, we need validation£%A;% that the array shapes are conformable. £%A;£%A;% Cases of indexed assign:£%A;% 1. x[scalar;;]&lt;- scalar          NB. Leading axis £%A;% 2. x[non-scalar;;]&lt;- scalar      NB. Leading axis£%A;% 3. x[scalar;;]&lt;- non-scalar      NB. Leading axis, cell shapes must match£%A;% 4. x[non-scalar;;]&lt;- non-scalar  NB. Leading axis,£%A;%                                  NB.  frame and cell shapes must match£%A;% 5. x[;scalar;;]&lt;- scalar         NB. Non-Leading axis £%A;% 6. x[;non-scalar;;]&lt;- scalar     NB. Non-Leading axis£%A;% 7. x[;scalar;;]&lt;- non-scalar     NB. Non-Leading axis, cell shapes must match£%A;% 8. x[;non-scalar;;]&lt;- non-scalar NB. Non-Leading axis,£%A;%                                  NB.  frame and cell shapes must match£%A;% 9. x[;;]&lt;- scalar                NB. All elements change here£%A;% 10.x[;;]&lt;- y                     NB. All elements change here£%A;%                                  NB.  frame and cell shapes must match£%A;£%A;%Fragment inds *0* bidc bidc bidc . nonscalarX[;;nonscalarI;;]&lt;- scalarY £%A;inline $ZTYPE[+] $FNAME($XTYPE[+] X, $INDICES $YTYPE Yin)£%A;{ /* X[;;nonscalarI;;;]&lt;- scalarY */£%A; $RAVELS £%A; z = to$ZT(X);£%A; $RESH£%A; $FORLOOPSPROLOG£%A; $BODY£%A; $FORLOOPSEPILOG£%A; return(z);£%A;}£%A;%Generate , ABC, III, ***, ., I£%A;%Generate , ABC, III, *00, ., I£%A;£%A;%Fragment inds *** bidc bidc bidc . nonscalarX[;;nonscalarI;;]&lt;- nonscalarY £%A;inline $ZTYPE[+] $FNAME($XTYPE[+] X, $INDICES $YTYPE[+] Y)£%A;{ /* X[;;nonscalarI;;;]&lt;- nonscalarY */£%A;  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */£%A; $RAVELS £%A; z = to$ZT(X);£%A; $FORLOOPSPROLOG£%A; $BODY£%A; $FORLOOPSEPILOG£%A; return(z);£%A;}£%A;%Generate , ABC, III, ***, ., I£%A;%Generate , ABC, III, *00, ., I£%A;£%A;%Fragment inds *0* bidc bidc bidc AllChange. nonscalarX[;;;;]&lt;- scalarY £%A;inline $ZTYPE[+] $FNAME($XTYPE[+] X, $INDICES $YTYPE Y)£%A;{/*  Case  9. X[;...;]&lt;- scalarY                NB. All elements change here£%A;  *  In some interpreters, this is used as a coercion, but I'm not sure£%A;  *  how to do that here. For example: BooleanVector[] &lt;- 2 - 2 1 1 2 £%A;  *  tries to keep the type of BooleanVector as Boolean. We don't even try that here.£%A; */£%A; z = genarray(shape(X), Y);£%A; return(z);£%A;}£%A;%Generate , ABC, III, ***, ., I£%A;%Generate , ABC, III, *00, ., I£%A;£%A;%Fragment inds *** bidc bidc bidc AllChange. nonscalarX[;;;;]&lt;- nonscalarY £%A;inline $ZTYPE[+] $FNAME($XTYPE[+] X, $INDICES $YTYPE[+] Y)£%A;{/*  Case 10. X[;...;]&lt;- nonscalarY                 NB. All elements change here£%A;  *  In some interrpreters, this is used as a coercion, but I'm not sure£%A;  *  how to do that here. For example: BooleanVector[] &lt;- 2 - 2 1 1 2 £%A;  *  tries to keep the type of BooleanVector as Boolean. We don't even try that here.£%A;  */£%A; if (!all (shape(X) == shape(Y))£%A;  /* This should be a fancier check that ignores 1s in the shape vectors... */£%A;£%9;APEXERROR (tochar("length error"));£%A; return(Y);£%A;}£%A;%Generate , ABC, III, ***, ., I£%A;%Generate , ABC, III, *00, ., I£%A;</string></array>
<array><shape>1124</shape><string>% SAC Code fragments for outer product loop control.£%A;% Robert Bernecky 2005-11-05£%A;£%A;%Fragment  jotdot 000 bidc bidc bidc .£%A;inline $ZTYPE $FNAME($XTYPE x, $YTYPE y$SYSVARFGDECL)£%A;{ /* SxS outer product */£%A;  z = $FN$CT$CT$ZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 000, ., $CT£%A;£%A;%Fragment  jotdot 0** bidc bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* SxA outer product */£%A;  z = $FN$CT$CT$ZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 0**, ., $CT£%A;£%A;%Fragment  jotdot *0* bidc bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE [+] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* AxS outer product */£%A;  z = $FN$CT$CT$ZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, *0*, ., $CT£%A;£%A;%Fragment  jotdot *** bidc bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE [+] x, $YTYPE [+] y$SYSVARFGDECL)£%A;{ /* AxA outer product */£%A; cell = genarray(shape(y), $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .) {£%A;£%9; xitem = to$CT(x[iv]);£%A;£%9;} : $FN$CT$CT$ZT(xitem, to$CT(y)$SYSVARGKER);£%A;£%9;} : genarray(shape(x), cell);£%A; return(z);£%A;}£%A;%Generate , $FN, $CT$CT$ZT, 0**, ., $CT£%A;</string></array>
<array><shape>6623</shape><string>$ SAC 2006-08-09 rbernecky£%A;% Code fragments for monadic adverbs: reduce, scan, and cut.£%A;%£%A;% NB. Replicate and expand are located in replicat.frg£%A;£%A;£%A;%%%%%%%%%%%%%%%%%%%%% reduce on scalars %%%%%%%%%%%%%%%%%%%%555£%A;£%A;%Fragment sl  x00 bidc bidc bidc .£%A;%Fragment sl1 x00 bidc bidc bidc .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* Reduction of scalar */£%A;£%9;return(y);£%A;}£%A;£%A;%Fragment sl  x00 bidc bidc bidc QUICKSTOP £%A;%Fragment sl1 x00 bidc bidc bidc QUICKSTOP £%A;inline $ZTYPE $FNAMEQUICKSTOP($YTYPE y)£%A;{ /* Reduction of scalar */£%A;£%9;return(y);£%A;}£%A;£%A;%Fragment sl  x00 bidc bidc bidc FOLD £%A;%Fragment sl1 x00 bidc bidc bidc FOLD £%A;inline $ZTYPE $FNAMEFOLD($YTYPE y)£%A;{ /* Reduction of scalar */£%A;£%9;return(y);£%A;}£%A;£%A;% The identity elements for vector reductions are not exactly right.£%A;% We use maxint() and minint() for integer min/max reduce, whereas£%A;% APL uses maxdouble() and mindouble(). If we did this, we would£%A;% end up with reduce ALWAYS having to produce a double result. £%A;% Bummer, Hal. £%A;% Purists can rewrite their integer reductions as:£%A;%      min/maxdouble(), Y£%A;% and get that double result they yearn for.£%A;£%A;%%%%%%%%%%%%%%%%%%%%% reduce on vectors %%%%%%%%%%%%%%%%%%%%555£%A;£%A;%Fragment sl  x10 bidc bidc bidc FOLD £%A;%Fragment sl1 x10 bidc bidc bidc FOLD £%A;inline $ZTYPE $FNAMEFOLD($YTYPE[.] y)£%A;{ /* First/last axis fold-based reduction of vector */ £%A;  lim = shape(y)[0]-1;£%A;  z = with {£%A;£%9;(0*shape(y) &lt;= iv &lt; shape(y)) £%A;£%9;£%9;: to$ZT(y[lim-iv]);£%A;       } :  fold( $FN$ZT$ZT$ZT, to$ZT($FRID));£%A;  return(z);£%A;}£%A;%Generate , $FN, $ZT$ZT$ZT, 000, ., $ZT£%A;£%A;%Fragment sl  x10 bidc bidc bidc QUICKSTOP £%A;%Fragment sl1 x10 bidc bidc bidc QUICKSTOP £%A;inline $ZTYPE $FNAMEQUICKSTOP($YTYPE[.] y)£%A;{ /* First/last axis reduction of vector with quick stop*/ £%A;#ifdef FOLDFIXBUG£%A; /* foldfix makes things die in ugly ways. See bug# ??? */£%A;  z = with {£%A;£%9; (0*shape(y) &lt;= iv &lt; shape(y)) £%A;£%9;£%9;: to$CT(y[iv]);£%A; /* sbs foldfix kills UTThorn (and others) with DFM bug */£%A;£%9;} : foldfix( $FN$ZT$CT$ZT, to$ZT($FRID), to$ZT($STOPONVALUE));£%A;£%A;#else£%A;£%A; z = to$ZT($FRID); £%9;/* right identity */£%A; lim = shape(y)[0];£%A; for ( i=0; i&lt;lim; i++) {£%A;£%9;z = $FN$ZT$CT$CT(to$CT(z), to$CT(y[[i]]));£%A;£%9;if ( y[[i]] == to$ZT($STOPONVALUE)) {£%A;£%9;£%9;i = lim; £%A;£%9;}£%A;}£%A;£%A;#endif£%A;  return(z);£%A;}£%A;%Generate , $FN, $ZT$ZT$ZT, 000, ., $ZT£%A;£%A;%Fragment sl  x10 bidc bidc bidc . £%A;%Fragment sl1 x10 bidc bidc bidc . £%A;inline $ZTYPE $FNAME($YTYPE[.] y)£%A;{ /* First/last axis slow reduction of vector. Can't use fold or quickstop */ £%A; shp = shape(y)[[0]];£%A; if (0 == shp)£%A;  z = to$ZT($FRID); £%A; else {£%A;  z = to$ZT(y[[shp-1]]);£%A;  for (i=shp-2; i&gt;=0; i--)£%A;   z = $FN$ZT$CT$ZT(to$CT(y[[i]]),to$CT(z));£%A; }£%A; return(z);£%A;}£%A;%Generate , $FN, $ZT$ZT$ZT, 000, ., $ZT£%A;£%A;%%%%%%%%%%%%%%%%%%%%% last-axis reduce on rank&gt;1 arrays  %%%%%%%%%%%%%%%%%%%%555£%A;£%A;%Fragment  sl  x** bidc bidc bidc QUICKSTOP£%A;inline $ZTYPE[+] $FNAMEQUICKSTOP($YTYPE[+] y)£%A;{ /* last axis reduce rank-2 or greater matrix w/quickstop */£%A;  sy = shape(y);£%A;  zrho = drop([-1], sy);£%A;  z = with {£%A;£%9; (. &lt;= iv &lt;= .) £%A;£%9;£%9;: $FNAMEQUICKSTOP(y[iv]);£%A;£%9;} : genarray(zrho, $OTFILL); £%A;  return(z);£%A;}£%A;%Generate $FN, sl, X$YT$ZT, X10, QUICKSTOP, $ZT£%A;£%A;%Fragment  sl  x** bidc bidc bidc FOLD£%A;inline $ZTYPE[+] $FNAMEFOLD($YTYPE[+] y)£%A;{ /* last axis reduce rank-2 or greater matrix w/folding */£%A;  sy = shape(y);£%A;  zrho = drop([-1], sy);£%A;  z = with {£%A;£%9; (. &lt;= iv &lt;= .) £%A;£%9;£%9;: $FNAMEFOLD(y[iv]);£%A;£%9;} : genarray(zrho, $OTFILL); £%A;  return(z);£%A;}£%A;%Generate $FN, sl, X$YT$ZT, X10, FOLD, $ZT£%A;£%A;%Fragment  sl  x** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($YTYPE[+] y)£%A;{ /* last axis reduce rank-2 or greater matrix w/no smarts */£%A;  sy = shape(y);£%A;  zrho = drop([-1], sy);£%A;  z = with {£%A;£%9; (. &lt;= iv &lt;= .) £%A;£%9;£%9;: $FNAME(y[iv]);£%A;£%9;} : genarray(zrho, $OTFILL); £%A;  return(z);£%A;}£%A;%Generate $FN, sl, X$YT$ZT, X10, ., $ZT£%A;£%A;£%A;%%%%%%%%%%%%%%%%%%%%% first-axis reduce on rank-2 arrays  %%%%%%%%%%%%%%%%%%£%A;£%A;%Fragment  sl1  x21 bidc bidc bidc QUICKSTOP£%A;inline $ZTYPE[.] $FNAMEQUICKSTOP($YTYPE[.,.] y)£%A;{ /* first-axis reduce rank-2 matrix with quickstop */£%A;  yt = TRANSPOSE(y);£%A;  zrho = drop([-1], shape(yt));£%A;  z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNslX$YT$ZTQUICKSTOP(yt[iv]);£%A;£%9;} : genarray(zrho, $OTFILL);£%A;  return(z);£%A;}£%A;%Generate $FN, £%9;sl, £%9;£%9;X$YT$ZT, X10,£%9;QUICKSTOP, $ZT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$YT$YT, X**,£%9;., $YT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$ZT$ZT, X**,£%9;., $ZT£%A;£%A;£%A;%Fragment  sl1  x21 bidc bidc bidc FOLD£%A;inline $ZTYPE[.] $FNAMEFOLD($YTYPE[.,.] y)£%A;{ /* first-axis reduce rank-2 matrix */£%A;  yt = TRANSPOSE(y);£%A;  zrho = drop([-1], shape(yt));£%A;  z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNslX$YT$ZTFOLD(yt[iv]);£%A;£%9;} : genarray(zrho, $OTFILL);£%A;  return(z);£%A;}£%A;%Generate $FN, £%9;sl, £%9;£%9;X$YT$ZT, X10,£%9;FOLD, $ZT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$YT$YT, X**,£%9;., $YT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$ZT$ZT, X**,£%9;., $ZT£%A;£%A;%Fragment  sl1  x21 bidc bidc bidc .£%A;inline $ZTYPE[.] $FNAME($YTYPE[.,.] y)£%A;{ /* first-axis reduce rank-2 matrix */£%A;  yt = TRANSPOSE(y);£%A;  zrho = drop([-1], shape(yt));£%A;  z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNslX$YT$ZT(yt[iv]);£%A;£%9;} : genarray(zrho, $OTFILL);£%A;  return(z);£%A;}£%A;%Generate $FN, £%9;sl, £%9;£%9;X$YT$ZT, X10,£%9;., $ZT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$YT$YT, X**,£%9;., $YT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$ZT$ZT, X**,£%9;., $ZT£%A;£%A;£%A;%%%%%%%%%%%%%%%%%%%%% first-axis reduce on rank&gt;2 arrays  %%%%%%%%%%%%%%%%%%£%A;£%A;%Fragment  sl1  x** bidc bidc bidc QUICKSTOP£%A;inline $ZTYPE[+] $FNAMEQUICKSTOP($YTYPE[+] y)£%A;{ /* first-axis reduce rank-3 or greater matrix with quickstop */£%A;  yt = TRANSPOSE(y);£%A;  zrho = drop([-1], shape(yt));£%A;  z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNslX$YT$ZTQUICKSTOP(yt[iv]);£%A;£%9;} : genarray(zrho, $OTFILL);£%A;  z = TRANSPOSE(z);£%A;  return(z);£%A;}£%A;%Generate $FN, £%9;sl, £%9;£%9;X$YT$ZT, X10,£%9;QUICKSTOP, $ZT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$YT$YT, X**,£%9;., $YT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$ZT$ZT, X**,£%9;., $ZT£%A;% We distinguish rank-2 from rank-3 and up reductions, because£%A;% the former doesn't want the trailing TRANSPOSE.£%A;£%A;£%A;%Fragment  sl1  x** bidc bidc bidc FOLD£%A;inline $ZTYPE[+] $FNAMEFOLD($YTYPE[+] y)£%A;{ /* first-axis reduce rank-3 or greater matrix */£%A;  yt = TRANSPOSE(y);£%A;  zrho = drop([-1], shape(yt));£%A;  z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNslX$YT$ZTFOLD(yt[iv]);£%A;£%9;} : genarray(zrho, $OTFILL);£%A;  z = TRANSPOSE(z);£%A;  return(z);£%A;}£%A;%Generate $FN, £%9;sl, £%9;£%9;X$YT$ZT, X10,£%9;FOLD, $ZT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$YT$YT, X**,£%9;., $YT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$ZT$ZT, X**,£%9;., $ZT£%A;£%A;%Fragment  sl1  x** bidc bidc bidc .£%A;inline $ZTYPE[+] $FNAME($YTYPE[+] y)£%A;{ /* first-axis reduce rank-3 or greater matrix */£%A;  yt = TRANSPOSE(y);£%A;  zrho = drop([-1], shape(yt));£%A;  z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNslX$YT$ZT(yt[iv]);£%A;£%9;} : genarray(zrho, $OTFILL);£%A;  z = TRANSPOSE(z);£%A;  return(z);£%A;}£%A;%Generate $FN, £%9;sl, £%9;£%9;X$YT$ZT, X10,£%9;., $ZT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$YT$YT, X**,£%9;., $YT£%A;%Generate ,  £%9;TRANSPOSE,£%9;X$ZT$ZT, X**,£%9;., $ZT£%A;£%A;</string></array>
<array><shape>140</shape><string>% Code fragments for monadic Conjunctions. Cut comes to mind...£%A;%£%A;%Fragment     nope x00           No monadic conjunctions today. Sorry£%A;foo£%A;</string></array>
<array><shape>3563</shape><string>% SAC Code fragments for rank conjunctions£%A;% Robert Bernecky 2006-08-17£%A;£%A;%Fragment nuax x00 x bidc bidc .£%A;inline $ZTYPE $FNAME($YTYPE y$SYSVARFGDECL)£%A;{ /* S monadic rank conj */ £%A;  z =  $FN$XT$YT$ZT(y$SYSVARGKER);£%A;  return(z);£%A;} £%A;%Generate , $FN, X$YT$ZT, X00, ., $CT£%A;£%A;%Fragment nuax x** x bidc bidc EXTY£%A;inline $ZTYPE[*] $FNAMEEXTY($YTYPE[+] y$SYSVARFGDECL)£%A;{ /* Monadic rank conjunction on non-scalar. Extend right argument */£%A; yframeshape = drop([-$YRANK], shape(y));£%A; xcellshape =  take([-$XRANK], shape(x));£%A; ycellshape =  take([-$YRANK], shape(y));£%A; defcell = genarray($ZCELLSHAPE, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;  £%9;£%9;: $FNX$YT$ZT(x[iv], y$SYSVARGKER);£%A;£%9;} : genarray(yframeshape, defcell);£%A;  return(z);£%A;} £%A;%Generate , $FN, X$YT$ZT, X$YRANK*, ., $CT£%A;£%A;%Fragment nuax 000 bidc bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE x, $YTYPE y$SYSVARFGDECL)£%A;{ /* SxS dyadic rank conj */ £%A;  z =  $FN$XT$YT$ZT(x,y$SYSVARGKER);£%A;  return(z);£%A;} £%A;%Generate , $FN, $XT$YT$ZT, 000, ., $CT£%A;£%A;%Fragment nuax 0** bidc bidc bidc EXTX£%A;inline $ZTYPE[*] $FNAMEEXTX($XTYPE x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* SxA rank conjunction. Extend left argument */ £%A; yframeshape = drop([-$YRANK], shape(y));£%A; xcellshape =  take([-$XRANK], shape(x));£%A; ycellshape =  take([-$YRANK], shape(y));£%A; defcell = genarray($ZCELLSHAPE, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;  £%9;£%9;: $FN$XT$YT$ZT(x, y[iv]$SYSVARGKER);£%A;£%9;} : genarray(yframeshape, defcell);£%A;  return(z);£%A;} £%A;%Generate , $FN, $XT$YT$ZT, $XRANK$YRANK*, ., $CT£%A;£%A;%Fragment nuax *0* bidc bidc bidc EXTY£%A;inline $ZTYPE[*] $FNAMEEXTY($XTYPE x[+], $YTYPE y$SYSVARFGDECL)£%A;{ /* AxS rank conjunction. Extend right argument */ £%A; xframeshape = drop([-$XRANK], shape(x));£%A; xcellshape =  take([-$XRANK], shape(x));£%A; ycellshape =  take([-$YRANK], shape(y));£%A; defcell = genarray($ZCELLSHAPE, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;  £%9;£%9;: $FN$XT$YT$ZT(x, y[iv]$SYSVARGKER);£%A;£%9;} : genarray(xframeshape, defcell);£%A;  return(z);£%A;} £%A;%Generate , $FN, $XT$YT$ZT, $XRANK$YRANK*, ., $CT£%A;£%A;%Fragment nuax *** bidc bidc bidc EXTX£%A;inline $ZTYPE[*] $FNAMEEXTX($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* AxA rank conjunction. Extend left argument */ £%A; yframeshape = drop([-$YRANK], shape(y));£%A; xcellshape =  take([-$XRANK], shape(x));£%A; ycellshape =  take([-$YRANK], shape(y));£%A; defcell = genarray($ZCELLSHAPE, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;  £%9;£%9;: $FN$XT$YT$ZT(x, y[iv]$SYSVARGKER);£%A;£%9;} : genarray(yframeshape, defcell);£%A;  return(z);£%A;} £%A;%Generate , $FN, $XT$YT$ZT, $XRANK$YRANK*, ., $CT£%A;£%A;%Fragment nuax *** bidc bidc bidc EXTY£%A;inline $ZTYPE[*] $FNAMEEXTY($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* AxA rank conjunction. Extend right argument */ £%A; xframeshape = drop([-$YRANK], shape(x));£%A; xcellshape =  take([-$XRANK], shape(x));£%A; ycellshape =  take([-$YRANK], shape(y));£%A; defcell = genarray($ZCELLSHAPE, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;  £%9;£%9;: $FN$XT$YT$ZT(x[iv], y$SYSVARGKER);£%A;£%9;} : genarray(xframeshape, defcell);£%A;  return(z);£%A;} £%A;%Generate , $FN, $XT$YT$ZT, $XRANK$YRANK*, ., $CT£%A;£%A;%Fragment nuax *** bidc bidc bidc . £%A;inline $ZTYPE[*] $FNAME($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* AxA rank conjunction. No extension */ £%A;/* requires checks for length error!! rbe 2005-09-05 */£%A; xframeshape = drop([-$XRANK], shape(x));£%A; yframeshape = drop([-$YRANK], shape(y));£%A; xcellshape =  take([-$XRANK], shape(x));£%A; ycellshape =  take([-$YRANK], shape(y));£%A; defcell = genarray($ZCELLSHAPE, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;  £%9;£%9;: $FN$XT$YT$ZT(x[iv], y[iv]$SYSVARGKER);£%A;£%9;} : genarray(xframeshape, defcell);£%A;  return(z);£%A;} £%A;%Generate , $FN, $XT$YT$ZT, $XRANK$YRANK*, ., $CT£%A;£%A;</string></array>
<array><shape>8970</shape><string>% SAC Code fragments for monadic upgrade, downgrade£%A;% Robert Bernecky 2006-11-09£%A;£%A;£%A;%Fragment ugrd x11 x b i . £%9;Vector upgrade on Booleans£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)£%A;{ /* Upgrade of boolean-valued vector */£%A;  /* ((~y)/iota rho y),y/iota rho y */£%A;  /* Model upgradeBV2 from workspace 42 upgrade: rbe/2005-12-11 */£%A;/*£%A;£%9;z{&lt;-}upgradeBV2 bv;s;n0;n1;i£%A;£%9;@ upgrade boolean vector£%A;£%9;s{&lt;-}+/bv£%A;£%9;z{&lt;-}({rho}bv){rho}{neg}1£%A;£%9;n0{&lt;-}0£%A;£%9;n1{&lt;-}({rho}bv)[0]-s£%A;£%9;:for i :in {iota}{rho}bv£%A;£%9; :if ~bv[i]£%A;£%9;  z[n0]{&lt;-}i£%A;£%9;  n0{&lt;-}n0+1£%A;£%9; :else£%A;£%9;  z[n1]{&lt;-}i£%A;£%9;  n1{&lt;-}n1+1£%A;£%9; :endif£%A;£%9;:endfor£%A;*/£%A;£%A; s = sum(toi(y));£%A; shpy = shape(y)[[0]];£%A; z = genarray(shape(y),-1);£%A; n0 = 0;£%A; n1 = shpy-s;£%A; for(i=0; i&lt;shpy; i++){£%A;   if (false == tob(y[[i]]))£%A;£%9;{z[[n0]] = i; n0++;}£%A;   else£%A;£%9;{z[[n1]] = i; n1++;}£%A; }£%A; return(z+QUADio);£%A;}£%A;%Generate , iota, XII, X01, ., I £%A;£%A;%Fragment dgrd x11 x b i . £%9;Vector downgrade on Booleans£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)£%A;{ /* Downgrade of boolean vector. */£%A;  /* (y/iota rho y),(~y)/iota rho y */£%A;  /* See APL model downgradeBV2 in workspace 42 upgrade£%A;   * R. Bernecky 2005-11-04£%A;   */£%A; s = sum(toi(y));£%A; z = genarray(shape(y),-1);£%A; shpy = shape(y)[[0]];£%A; n0 = shpy-1;£%A; n1 = s-1;£%A; for(i=shpy-1; i&gt;=0; i--)£%A;   if (false == tob(y[[i]]))£%A;£%9;{z[[n0]] = i; n0--;}£%A;   else£%A;£%9;{z[[n1]] = i; n1--;}£%A; return(z+QUADio); £%A;}£%A;£%A;%Fragment ugrdPV x11 x bi i PV   Vector upgrade of permutation vector£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)£%A;{ /* Upgrade of permutation vector. */£%A;  /* This exploits array predicate astPredPV */£%A;  z = genarray(shape(y), -1);£%A;  for( i=0; i&lt;shape(y)[0]; i++) {£%A;£%9;z[[y[[i]]]] = i+QUADio;£%A;  }£%A; return(z); £%A;}£%A;£%A;£%A;%Fragment dgrdPV x11 x bi i  PV downgrade on permutation vector£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y, int QUADio)£%A;{ /* Downgrade of permutation vector. */£%A;  /* This exploits array predicate astPredPV */£%A;  z = genarray(shape(y), -1);£%A;  size = shape(y)[0];£%A;  for( i=0; i&lt;size; i++) {£%A;£%9;z[[(size-1)-y[[i]]]] = i+QUADio;£%A;  }£%A; return(z); £%A;}£%A;£%A;%Fragment ugrd x** x bidc i    .  £%A;inline $ZTYPE[.] $FNAME($YTYPE[+] y, int QUADio)£%A;{ /* Vector/matrix upgrade  */£%A; z = QUADio + UpgradeHeap(y); £%A; return( z);£%A;}£%A;%Generate , UpgradeHeap, X$YTI, X**, ., $CT£%A;£%A;%Fragment UpgradeHeap x** x bidc i    .  internal matrix upgrade£%A;inline $ZTYPE[.] UpgradeHeap($YTYPE[+] y)£%A;{ £%A;/*    Do APL upgrade of array y using heapsort.£%A;      This is a sub-function shared by upgrade/downgrade/indexof, etc.£%A;      This version adapted from the Sara Baase "Computer Algorithms"£%A;      version of heapsort.£%A;     Robert Bernecky 2006-11-14£%A;     Knuth, Vol. III, pp. 145-148 gives a good example. £%A;     APL model: (See workspace apex2003/wss/upgrade or£%A;                 apex2003/wif/upgrade)£%A;£%9;£%9;Also UTGrade.dws£%A;r{&lt;-}upgradeHeap v;#io;N;heap£%A;@ Upgrade vector using heapsort£%A;#io{&lt;-}0£%A;N{&lt;-}{rho}v£%A;:if N{&lt;=}1£%A;  r{&lt;-}{iota}N£%A;:else£%A;  heap{&lt;-}MakeHeap(v)£%A;  r{&lt;-}(UnHeap(heap))£%A;:endif£%A;*/£%A;£%A; N = shape(y)[[0]];£%A; if (N &lt;= 1)£%A;£%9;z = iota(N); £%A; else{£%A;£%9;heap = MakeHeap(y);£%A;£%9;z = UnHeap(heap,y);£%A; }£%A; return(z);£%A;}£%A;£%A;£%A;inline int[.] MakeHeap($YTYPE[+] v)£%A;{ /* Build heap from array v. v has at least two elements */£%A;/*£%A;r{&lt;-}MakeHeap v;i;n;heap;biggest£%A;@ Build heap from v£%A;@ We know v has at least two elements£%A;N{&lt;-}{rho}v£%A;heap{&lt;-}{iota}N£%A;:for i :in {reverse}{iota}{floor}N{divide}2£%A;  y FixHeap i,heap[i],n£%A;:endfor£%A;r{&lt;-}heap£%A;*/£%A; n = shape(v)[[0]];£%A; heap = iota(n);£%A; lim = n/2;£%A; for(i=lim-1; i&gt;=0; i--) {£%A;£%9;heap = FixHeap(heap, v, i, heap[[i]], n);£%A; }£%A; return(heap);£%A;}£%A;£%A;inline int[.] UnHeap(int[.] heap, $YTYPE[+]v)£%A;{ /* Extract heap elements in top-to-bottom order */£%A;  n = shape(v)[[0]];£%A;  for(heapsize= n-1; heapsize&gt;0; heapsize--){£%A;£%9;biggest = heap[[0]];£%A;        heap = FixHeap(heap,v,0,heap[[heapsize]],heapsize);£%A;£%9;heap[[heapsize]] = biggest;£%A;  }£%A; return(heap);£%A;}£%A;£%A;inline int[.] FixHeap(int[.] heap, $YTYPE[+] v, int root, £%A;£%9;int heapitem, int heapsize)£%A;{ /* Restore heap invariant: parent&gt;= both children */£%A; vacant = root;£%A; lchild = 1+vacant+vacant;£%A; while( lchild &lt; heapsize) {£%A;£%9;bigC = lchild;      /* Identify larger child, if any */£%A;£%9;rchild = lchild+1;£%A;£%9;if ((lchild&lt;(heapsize-1))){£%A;£%9;£%9;li = heap[[lchild]];£%A;  £%9;£%9;ri = heap[[rchild]]; £%A;£%9;£%9;if ((GradeGT(v[[ri]],v[[li]])) || £%A;£%9;£%9;£%9;(match(v[[ri]], v[[li]])&amp;&amp;(ri&gt;li))){ /* Stability */£%A;£%9;£%9;bigC = rchild; /* right child larger */£%A;£%9;£%9;}£%A;£%9;}£%A;£%9;/* parent vs big kid*/£%A;£%9;li = heap[[bigC]];£%A;£%9;if ((GradeGT( v[[li]], v[[heapitem]])) ||£%A;£%9;£%9;(match(v[[li]], v[[heapitem]]) &amp;&amp;(li&gt;heapitem))) {£%A;£%9;£%9;£%9;heap[[vacant]] = heap[[bigC]];£%A;£%9;£%9;£%9;vacant = bigC;£%A;£%9;£%9;£%9;lchild = 1+vacant+vacant;£%A;£%9;} else lchild = heapsize;   /* exitloop */£%A; }£%A; heap[[vacant]] = heapitem;£%A; return(heap);£%A;}£%9;£%9;£%A;%Generate , GradeGT, $YT$YTB, 000, ., $CT£%A;%Generate , GradeGT, $YT$YTB, **0, ., $CT£%A;£%A;%Fragment GradeGT 000 i i b .£%A;inline bool GradeGT(int x, int y)£%A;{ /* Integer Comparator for upgrade */£%A; return(x&gt;y);£%A;}£%A;£%A;%Fragment GradeGT 000 b b b .£%A;inline bool GradeGT(bool x, bool y)£%A;{ /* Boolean Comparator for upgrade */£%A; return(x &amp; !y);£%A;}£%A;£%A;%Fragment GradeGT 000 d d  b .£%A;inline bool GradeGT(double x, double y)£%A;{ /* Double Comparator for upgrade */£%A; return(x&gt;y);£%A;}£%A;£%A;%Fragment GradeGT 000 c c  b .£%A;inline bool GradeGT(char x, char y)£%A;{ /* Char Comparator for upgrade */£%A; return(x&gt;y);£%A;}£%A;£%A;£%A;%Fragment GradeGT **0 b b b .£%A;inline bool GradeGT(bool[+] x, bool[+] y)£%A;{ /* Boolean Array Comparator for upgrade */£%A;  /* The ravels of the two arrays are compared.  */£%A; z = with {£%A;       (0*shape(x) &lt;= iv &lt; shape(x))£%A;£%9;£%9;: x[iv] &gt; y[iv];£%A;#ifdef FOLDFIXBUG£%A; /* foldfix kills sac2c with DFM bug */£%A;        }: foldfix( &amp;, true,false);£%A;#else£%A;        }: fold( &amp;, true);£%A;#endif£%A;£%A; return(z);£%A;}£%A;£%A;%Fragment GradeGT **0 c c b .£%A;inline bool GradeGT(char[+] x, char[+] y)£%A;{ /* Char Array Comparator for upgrade */£%A;  /* The ravels of the two arrays are compared.  */£%A; z = with {£%A;       (0*shape(x) &lt;= iv &lt; shape(x))£%A;£%9;£%9;: x[iv] &gt; y[iv];£%A;#ifdef FOLDFIXBUG£%A; /* foldfix kills sac2c with DFM bug */£%A;        }: foldfix( &amp;, true,false);£%A;#else£%A;        }: fold( &amp;, true);£%A;#endif£%A; return(z);£%A;}£%A;£%A;%Fragment GradeGT **0 i i b .£%A;inline bool GradeGT(int[+] x, int[+] y)£%A;{ /* Integer Array Comparator for upgrade */£%A;  /* The ravels of the two arrays are compared.  */£%A; z = with {£%A;       (0*shape(x) &lt;= iv &lt; shape(x))£%A;£%9;£%9;: x[iv] &gt; y[iv];£%A;#ifdef FOLDFIXBUG£%A; /* foldfix kills sac2c with DFM bug */£%A;        }: foldfix( &amp;, true,false);£%A;#else£%A;        }: fold( &amp;, true);£%A;#endif£%A; return(z);£%A;}£%A;£%A;%Fragment GradeGT **0 d d b .£%A;inline bool GradeGT(double[+] x, double[+] y)£%A;{ /* Double Array Comparator for upgrade */£%A;  /* The ravels of the two arrays are compared.  */£%A; z = with {£%A;       (0*shape(x) &lt;= iv &lt; shape(x))£%A;£%9;£%9;: x[iv] &gt; y[iv];£%A;#ifdef FOLDFIXBUG£%A; /* foldfix kills sac2c with DFM bug */£%A;        }: foldfix( &amp;, true,false);£%A;#else£%A;        }: fold( &amp;, true);£%A;#endif£%A; return(z);£%A;}£%A;£%A;%Fragment dgrd x** x bidc i    .  £%A;inline $ZTYPE[.] $FNAME($YTYPE[+] y, int QUADio)£%A;{ /* Do APL downgrade of array y using heapsort. */£%A; z = QUADio + DowngradeHeap( y);£%A; return(z);£%A;}£%A;%Generate , DowngradeHeap, X$YTI, X**, ., $CT£%A;£%A;%Fragment DowngradeHeap x** x bidc i    .  £%A;inline $ZTYPE[.] DowngradeHeap($YTYPE[+] y)£%A;{ /* Do APL downgrade of array y using heapsort.£%A;      This is a sub-function shared by upgrade/downgrade/indexof, etc.£%A;     This version adapted from the Sara Baase "Computer Algorithms"£%A;     version of heapsort.£%A;     Knuth, Vol. III, pp. 145-148 gives a good example. £%A;     APL model: (See workspace apex2003/benchmks/UTGrade or£%A;                 apex2003/wif/upgrade)£%A;*/£%A;£%A; N = shape(y)[[0]];£%A; if (N &lt;= 1)£%A;£%9;z = iota(N); £%A; else{£%A;£%9;heap = MakeDHeap(y);£%A;£%9;z = UnDHeap(heap,y);£%A; }£%A; return(z);£%A;}£%A;£%A;£%A;inline int[.] MakeDHeap($YTYPE[+] v)£%A;{ /* Build downgrade heap from v. v has at least two elements */£%A; n = shape(v)[[0]];£%A; heap = iota(n);£%A; lim = n/2;£%A; for(i=lim-1; i&gt;=0; i--) {£%A;£%9;heap = FixDHeap(heap, v, i, heap[[i]], n);£%A; }£%A; return(heap);£%A;}£%A;£%A;inline int[.] UnDHeap(int[.] heap, $YTYPE[+]v)£%A;{ /* Extract heap elements in top-to-bottom order */£%A;  n = shape(v)[[0]];£%A;  for(heapsize= n-1; heapsize&gt;0; heapsize--){£%A;£%9;biggest = heap[[0]];£%A;        heap = FixDHeap(heap,v,0,heap[[heapsize]],heapsize);£%A;£%9;heap[[heapsize]] = biggest;£%A;  }£%A; return(heap);£%A;}£%A;£%A;inline int[.] FixDHeap(int[.] heap, $YTYPE[+] v, int root, £%A;£%9;int heapitem, int heapsize)£%A;{ /* Restore heap invariant: parent&lt;= both children */£%A; vacant = root;£%A; lchild = 1+vacant+vacant;£%A; while( lchild &lt; heapsize) {£%A;£%9;bigC = lchild;      /* Identify larger child, if any */£%A;£%9;rchild = lchild+1;£%A;£%9;if ((lchild&lt;(heapsize-1))){£%A;£%9;£%9;li = heap[[lchild]];£%A;  £%9;£%9;ri = heap[[rchild]]; £%A;£%9;£%9;if ((GradeGT(v[[li]], v[[ri]])) || £%A;£%9;£%9;£%9;(match(v[[ri]],v[[li]]))&amp;&amp;(ri&gt;li)){ /* Stability */£%A;£%9;£%9;bigC = rchild; /* right child larger */£%A;£%9;£%9;}£%A;£%9;}£%A;£%9;/* parent vs big kid*/£%A;£%9;li = heap[[bigC]];£%A;£%9;if ((GradeGT( v[[heapitem]], v[[li]])) ||£%A;£%9;£%9;(match(v[[li]], v[[heapitem]]) &amp;&amp;(li&gt;heapitem))) {£%A;£%9;£%9;£%9;heap[[vacant]] = heap[[bigC]];£%A;£%9;£%9;£%9;vacant = bigC;£%A;£%9;£%9;£%9;lchild = 1+vacant+vacant;£%A;£%9;} else lchild = heapsize;   /* exitloop */£%A; }£%A; heap[[vacant]] = heapitem;£%A; return(heap);£%A;}£%9;£%9;£%A;%Generate , GradeGT, $YT$YTB, 000, ., $CT£%A;%Generate , GradeGT, $YT$YTB, **0, ., $CT£%A;£%A;</string></array>
<array><shape>1733</shape><string>/*£%A; * Monadic miscfns£%A; * Will eventually handle:£%A; * £%9;shape, index generator, matrix inverse,£%A; * £%9;dex, nubsieve, thorn£%A; * Robert Bernecky 2007-05-13£%A; */£%A;£%A;%Fragment iota x01 x bidc i .£%A;inline int[.] $FNAME($YTYPE y, int QUADio)£%A;{ /* Index generator on scalar */£%A;/* HELP! Needs domain check for negative shp */£%A;  z = QUADio+iota(toi(y));£%A;  return( z);£%A;}£%A;£%A;%Fragment iota x01 x bidc i NonNeg£%A;inline int[.] $FNAMENonNeg($YTYPE y, int QUADio)£%A;{ /* Index generator on ScalarN when N is non-negative integer */£%A;  z = QUADio+iota(toi(y));£%A;  return( z);£%A;}£%A;£%A;%Fragment iota x11 x bidc i .£%A;inline int[.] $FNAME($YTYPE[1] y, int QUADio)£%A;{ /* Index generator on 1-element vector */£%A; /* HELP! Needs length error check */£%A;/* HELP! Needs domain check for negative shp */£%A;  z = QUADio+iota(toi(y[[0]]));£%A;  return( z);£%A;}£%A;£%A;%Fragment iota x11 x bidc i NonNeg£%A;inline int[.] $FNAMENonNeg($YTYPE[1] y, int QUADio)£%A;{ /* Index generator on 1-element vector, known to be non-negative integer */£%A;  z = QUADio+iota(toi(y[[0]]));£%A;  return( z);£%A;}£%A;£%A;%Fragment ltak *** x bidc bidc .£%A;inline $YTYPE[*] $FNAME($YTYPE[*] y) £%A;{ /* Dex on anything */£%A;£%9;return(y);£%A;}£%A;£%A;%Fragment rho x01 x bidc i . £%A;inline int[0] $FNAME($YTYPE y) £%A;{ /* Shape of scalar */£%A; return(shape(y));£%A;}£%A;£%A;%Fragment rho x11 x bidc i .£%A;inline int[1]  $FNAME($YTYPE[.] y) £%A;{ /* Shape of vector */£%A; return(shape(y));£%A;}£%A;£%A;%Fragment rho x21 x bidc i .£%A;inline int[2]  $FNAME($YTYPE[.,.] y) £%A;{ /* Shape of matrix (rank-2) */£%A; return(shape(y));£%A;}£%A;£%A;%Fragment rho x*1 x bidc i .£%A;inline int[.]  $FNAME($YTYPE[+] y) £%A;{ /* Shape of rank-3 or higher */£%A; return(shape(y));£%A;}£%A;£%A;%Fragment quad x** x bidc bidc .£%A;inline $ZTYPE[*] $FNAME($YTYPE[*] y, int QUADpp, int QUADpw)£%A;{ /* {quad}{&lt;-} anything */£%A;£%9;show(y);£%A;£%9;return(y);£%A;}£%A;</string></array>
<array><shape>2260</shape><string>% Monadic Scalar Function code fragments£%A;% Converted to SAC 2005-11-03 R. Bernecky£%A;%£%A;% All code fragments presume that the argument has already been£%A;% converted to the correct compute type.£%A;%         jsym  ranks£%9;lt rt   zt£%A;£%A;% IF you're seeking query, it lives in query.frg, because£%A;% it is NOT a scalar function on parallel machines!£%A;£%A;%Fragment mod   x00 x  b    b .£%A;inline bool $FNAME($YTYPE y)£%A;{ /* Absolute value Boolean (NOP) */£%A; return(tob(y));£%A;}£%A;£%A;%Fragment mod   x00 x  id    id .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ return(abs(to$CT(y)));£%A;}£%A;£%A;%Fragment bar   x00 x  b    b .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ return(!y);£%A;}£%A;£%A;%Fragment bar   x00 x  id    id£%9; .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ return(-y);£%A;}£%A;£%A;%Fragment plus  x00 x  bid  bid .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ return(y);£%A;}£%A;£%A;%Fragment min   x00 x bi bi .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ return(y);£%A;}£%A;£%A;%Fragment min   x00 x d  i .£%A;inline $ZTYPE $FNAME($YTYPE y,double QUADct)£%A;{ return(DFLOOR(y,QUADct));£%A;}£%A;%Generate , DFLOOR, X$YT$ZT, X00, ., $CT£%A;£%A;£%A;%Fragment max   x00 x bi bi .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* Boolean/integer ceiling (NOP) */£%A;  return(y);£%A;}£%A;£%A;%Fragment max   x00 x d  i .£%A;inline $ZTYPE $FNAME($YTYPE y, double QUADct)£%A;{ /* Ceiling */£%A; return(-DFLOOR(-y, QUADct));£%A;}£%A;%Generate , DFLOOR, X$YT$ZT, X00, ., $CT£%A;£%A;%Fragment mpy   x00 x b  b .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* Boolean signum (NOP) */£%A; return(y);£%A;}£%A;£%A;%Fragment mpy   x00 x i i .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* signum int */£%A; if (0 == toi(y))£%A;        z = 0;£%A; else if (0 &gt; toi(y))£%A;        z = -1;£%A; else£%A;        z = 1;£%A; return(z);£%A;}£%A;£%A;%Fragment mpy   x00 x d i .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* double signum */£%A; if (0.0 == tod(y))£%A;        z = 0;£%A; else if (0.0 &gt; tod(y))£%A;        z = -1;£%A; else£%A;        z = 1;£%A; return(z);£%A;}£%A;£%A;%Fragment not   x00 x bid b .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* Boolean NOT */£%A;  return(!tob(y));£%A;}£%A; £%A;%Fragment div   x00 x bid d .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ return(1.0/tod(y));£%A;}£%A;£%A;%Fragment star  x00 x bid d .£%A;inline $ZTYPE $FNAME ($YTYPE y)£%A;{ return(pow(2.718281828459046,tod(y)));£%A;}£%A;£%A;%Fragment log   x00 x bid d .£%A;inline $ZTYPE $FNAME ($YTYPE y)£%A;{ return(log(tod(y)));£%A;}£%A;£%A;%Fragment circ  x00 x bid d .£%A;inline $ZTYPE $FNAME ($YTYPE y)£%A;{ return(3.1415926535897632*tod(y));£%A;}£%A;</string></array>
<array><shape>376</shape><string>% APEX code fragments for monadic scalar functions.£%A;% R. Bernecky 2006-01-05£%A;£%A;%Fragment msfctl x** x bidc bidc .£%A;inline $ZTYPE[+]$SYSVARGOUT $FNAME($YTYPE[+] y$SYSVARGDECL)£%A;{ /* Monadic scalar functions on array */£%A;  z = with { £%A;£%9;( . &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNX$CT$ZT(to$CT(y[iv])$SYSVARGKER);£%A;£%9;} : genarray(shape(y), $OTFILL);£%A;  return(z);£%A;}£%A;%Generate , $FN, $XT$CT$ZT, x00, ., $CT£%A;</string></array>
<array><shape>2529</shape><string>% Code fragments for monadic structural function loop structures.£%A;% 2004-08-14£%A;%£%A;%Fragment tran x00  x bidc bidc .£%A;%Fragment rotr x00  x bidc bidc .£%A;%Fragment rot1 x00  x bidc bidc .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* Tranpose and rotate on scalars are NOPs */ £%A;return(y);£%A;}£%A;£%A;%Fragment coma x01 x bidc bidc .£%A;inline $ZTYPE[.] $FNAME($YTYPE y)£%A;{ /* Ravel of scalar */£%A;£%9;return([y]);£%A;}£%A;£%A;%Fragment comb x02 x bidc bidc .£%A;inline $ZTYPE[1,1] $FNAME($YTYPE y)£%A;{ /* Table of scalar */£%A; z = reshape([1,1],y);£%A; return(z);£%A;}£%A;£%A;%Fragment comb x12 x bidc bidc .£%A;inline $ZTYPE[.,1] $FNAME($YTYPE[.] y)£%A;{ /* Table on vector */£%A; z = reshape([shape(y),1],y);£%A; return(z);£%A;}£%A;£%A;%Fragment comb x22 x bidc bidc .£%A;inline $ZTYPE[.,.] $FNAME($YTYPE[.,.] y)£%A;{ /* Table on table is NOP */£%A;£%9;return(y);£%A;}£%A;£%A;%Fragment comb x** x bidc bidc .£%A;inline $ZTYPE[.,.] $FNAME($YTYPE[+] y)£%A;{ /* Table on matrix */£%A; shpy = shape(y);£%A; z = reshape(take([1],shpy),prod(drop([1],shpy)),y);£%A; return(z);£%A;}£%A;£%A;%Fragment tran x11 x bidc bidc .£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y)£%A;{ /* Transpose on vectors is NOP */ £%A;£%9;return(y);£%A;}£%A;£%A;%Fragment coma x11 x bidc bidc .£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y)£%A;{ /* Ravel of vector is NOP */  £%A;£%9;return(y);£%A;}£%A;£%A;£%A;%Fragment coma x*1 x bidc bidc .£%A;inline $ZTYPE[.] $FNAME($YTYPE[+] y)£%A;{ /* Ravel of anything with rank&gt;1 */£%A;£%9;z = reshape([prod(shape(y))],y);£%A;£%9;return(z);£%A;}£%A;£%A;%Fragment rotr x11 x bidc bidc .£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y)£%A;{ /* Vector reverse */£%A; n = shape(y);£%A; cell = $OTFILL;£%A; z = with {£%A;£%9;( . &lt;= iv &lt;= .)£%A;£%9;£%9;: y[(n-1)-iv];£%A;£%9;} : genarray(n, cell);£%A; return(z);£%A;}£%A;£%A;%Fragment rot1 x** x bidc bidc .£%A;inline $ZTYPE[+] $FNAME($YTYPE[+] y)£%A;{ /* First axis reverse on anything */£%A; frameshape = take([1],shape(y));£%A; cell = genarray(drop([1],shape(y)), $OTFILL);£%A; z = with {£%A;£%9;( . &lt;= iv &lt;= .)£%A;£%9;£%9;: y[(frameshape-[1])-iv];£%A;£%9;} : genarray(frameshape, cell);£%A; return(z);£%A;}£%A;£%A;%Fragment rotr x** x bidc bidc .£%A;inline $ZTYPE[+] $FNAME($YTYPE[+] y)£%A;{/* Last axis reverse on rank&gt;1 */£%A; cellshape = take([-1], shape(y));£%A; frameshape = drop([-1],shape(y));£%A; cell = genarray(cellshape, $OTFILL);£%A; z = with {£%A;£%9;( . &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNAME(y[iv]);£%A;£%9;} : genarray(frameshape, cell);£%A; return(z);£%A;}£%A;%Generate , $FN, $XT$YT$ZT, x11, ., $CT£%A;£%A;%Fragment tran x22 x bidc bidc .£%A;inline $ZTYPE[.,.] $FNAME($YTYPE[.,.] y)£%A;{ /* Transpose on rank-2 */£%A;£%9;z = { [i,j] -&gt; y[j,i] };£%A;£%9;return(z);£%A;}£%A;£%A;%Fragment tran x** x bidc bidc .£%A;inline $ZTYPE[+] $FNAME($YTYPE[+] y)£%A;{ /* General transpose */£%A;£%9;z = TRANSPOSE(y);£%A;£%9;return(z);£%A;}£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;</string></array>
<array><shape>1259</shape><string>% QUADfi and QUADvi code fragments£%A;%£%A;% Robert Bernecky 2006-03-05£%A;%£%A;% --------------- QUADfi fragments ----------------------------£%A;%Fragment quadfi x01  x c d .£%A;inline $ZTYPE[.] $FNAME($YTYPE y)£%A;{ /* QUADfi on scalar */£%A;if (£%A; z = toi(y)-toi('0');£%A; z = z *toi((z&gt;=0) &amp; (z&lt;=9));£%A; return([z]);£%A;}£%A;£%A;%Fragment quadfi x11  x c d .£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y)£%A;{ /* BROKEN!!!  QUADfi on vector */£%A;zshape = with {£%A;£%9; ([0] &lt;= iv &lt; shape(y)-[1])£%A;£%9;£%9;: toi((' ' == y[iv]) &amp;&amp; (' ' != y[iv+[1]]));£%A;£%9;} : fold(+, 0);£%A; zshape= zshape+1;£%A; z = genarray([zshape],-42.0);£%A; str = to_string(y);£%A; for(i=0; i&lt;zshape; i++){£%A;        v,str = strtod(str);£%A;        z[i] = v;£%A;        }£%A; return(z);£%A;}£%A;£%A;% --------------- QUADvi fragments ----------------------------£%A;%Fragment quadvi x01  x c bid .£%A;inline $ZTYPE[.] $FNAME($YTYPE y)£%A;{ /* QUADvi on scalar */£%A; z = toi( (y&gt;='0') &amp; (y&lt;='9'));£%A; return([z]);£%A;}£%A;£%A;%Fragment quadvi x11  x c bid .£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y)£%A;{ /* QUADvi on vector */£%A;zshape = with {£%A;£%9;([0] &lt;= iv &lt; shape(y)-[1])£%A;£%9;£%9;: toi((' ' == y[iv]) &amp;&amp; (' ' != y[iv+[1]]));£%A;£%9;} : fold(+, 0);£%A; zshape= zshape+1;£%A; z = genarray([zshape], false);£%A; str = to_string(y);£%A; for(i=0; i&lt;zshape; i++){£%A;        v,str = strtod(str);£%A;        z[i] = 0.0 != v;£%A;        }£%A;£%A; return(z);£%A;}£%A;</string></array>
<array><shape>2495</shape><string>%  Monadic query (roll) and Dyadic query (deal)£%A;%£%A;% Robert Bernecky 2006-07-27£%A;% SAC code generator£%A;%£%A;£%A;%Fragment quer X00 x bid i .£%A;inline $ZTYPE, int $FNAME($YTYPE y, int QUADio, int QUADrl)£%A;{ /* Monadic query (roll) -  scalar */£%A; inty = toi(y);£%A; if (inty &lt;= 0) print(tochar("roll domain error"));£%A; QUADrl = Lehmer(QUADrl);£%A; z = (tod(QUADrl) * tod(inty)) / tod(2147483647);£%A; return(toi(z) + QUADio, QUADrl);£%A;}£%A;%Generate , Lehmer, $XT$YT$ZT, X00, ., I£%A;£%A;£%A;%Fragment quer X** x bid i .£%A;inline $ZTYPE[+], int $FNAME($YTYPE[+] y, int QUADio, int QUADrl)£%A;{ /* Monadic query (roll) - non=scalar */£%A; zxrho = prod(shape(y));£%A; ravely = reshape([zxrho], y);£%A; inty = toi(y);£%A; if (any(inty &lt;= 0)) print(tochar("roll domain error"));£%A; /* The following presumes ordering, so we use FOR loop. Sorry */£%A; z = genarray([zxrho], -1);£%A; for (i=0; i&lt;zxrho; i++) {£%A;        QUADrl = Lehmer(QUADrl);£%A;£%9;val = (tod(QUADrl) * tod(ravely[[i]])) / tod(2147483647);£%A;        z[[i]] =  QUADio + toi(val);£%A; }£%A; z = reshape(shape(y), z);£%A; return(z, QUADrl);£%A;}£%A;%Generate , Lehmer, $XT$YT$ZT, X00, ., I£%A;£%A;£%A;%Fragment quer 001  bid bid i .£%A;inline $ZTYPE[.], int $FNAME($XTYPE x, $YTYPE y, int QUADio, int QUADrl)£%A;{ /* Dyadic query (deal) - scalar */£%A;  /* This allocates an array of shape y. If this£%A;   * causes you memory grief, use the algorithm in workspace 42 query,£%A;   * or use smaller y!£%A;   */£%A; intx = toi(x);£%A; inty = toi(y);£%A; shpz = toi(x);£%A; z = iota (( shape(y))[0]);£%A; for( i=0; i&lt;shape(x)[0]; i++) {£%A;£%9;rand, QUADrl = querXII(inty[[i]]-i, 0, QUADrl);£%A;£%9;c = i + rand;£%A;£%9;if ( c &lt; shpz) {£%A;£%9;£%9;tmp    = z[[c]];£%A;£%9;£%9;z[[c]] = z[[i]]; £%A;£%9;£%9;z[[i]] = tmp;£%A;£%9;}£%A; }£%9;£%A; z = take([intx], z);£%A; return(z + QUADio, QUADrl);£%A;}£%A;%Generate , quer, X$YT$ZT, X00, ., I £%A;£%A;%Fragment quer 111  bid bid i .£%A;inline $ZTYPE[.], int $FNAME($XTYPE[.] x, $YTYPE[.] y, int QUADio, int QUADrl)£%A;{ /* Dyadic query (deal) - non-scalar */£%A; /* need length error check FIXME */£%A; return(querIII(x[0],y[0],QUADio,QUADrl));£%A;}£%A;%Generate , quer, III, 000, ., I £%A;£%A;%Fragment quer 011  bid bid i .£%A;inline $ZTYPE[.], int $FNAME($XTYPE x, $YTYPE[.] y, int QUADio, int QUADrl)£%A;{ /* Dyadic query (deal) - non-scalar */£%A; /* need length error check FIXME */£%A; return(querIII(x,y[0],QUADio,QUADrl));£%A;}£%A;%Generate , quer, III, 000, ., I £%A;£%A;%Fragment quer 101  bid bid i .£%A;inline $ZTYPE[.], int $FNAME($XTYPE[.] x, $YTYPE y, int QUADio, int QUADrl)£%A;{ /* Dyadic query (deal) - non-scalar */£%A; /* need length error check FIXME */£%A; return(querIII(x[0],y,QUADio,QUADrl));£%A;}£%A;%Generate , quer, III, 000, ., I £%A;</string></array>
<array><shape>226</shape><string>% Code fragment for quote-quad input and probably others£%A;£%A;%Fragment qdd XX1 X X C .£%A;inline char[.] $FNAME()£%A;{ /* Quote-quad input */£%A;  arbitrarylimit = 100000;£%A;  z = drop([-1], tochar(scanl(arbitrarylimit)));£%A;  return( z);£%A;}£%A;£%A;</string></array>
<array><shape>6603</shape><string>% Code fragments for replicate and expand£%A;% Rewritten for SAC 2004-08-02 rbe£%A;£%A;% Fragment header:£%A;%  jsymbol xyz-ranks lefttypes righttypes resulttypes specialcasename£%A;%  1       2         3         4          5           6 £%A;£%A;%Fragment sl  001 bid bidc bidc .£%A;%Fragment sl1 001 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE y)£%A;{ /* Scalar replicate scalar */£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: y;£%A;£%9;} : genarray([toi(x)]);£%A; return(z);£%A;} £%A;£%A;%Fragment sl  101 b bidc bidc .£%A;%Fragment sl1 101 b bidc bidc .£%A;%Fragment sl  101 bid bidc bidc .£%A;%Fragment sl1 101 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{ /* Vector compress/replicate scalar */£%A; shpz = sum(toi(x));£%A; z = genarray([shpz],y);£%A; return(z);£%A;}£%A;£%A;%Fragment sl  111 bid bidc bidc . £%A;%Fragment sl1 111 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE[.] y)£%A;{/* vector compress/replicate vector */£%A; /* HELP! non-boolean left argument needs a range check */£%9;£%A; intx = toi(x);£%A; zxrho = sum(intx);£%A; z = genarray([zxrho], $OTFILL);£%A; zi = 0;£%A; for(i=0; i&lt;shape(x)[0]; i++)£%A;   for(k=0; k&lt;intx[[i]]; k++){£%A;    z[[zi]] = y[[i]];£%A;    zi++;£%A;   }£%A; return(z);£%A;}£%A;£%A;inline $ZTYPE[.] $FNAME($XTYPE[1] x, $YTYPE[.] y)£%A;{/* 1-element-vector compress/replicate vector */£%A; /* HELP! non-boolean left argument needs a range check */£%9;£%A; if (true == tob(x[[0]]))£%A;        z = y;£%A; else£%A;        z = genarray([0], $OTFILL);£%A; return(z);£%A;}£%A;£%A;%Fragment sl  011 bid bidc bidc .£%A;%Fragment sl1 011 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE[.] y)£%A;{ /* Scalar replicate vector */£%A; cell = genarray([toi(x)], $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: genarray([toi(x)], y[iv]);£%A;£%9;} : genarray(shape(y), cell);£%A; return(comaX$ZT$ZT(z));£%A;}£%A;%Generate , coma, X$ZT$ZT, X*1, ., $ZT£%A;£%A;%Fragment sl  0** b bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Scalar compress non-scalar */£%A;sy = shape(y);£%A;if (true == tob(x))£%A;£%9;z = y;£%A;else £%A;£%9;z = genarray(drop([-1],sy)++[0],$OTFILL);£%A;return(z);£%A;}£%9;£%A;£%A;%Fragment sl 0** id bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{/* Scalar replicate non-scalar */£%A; /* FIXME : domain check needed on x */£%A; ix = [toi(x)];£%A; frameshape = drop([-1],shape(y));  £%A; cellshape  = ix * take([-1],shape(y));£%A; defcell = genarray(cellshape, $OTFILL);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNAME(x, y[iv]);£%A;£%9;}: genarray(frameshape, defcell);£%A; return(z);£%A;}£%A;%Generate , $FN, $XT$YT$ZT, 011, ., $CT£%A;£%A;%Fragment sl 1** bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* Vector compress/replicate matrix */£%A;  /* This needs conformability check FIXME */£%A;  /* Also, x may be one-element vector */£%A; yt = TRANSPOSE(y);£%A; frameshape = take([1],shape(yt));£%A; cellshape  = drop([1],shape(yt));£%A; defcell = genarray(cellshape,$OTFILL);£%A; if (1 == shape(x)[[0]])  /* THIS IS BAD. Build x[1] version */£%A;£%9;x = genarray(frameshape, x[[0]]);£%A; z = genarray([sum(toi(x))], defcell);£%A; zi = 0;£%A; for(i=0; i&lt;shape(x)[[0]]; i++) {£%A;£%9;for(j = 0; j&lt;toi(x[[i]]); j++){£%A;        z[[zi]] = yt[[i]];£%A;        zi++;£%A;  }£%A;}£%A;return(TRANSPOSE(z));£%A;}£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;£%A;% ------------------ Code fragments for first axis replicate -----------£%A;£%A;£%A;%Fragment sl1 0** b bidc bidc . £%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Boolean scalar compress non-scalar, first axis */£%A;sy = shape(y);£%A;if (true == tob(x))£%A;        z = y;£%A;else£%A;        z = genarray([0]++drop([1],sy),$OTFILL);£%A;return(z);£%A;}£%A;£%A;%Fragment sl1 0** id bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Scalar replicate non-scalar, first axis */£%A; xi = [toi(x)];£%A; cellshape = xi++drop([1],shape(y));£%A; defcell = genarray(cellshape,$OTFILL);£%A; frameshape = take([1],shape(y));£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: genarray(xi,y[iv]);£%A;£%9;} : genarray(frameshape, defcell);£%A;£%A; zshape = [prod(take([2],shape(z)))]++drop([2],shape(z));£%A; z = reshape(zshape,z);£%A; return(z);£%A;}£%A;£%A;%Fragment sl1 1** bid bidc bidc  .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* Vector compress/replicate-first-axis matrix */£%A;  /* FIXME: needs conformability and domain checks on x */£%A; frameshape = take([1], shape(y));£%A; cellshape =  drop([1], shape(y));£%A; intx = toi(x);£%A; if (1 == shape(x)[[0]])£%A;£%9;intx = genarray(frameshape,intx[[0]]);£%A; zxrho = sum(intx);£%A; shpz = [zxrho]++cellshape;£%A; z = genarray(shpz,$OTFILL);£%A; zi = 0;£%A; for(i=0; i&lt;shape(intx)[0]; i++) {£%A;£%9;for(j = 0; j&lt;intx[[i]]; j++){£%A;£%9;£%9;z[[zi]] = y[[i]];£%A;£%9;£%9;zi++;£%A;£%9;}£%A; }£%A;return(z);£%A;}£%A;£%A;% ------------------------ Expand code fragments ----------------------£%A;£%A;%Fragment bsl  001 bid bidc bidc .£%A;%Fragment bsl1 001 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE y)£%A;{/* Scalar expand scalar (first or last axis) */£%A; /* In practice, one-element left arguments to expand£%A;  * are nearly useless... £%A;  */£%A; if (true == tob(x))£%A;£%9;z = [y];£%A; else£%A;£%9;z = [false];£%A; return(z);£%A;}£%A;£%A;%Fragment bsl  101 bid bidc bidc .£%A;%Fragment bsl1 101 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{/* Vector expand scalar (first or last axis) */£%A; v = [$OTFILL,y];£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: v[[toi(x[iv])]];£%A;£%9;} : genarray(shape(x));£%A; return(z);£%A;}£%A;£%A;%Fragment bsl 111 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE[.] y)£%A;{ /* Vector-vector expand */£%A; /* Stupid with-loops won't work here. */£%A; /* FIXME: Needs check that (+/x)= shape(y)[0] and x∧.GE 0 */£%A; yi=0;£%A; z= genarray(shape(x),$OTFILL);£%A; for (xi=0; xi&lt;shape(x)[[0]]; xi++){£%A;   if (tob(x[[xi]])){£%A;        z[[xi]]=y[[yi]];£%A;        yi++;£%A;   }£%A; }£%A; return(z);£%A;}£%A;£%A;£%A;%Fragment bsl 1** bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* vector expand matrix last axis */£%A; yt = TRANSPOSE(y);£%A; bx = tob(x);£%A; if (1 == shape(bx)[[0]])£%A;£%9;bx = genarray(take([1],shape(yt)), bx[[0]]);£%A; z = genarray(shape(bx)++drop([1],shape(yt)),$OTFILL);£%A; yi = 0;£%A; for(i=0; i&lt;shape(bx)[[0]]; i++)£%A;£%9;if (bx[[i]]){£%A;£%9;£%9;z[[i]] = yt[[yi]];£%A;£%9;£%9;yi++;£%A;£%9;}£%A; z = TRANSPOSE(z);£%A; return(z);£%A;}£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;£%A;%Fragment bsl 1** bid bidc bidc  .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* vector expand matrix last axis */£%A; bx = tob(x);£%A; if (1 == shape(bx)[[0]])£%A;£%9;bx = genarray(shape(yt)[[0]], bx[[0]]);£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: $FNAME(bx, y[iv]));£%A;£%9;} : genarray(drop([-1],shape(y)));£%A; return(z);£%A;}£%A;%Generate , $FN, $XT$YT$ZT, 111, ., $CT£%A;£%A;%Fragment bsl1 1** bid bidc bidc .£%A;inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* vector expand matrix first axis */£%A; bx = tob(x);£%A; if (1 == shape(bx)[[0]])£%A;£%9;bx = genarray(take([1],shape(y)), bx[[0]]);£%A; shpz = shape(y);£%A; shpz[[0]] = shape(bx)[[0]];£%A; z = genarray(shpz,$OTFILL);£%A; yi = 0;£%A; for(i=0; i&lt;shape(bx)[[0]]; i++)£%A;£%9;if (bx[[i]]){£%A;£%9;£%9;z[[i]] = y[[yi]];£%A;£%9;£%9;yi++;£%A;£%9;}£%A; return(z);£%A;}£%A;</string></array>
<array><shape>2114</shape><string>% Code fragments for reshape fragments£%A;%£%A;% Rewritten for sac with help from Sven-Bodo Scholz.£%A;% Robert Bernecky 2004-09-17. Add SAC-like rank specifiers£%A;£%A;%Fragment rho 001 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE y)£%A;{ /* Scalar reshape scalar to vector) */ £%A;£%9;z = genarray([toi(x)], y);£%A;£%9;return(z);£%A;}£%A;£%A;%Fragment rho 100 bidc bidc bidc .£%A;inline $ZTYPE $FNAME($XTYPE[.] x, $YTYPE y)£%A;{ /* Empty Vector reshape scalar to scalar */ £%A; return(y);£%A;}£%A;£%A;%Fragment rho 10* bidc bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{ /* Vector reshape scalar to matrix) */ £%A;£%9;zxrho = prod(toi(x)); /* Result element count */£%A;£%9;z = genarray([zxrho], y); /* allocate result */£%A;£%9;z = reshape(toi(x),z);£%A;£%9;return(z);£%A;}£%A;£%A;%Fragment rho 0*1 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE[+] y)£%A;{ /* Scalar reshape non-scalar (to vector) */ £%A; z = rhoI$YT$ZT([toi(x)],y);£%A; return(z);£%A;}£%A;%Generate , rho, I$YT$YT, 1*1, ., $YT£%A;£%A;%Fragment rho 1** c bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE[*] y)£%A;{ /* Character-vector reshape anything. */£%A;  /* Left argument must be empty vector! */£%A; if ( 0 != shape(x)[[0]]) {£%A;£%9;show(tochar("reshape domain error in $FNAME"));£%A; }£%A; z = reshape([prod(shape(y))], y);£%A; return(z[[0]]);£%A;}£%A;£%A;%Fragment rho 1** bid bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE[+] y)£%A;{ /* APEX vector x reshape, with item reuse */ £%A;  ix = toi(x);£%A;  ry = comaX$YT$YT(y); £%A;  zxrho = prod(ix); /* THIS NEEDS XRHO FOR CODE SAFETY!! */ £%A;  yxrho = shape(ry)[[0]];£%A;  if( zxrho &lt;= yxrho) { /* No element resuse case */£%A;        z = take([zxrho],ry); £%A; } else { £%A;        ncopies = zxrho/yxrho; /* # complete copies of y. */£%A;        /* FIXME: y empty case !*/£%A;        z = with {£%A;£%9;£%9;(. &lt;= [i] &lt;= .)£%A;£%9;£%9;£%9;: y;£%A;£%9;£%9;} : genarray( [ncopies], y);£%A;        /* Now append the leftover bits */£%A;        z = comaX$YT$YT(z) ++ take([zxrho-(ncopies*yxrho)],ry); £%A; } £%A; return(reshape(ix,z)); £%A;}£%A;%Generate , coma, X$YT$YT, X*1, ., $YT£%A;£%A;£%A;%Fragment rho *** bidc bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE[*] x, $YTYPE[*] y)£%A;{ /* x rank&gt;1! rank error! */£%A; APEXERROR("rank error"++__FILE__++__LINE__);£%A; return(y);£%A;}£%A;</string></array>
<array><shape>1505</shape><string>% Code fragments for scans£%A;% 1995-07-04£%A;%£%A;% Supports arbitrary user array index origin 1996-03-26 /rbe£%A;%£%A;%Fragment bsl x00 bid bid bid .£%A;inline $ZTYPE $FNAME($YTYPE y)£%A;{ /* Scan of a scalar */£%A; return(y);£%A;}£%A;£%A;%Fragment bsl x11 bid bid bid .£%A;inline $ZTYPE[.] $FNAME($YTYPE[.] y)£%A;{ /* Scan of vector */£%A;/* This does the scan in the wrong direction, but since£%A; * we assume associative functions only, it should be ok.£%A; */£%A; size = shape(y);£%A; z = genarray(size,to$ZT($FRID));£%A; if (0 != size[[0]]) {£%A; £%9;/* real work to do */ £%A; £%9;z[[0]] = to$ZT(y[[0]]); /* Not sure about the coercion... */£%A; £%9;for ( i=1; i&lt;size[[0]]; i++) {£%A;  £%9;£%9;z[[i]] = $FN$ZT$CT$ZT(to$CT(z[[i-1]]),to$CT(y[[i]]));£%A; £%9;}£%A;  }£%A; return(z);£%A;}£%A;%Generate , $FN, $ZT$CT$ZT, 000, ., $CT£%A;£%A;£%A;%Fragment  bsl1  x22 bid bid bid . £%A;inline $ZTYPE[.,.] $FNAME($YTYPE[.,.] y)£%A;{ /* Scan of matrix along first axis */£%A;y = TRANSPOSE(y);£%A;defcell = genarray(take([-1], shape(y)), $OTFILL);£%A;z = with{£%A;        (. &lt;= iv &lt;= .) :  $FNAME(y[iv]);£%A;        } : genarray(drop([-1],shape(y)), defcell);£%A; return(TRANSPOSE(z));£%A;}£%A;%Generate $FN, bsl, X$YT$ZT, X11, ., $CT£%A;%Generate , TRANSPOSE, X$YT$YT, X**, ., $CT£%A;%Generate , TRANSPOSE, X$ZT$ZT, X**, ., $CT£%A;£%A;%Fragment  bsl  x22 bid bid bid . £%A;inline $ZTYPE[.,.] $FNAME($YTYPE[.,.] y)£%A;{ /* Scan of matrix along last axis */£%A;defcell = genarray(take([-1], shape(y)), $OTFILL);£%A;z = with{£%A;        (. &lt;= iv &lt;= .) :  $FNAME(y[iv]);£%A;        } : genarray(drop([-1],shape(y)), defcell);£%A; return(z);£%A;}£%A;%Generate $FN, bsl, X$YT$ZT, X11, ., $CT£%A;£%A;</string></array>
<array><shape>742</shape><string>% Niladic system functions: QUADav and QUADts£%A;%£%A;% Robert Bernecky 2007-05-20£%A;%£%A;% --------------- QUADts fragments ----------------------------£%A;%Fragment quadts xx1  x x i .£%A;inline $ZTYPE[.] $FNAME()£%A;{ /* QUADts - system timestamp */£%A;  /* FIXME: This should be changed to double, so we can report nanoseconds */£%A; ts, nsec = gettime();£%A; secs = to_time(ts);£%A; d = mday(secs);£%A; m = mon (secs);£%A; y = year(secs);£%A; h,mi,s = clock(secs);£%A; z = [y + 1900, m + 1 , d, h, mi, s, nsec/1000000];£%A; return(z);£%A;}£%A;£%A;% --------------- QUADav fragment ----------------------------£%A;%Fragment quadav xx1  x x c .£%A;inline char[256] $FNAME()£%A;{ /* QUADav - system character set */£%A; z = with{£%A;£%9;([0] &lt;= [i] &lt; [256]) : tochar(i);£%A;£%9;} : genarray( [256], ' ');£%A; return(z);£%A;}£%A;£%A;</string></array>
<array><shape>1746</shape><string>% Code fragments for take and drop£%A;%£%A;% Robert Bernecky 2006-02-14£%A;% These all just call sac take/drop now.£%A;£%A;% %%%%%%%%%%%%%%%%%%% take %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%£%A;£%A;%Fragment take 001 bid bidc bidc .£%A;£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE y)£%A;{ /* Scalar take scalar */£%A;  return(take([toi(x)],[y]));£%A;}£%A;£%A;%Fragment take 101 bid bidc bidc  .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE y)£%A;{ /* Vector take scalar */£%A;  return(take(toi(x),[y]));£%A;}£%A;£%A;%Fragment take 011 bid bidc bidc .£%A;%Fragment take 011 bid bidc bidc .£%A;inline $ZTYPE[.] $FNAME($XTYPE x, $YTYPE[.] y)£%A;{ /* Scalar take vector */ £%A;  return(take([toi(x)], y));£%A;}£%A;£%A;%£%A;%Fragment take 11* bid bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE[1] x, $YTYPE[.] y)£%A;{ /* Vector take Vector */ £%A;  return(take(toi(x),y));£%A;}£%A;£%A;%Fragment take 0** bid bidc bidc .£%A;inline $ZTYPE[.,.] $FNAME($XTYPE x, $YTYPE[.,.] y)£%A;{ /* scalar take matrix */£%A; return(take([toi(x)],y));£%A;}£%A;£%A;%Fragment take 1** bid bidc bidc .£%A;inline $ZTYPE[.,.] $FNAME($XTYPE[.] x, $YTYPE[.,.] y)£%A;{ /* vector take matrix */£%A;  return(take(toi(x),y));£%A;}£%A;£%A;%% -------------------- drop code fragments ------------------------£%A;%£%A;%Fragment drop 001 bid bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE x, $YTYPE[*] y)£%A;{ /* Scalar drop scalar */£%A;  return(drop([toi(x)], [y]));£%A;}£%A;£%A;%Fragment drop 0** bid bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE x, $YTYPE[*] y)£%A;{ /* Scalar drop non-scalar */£%A;  return(drop([toi(x)], y));£%A;}£%A;£%A;%Fragment drop 111 bid bidc bidc .£%A;%Fragment drop 1** bid bidc bidc .£%A;inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE[*] y)£%A;{ /* Vector drop non-scalar */£%A;  /* FIXME: Assert  dim(y)  == shape(x)[0]; */£%A;  /* e.g, (,5)drop iota 5  */£%A;  return(drop(toi(x), y));£%A;}£%A;£%A;</string></array>
<array><shape>3337</shape><string>% Monadic and dyadic thorn formatting functions£%A;£%A;% We don't do this yet, but should keep it in mind...£%A;% Dyalog APL Version 10.1 Ref Man p153 says that monadic format£%A;% has these properties:£%A;%   1. the decimal points for floating point or scaled formats are aligned.£%A;%   2. The E characters for scaled formats are aligned, with trailing zeros£%A;%      added to the mantissae if necessary.£%A;%   3. Integer formats are aligned to the left of the decimal point column,£%A;%      if any, or right-adjusted in the field otherwise.£%A;%   4. Each formatted column is separated from its neighbours by a single£%A;%      blank column.£%A;%   5. The exponent values in scaled formats are left-adjusted to remove any blanks£%A;£%9;and + signs.£%A;%   6. Scaled notation is used of the magnitude of the non-integer number is too large£%A;%      to represent with QAADpp significant digits or if the number requires more£%A;%      than five leading zeros after the decimal point. E.g.:£%A;%          QUADpp{&lt;-} 5£%A;%          thorn 123456.7£%A;%      1.2346E5£%A;%          thorn 0.0000001234£%A;%      1.234E_7£%A;%   7. Negative numbers are formatted with ascii '-', not high-minus.£%A;£%A;£%A;%%%%%%%%%%%%% monadic character thorn %%%%%%%%%%%%%%%%%£%A;£%A;%Fragment thrn X** X C C  .£%A;inline char[*] $FNAME($YTYPE[*] y, int QUADpp)£%A;{ /* Monadic format on characters */£%A;  return( y);£%A;}£%A;£%A;%%%%%%%%%%%%% monadic Boolean thorn %%%%%%%%%%%%%%%%%£%A;£%A;%Fragment thrn X01 X B C  .£%A;inline char[.] $FNAME($YTYPE y, int QUADpp)£%A;{ /* Monadic format on Boolean scalar  */£%A;  z = y ? '1' : '0';£%A;  return([z]);£%A;}£%A;£%A;%Fragment thrn X** X B C  .£%A;inline char[+] $FNAME($YTYPE[+] y, int QUADpp)£%A;{ /* Monadic format on Boolean non-scalars */£%A;  z = format(y, QUADpp);£%A;  return(z);£%A;}£%A;£%A;%%%%%%%%%%%%% monadic integer  thorn %%%%%%%%%%%%%%%%%£%A;£%A;%Fragment thrn X01 X I C .£%A;inline char[.] $FNAME($YTYPE y, int QUADpp)£%A;{ /* Monadic format on integer scalar  */£%A;  z = format(y, QUADpp);£%A; return( z);£%A;}£%A;£%A;%Fragment thrn  X** X I C  .£%A;inline char[+] $FNAME($YTYPE[+] y, int QUADpp)£%A;{ /* Monadic format on integer non-scalar */£%A;  z = format(y, QUADpp);£%A;  return(z);£%A;}£%A; £%A;%%%%%%%%%%%%% monadic double  thorn %%%%%%%%%%%%%%%%%£%A;£%A;%Fragment thrn X01 X D C  .£%A;inline char[.] $FNAME($YTYPE y, int QUADpp)£%A;{ /* Monadic format on double scalar  */£%A; z = format(y, QUADpp);£%A; return(z);£%A;}£%A;£%A;%Fragment thrn X** X D C .£%A;inline char[+] $FNAME($YTYPE[+] y, int QUADpp)£%A;{ /* Monadic format on double non-scalar */£%A;  /* Refer to UTThorn.dws &lt;threal&gt; for APL model of this */£%A;  z = format(y, QUADpp);£%A;  return(z);£%A;}£%A;£%A;%%%%%%%%%%%%%%%%%%%%%%%%%%% Dyadic Thorn fragments %%%%%%%%%%%%%%%%%%%%%5£%A;£%A;%Fragment thrn 101 BID BID C .£%A;inline char[+] $FNAME($XTYPE[2] x,  $YTYPE y)£%A;{ /* Dyadic thorn on Boolean, Integer, or double scalar */£%A; widths = toi(x[[0]]);£%A; precision = toi(x[[1]]);£%A; z, junk = APEXDthrn( [y], widths);£%A; if ( widths&lt;shape(z)[0]) { £%A;£%9;z = genarray([widths], '*');£%A; }£%A; return(z);£%A;}£%A;%Generate , APEXDthrn, £%9;X$YTC, X11, ., I £%A;£%A;%Fragment thcharsto 110 C C I   .£%A;inline int thcharsto(char[.] ch, char[.] fry)£%A;{ /* Find chars left of decimal point (or end) */£%A; lim = (shape(fry))[0];£%A; z = lim;£%A; for(i=0; i&lt;lim; i++) {£%A;        if ((fry[[i]] == ch[[0]]) || (fry[[i]] == ch[[1]])) {£%A;                z = i;£%A;                i = lim;£%A;        }£%A; }£%A; return(z);£%A;}£%A;£%A;% We should have dyadic thorn for arrays...£%A;% with  scalar, 2-element vector, and shape-of-Y-cols X argument...£%A;£%A;</string></array>
<array><shape>6862</shape><string>/* Various utility functions we need to generate from £%A; * time to time.£%A; * Robert Bernecky 2006-02-17£%A; */£%A;£%A;%Fragment NOOP *** bidc bidc bidc . $CT£%A;% noop for conjunctions with derived/defined fns as operands£%A;£%A;%Fragment binarysearch 100 i i i .£%A;inline int BinarySearch(int[.] x, int y)£%A;{ /* Binary search (sorted) vector x for y */£%A;  /* From "Computer Algorithms", 2nd Ed., Sara Baase 1988 */£%A;  n = shape(x)[0];£%A;  first = 0;£%A;  last = n-1;£%A;  found = false;£%A;  while((first&lt;last) &amp;&amp; !found){£%A;£%9;i = (first+last)/2;£%A;£%9;if (y == x[i])£%A;£%9;£%9;found = true;£%A;£%9;elseif (y &lt; x[i])£%A;£%9;£%9;last = i-1;£%A;£%9;else£%A;£%9;£%9;first = i+1;£%A;£%9;endif£%A;  endwhile;£%A;£%A;  if (!found)£%A;£%9;i = n;£%A;  return(i);£%A;}£%A;£%9;£%9;£%A;£%A;%Fragment upgrade X11 x id i .£%A;£%A;inline int[.] Upgrade($YTYPE[.] y)£%A;{ /* Upgrade on integer/floating vector. £%A;     Do APL upgrade of vector y using heapsort.£%A;     This version from "Numerical Recipes in C", p. 249£%A;     Robert Bernecky 2005-11-17£%A;     Knuth, Vol. III, pp. 145-148 gives a good example. £%A;     APL model: (See workspace apex2003/wss/upgrade or£%A;                 apex2003/wif/upgrade)£%A;  */£%A;£%A; qio=1; /* Heapsort is sort of origin-1 */£%A; N = shape(y)[0];£%A; if (N &lt;= 1)£%A;£%9;z = iotaXII(N,qio); £%A; else{£%A;£%9;z = MakeHeap(y);£%A;£%9;z = (UnHeap(z,y))-qio;£%A; }£%A; return(z);£%A;}£%A;£%A;inline int[.] MakeHeap($XTYPE[.] v)£%A;{ /* Build heap from vector v. v has at least two elements */£%A; N = shape(v)[0];£%A; qio = 1;£%A; heap = iotaXII(N+qio);£%A; ir=N;£%A; max= 1+N/2; £%A; for(L=max-1; L&gt;0; L--){£%A;£%9;indxt=heap[L-qio];£%A;£%9;q=v[indxt-qio];£%A;£%9;heap = Heapness(L,ir,q,indxt,heap,v);£%A; }£%A; return(heap);£%A;}£%A;£%A;inline int[.] UnHeap(int[.] heap, $YTYPE[.]v)£%A;{ /* Extract heap elements in top-to-bottom order */£%A;£%A; qio=1;£%A; for(ir=shape(heap)[0]-1; ir&gt;=2; ir--){£%A;£%9;indxt=heap[ir];£%A;£%9;q=v[indxt-qio];£%A;£%9;heap[ir]=heap[0];£%A;£%9;heap=Heapness(qio,ir,q,indxt,heap,v);£%A; }£%A; t = heap[0];£%9;£%9;/* This doesn't look kosher to me... */£%A; heap[0]=heap[1];£%A; heap[1]=t;£%A; return(heap);£%A;}£%A;£%A;inline int[.] Heapness(int L, int ir, $YTYPE q, int indxt, int[.] heap, $YTYPE[.] v)£%A;{ /* Restore heap invariant: For Origin-1 a[i], i member 1...N,£%A;     a[i/2]&gt;=a[i].£%A;  */£%A;£%A;qio=1;£%9;£%9;/* Heap is origin-1 */£%A;P = L;£%9;£%9;/* Parent node */£%A;C = P+P;£%9;/* Child node */£%A;while (C&lt;=ir){£%A;£%9;/* Find larger sibling index into v */£%A;£%9;if (C &gt;= ir)£%9;/* Fell off heap */£%A;£%9;£%9;newC=C;£%A;£%9;else{£%A;£%9;£%9;lsibp=heap[C-qio];£%A;£%9;£%9;lsib=v[lsibp-qio];£%A;£%9;£%9;rsibp=heap[C+1-qio];£%A;£%9;£%9;rsib=v[rsibp-qio];£%A;£%9;if £%9;(upgradeGT(lsib,rsib))£%9;/* Left sib bigger */£%A;£%9;£%9;newC=C;£%A;£%9;else if£%9;(upgradeLT(lsib,rsib))£%9;/* Right sib bigger */£%A;£%9;£%9;newC=C+1;£%A;£%9;else if£%9;(lsibp&lt;rsibp)£%9;£%9;/* Sibs equal. Preserve stable sort */£%A;£%9;£%9;newC=C+1;£%A;£%9;else£%A;£%9;£%9;newC=C;£%A;£%9;}£%A;£%A;/* Swap parent with larger child, if parent smaller */£%A;£%9;bigsibp = heap[newC-qio];£%A;£%9;bigsib = v[bigsibp-qio];£%A;£%9;if£%9;(upgradeLT(q,bigsib)){£%9;/* Parent smaller -swap */£%A;£%9;£%9;heap[P-qio]=bigsibp;£%A;£%9;£%9;C=newC+newC;£%A;£%9;£%9;P=newC;£%A;£%9;£%9;}£%A;£%9;else if£%9;(upgradeGT(q,bigsib))£%9;/* Parent bigger - no swap */£%A;£%9;£%9;C=ir+1;£%A;£%9;else if£%9;(indxt&lt;bigsibp){£%9;/* Parent=child. Preserve stability */£%A;£%9;£%9;heap[P-qio]=bigsibp;£%A;£%9;£%9;C=newC+newC;£%A;£%9;£%9;P=newC;£%A;£%9;£%9;}£%A;£%9;else£%9;£%9;£%9;£%9;/* Parent=child. Already stable */£%A;£%9;£%9;C=ir+1;£%A; }£%A; heap[P-qio]=indxt;£%A;return(heap);£%A;}£%9;£%9;£%A;%Generate , iota, XII, X01, ., $CT£%A;£%A;%Fragment ABC *00 bidc bidc i . I£%A;inline int ABC(int I, int Xshape)£%A;{ /* Array bounds checker for indexed ref X[scalarI] and indexed assign */£%A; z = I;£%A;#ifdef BOUNDSCHECKING£%A; /* This needs more thought... */£%A;  if ( (I &lt; 0) || (I &gt;= Xshape)) {£%A;  £%9;print(tochar("APEX index error!"));£%A;  }£%A;#endif£%A; return(z);£%A;}£%A;£%A;%Fragment ABC *** bidc bidc i . I£%A;inline int[+] ABC(int[+] I, int Xshape)£%A;{ /* Array bounds checker for indexed ref  X[nonscalarI] and indexed assign */£%A; z = I;£%A;#ifdef BOUNDSCHECKING£%A; bad = with {£%A;£%9;((0*shape(z)) &lt;= iv &lt; shape(z))£%A;£%9;£%9;: (z[iv] &lt; 0) || (z[iv] &gt;= Xshape);£%A;£%9;}: fold(|, false);£%A; if (bad)£%A;  print(tochar("APEX index error!"));£%A;#endif£%A; return(z);£%A;}£%A;£%A;%Fragment Lehmer X00 i i i . I£%A;inline int Lehmer(int qrl)£%A;{ /* Lehmer's random number generator £%A;   * CACM 1966-06, p. 432 £%A;   */£%A;  val = tod(qrl)*16807.0;£%A;  z = toi(sacmod(val, 2147483647.0));£%A; return(z);£%A;}£%A;%Generate , sacmod, DDD, 000, ., D£%A;£%A;%Fragment sacmod 000 d d d . D£%A;inline double sacmod(double x, double y)£%A;{ /* SAC _mod_ for floats */£%A; if ( 0.0 == y) {£%A;        t = 1.0;£%A; } else {£%A;        t = y;£%A; }£%A; t2 = floor(x/t);£%A; z = x - (y*t2);£%A; return(z);£%A;}£%A;£%A;%Fragment APEXFUZZEQ 000 d d b . D£%A;inline bool APEXFUZZEQ(double x, double y, double QUADct)£%A;{ /* ISO APL Tolerant equality predicate */£%A; absx = abs(x);£%A; absy = abs(y);£%A; tolerance = QUADct * max(absx,absy);£%A; z = abs(x-y) &lt;= tolerance;£%A; return(z);£%A;}£%A;£%A;%Fragment APEXFUZZEQ 000 bid bid b . $CT£%A;% This fragment isn't needed for anything except double/float£%A;£%A;£%A;%Fragment TRANSPOSE x00 bidc bidc bidc . bidc£%A;inline $ZTYPE TRANSPOSE($YTYPE y)£%A;{ /* Generic monadic transpose on scalar */£%A; return(y);£%A;}£%A;£%A;%Fragment TRANSPOSE x11 bidc bidc bidc . bidc£%A;inline $ZTYPE[.] TRANSPOSE($YTYPE[.] y)£%A;{ /* Generic monadic transpose on vector */£%A; return(y);£%A;}£%A;£%A;%Fragment TRANSPOSE x** bidc bidc bidc . bidc£%A;inline $YTYPE[+] TRANSPOSE($YTYPE[+] y)£%A;{ /* Generic monadic transpose */£%A;  z = with {£%A;        ( . &lt;= iv &lt;= .)£%A;£%9;£%9;: y[reverse( iv)]; £%A;£%9;}: genarray( reverse( shape(y)), $OTFILLY);£%A;  return(z); £%A;}£%A;£%A;%Fragment DFLOORNOFUZZ x00 x  d d . d£%A;inline int DFLOORNOFUZZ(double y)£%A;{ /* Exact floor (no fuzz) */£%A; return(toi(floor(y)));£%A;}£%A;£%A;%Fragment DFLOOR x00 x  d d . d£%A;inline int DFLOOR(double y, double QUADct)£%A;{ /* Fuzzy floor */£%A;  /* Definition taken from SHARP APL Refman May 1991, p.6-23£%A;   * floor:  n &lt;- (signum y) times nofuzzfloor 0.5+abs y)£%A;   *         z &lt;- n-(QUADct times 1 max abs y)&lt;(n-y)£%A;   * If you want a double result,  write: "y - 1| y".£%A;   */£%A;   n = tod(floor(0.5+fabs(y)));£%A;   if (y &lt; 0.0)£%A;£%9;n = -n;£%A;   else if (0.0 == y)£%A;£%9;n = 0.0;£%A;   range = fabs(y);£%A;   if (1.0 &gt; range)£%A;£%9;range = 1.0;£%A;   fuzzlim = QUADct*range;£%A;   ny = n-y;£%A;   if (fuzzlim &lt; ny)£%A;£%9;z = n - 1.0;£%A;   else£%A;£%9;z = n;£%A;   return(toi(z)); £%A;}£%A;£%A;%Fragment VECTORROTATEAMOUNT 000 i i i . i£%A;inline int VectorRotateAmount(int x, int y)£%A;{ /* Normalize x rotate for array of shape y on selected axis */£%A; /* normalize rotation count */£%A;£%A;if ((0==x) || (0==y))£%A;  z = 0;£%A;else if (x&gt;0)£%A;        z = _mod_(x,y);£%A;     else£%A;        z = y - _mod_(_abs_(x),y);£%A; return(z);£%A;}£%A;£%A;%Fragment VECTORROTATEAMOUNT *0* i i i . i£%A;inline int[+] VectorRotateAmount(int[+] x, int y)£%A;{ /* Normalize x rotate for array of shape y on selected axis */£%A; /* normalize rotation count */£%A; z = with {£%A;£%9;(. &lt;= iv &lt;= .)£%A;£%9;£%9;: VectorRotateAmount( x[iv], y);£%A;£%9;} : genarray( shape(x), 0);£%A; return(z);£%A;}£%A;%Generate , VECTORROTATEAMOUNT, III, 000, ., I£%A;£%A;%Fragment DSFLenErrorCheck *** i i b . I£%A;inline int[.] DSFLenErrorCheck(int[.] sx, int[.] sy, char[.] whodunit)£%A;{ /* Dyadic scalar fn length error check */£%A;     z = sx;£%A;#ifdef GENME£%A;/* SAC bug #306 - side effect kills fold!  */£%A;    if (any(sx != sy)) { /* Check that shapes match */£%A;£%9;show(tochar("APEX dyadic scalar function length error in function"));£%A;£%9;show(whodunit);£%A;£%9;show(sx); show(sy);£%A;    }£%A;#endif£%A;     return(z);£%A;}£%A;£%A;</string></array></array>
