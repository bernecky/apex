'% Dyadic Scalar function definitions ',(⎕UCS 10),'% R. Bernecky 2006-01-05',(⎕UCS 10),'%',(⎕UCS 10),'% Header notes:',(⎕UCS 10),'%    percentFragment  marks the beginning of each entry',(⎕UCS 10),'%    Fields are delimited by blanks.',(⎕UCS 10),'%    Field 1: primitive function jsymbol',(⎕UCS 10),'%    Field 2: acceptable left argument types',(⎕UCS 10),'%    Field 3: acceptable right argument types',(⎕UCS 10),'%    Field 4: Result type for fragment',(⎕UCS 10),'%    Field 5: ifergit',(⎕UCS 10),'%',(⎕UCS 10),'% Header ordering may be critical in the case where two ',(⎕UCS 10),'% fragments would both work. This is important in epio, for',(⎕UCS 10),'% example, where a special case (e.g., charvec iota charvec)',(⎕UCS 10),'% must be chosen in preference to the general case. ',(⎕UCS 10),'% Or, here, where we can use a fast Boolean-mod-Boolean, rather',(⎕UCS 10),'% than general mod code.',(⎕UCS 10),'%',(⎕UCS 10),'%Fragment plus 000 bid bid bid .        ',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return($XTto$CT(x)+$YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment bar 000 bid bid bid .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return($XTto$CT(x)-$YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment mpy 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return($XTtoB(x) & $YTtoB(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment mpy 000 bid bid bid .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return($XTto$CT(x)*$YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment div 000 bid bid d .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ dx = $XTtoD(x);',(⎕UCS 10),'  dy = $YTtoD(y);',(⎕UCS 10),'  z = (dx == dy) ? 1.0  : dx/dy;',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment min 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return (x&y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment min 000 idc idc idc .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* x min y */',(⎕UCS 10),' return (min($XTto$CT(x),$YTto$CT(y)));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment max 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return (x&y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment max 000 bidc bidc idc .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* x max y */ ',(⎕UCS 10),' return (max($XTto$CT(x),$YTto$CT(y)));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment mod 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return((!x)&y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment mod 000 bi bi bi .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* SxS residue (aka modulo) */',(⎕UCS 10),'  /* (x residue y) <-->   y-x times floor y divide x + 0 = x  */',(⎕UCS 10),'  /* See model residueI in workspace UTDScalarI.dws */',(⎕UCS 10),'  x = $XTtoI(x);',(⎕UCS 10),'  y = $YTtoI(y);',(⎕UCS 10),'  if( 0 != x) {',(⎕UCS 10),'    q = y / x;',(⎕UCS 10),'    z = y - ( x * q);',(⎕UCS 10),'  } else {',(⎕UCS 10),'    z = y;',(⎕UCS 10),'  }',(⎕UCS 10),' ',(⎕UCS 10),'  if( z != 0) {',(⎕UCS 10),'    if( mpyXII( x) != mpyXII( y)) {',(⎕UCS 10),'      z = z + x;',(⎕UCS 10),'    }',(⎕UCS 10),'  }',(⎕UCS 10),' return(z);',(⎕UCS 10),'} ',(⎕UCS 10),'%Generate , mpy, X$YT$ZT, X00, ., $CT',(⎕UCS 10 10),'%Fragment mod 000 bid bid bid .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* Double residue double */',(⎕UCS 10),'  /* This definition is taken from SHARP APL Refman May 1991, p.6-26.',(⎕UCS 10),'   * It extends the definition of residue to fractional right arguments',(⎕UCS 10),'   * and to zero, negative and fractional left arguments.',(⎕UCS 10),'   * r= y-x times floor y divide x+0=x',(⎕UCS 10),'   * See also APL model in workspace 43 UTDScalarI. ',(⎕UCS 10),'   */',(⎕UCS 10),'  nx = (0.0 == $XTto$CT(x))  ?  1.0  : $XTto$CT(x);',(⎕UCS 10),'  z = $YTto$CT(y) - $XTto$CT(x) * tod(DFLOOR($YTto$CT(y)/nx, QUADct));',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , DFLOOR, X$YT$ZT, X00, ., $CT',(⎕UCS 10 10),'%Fragment star 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return(x | !y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment star 000 bid b bid .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ ',(⎕UCS 10),' z =  ($YTtoB(y))  ?  $XTto$ZT(x)  : Ito$ZT(1);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment star 000 bid i bid .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{  /* number to integer power */',(⎕UCS 10),'  z = Ito$CT( 1);',(⎕UCS 10),'  for( i=0; i<$YTtoI( y); i++) {',(⎕UCS 10),'    z = z * $XTto$CT(x);  ',(⎕UCS 10),'  }',(⎕UCS 10),'  return( z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment star 000 bid d d .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return(pow($XTtoD(x),$YTtoD(y)));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment log  000 bid bid d .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return(log($YTtoD(y))/log($XTtoD(x)));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment lt 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return((!x)&y);',(⎕UCS 10),'}',(⎕UCS 10 10),'/* NB.  APEX Extension of ISO APL to allow comparison of characters */',(⎕UCS 10),'/* relationals */',(⎕UCS 10),'%Fragment lt 000 bic bic b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A<B on Boot/Int/Char */',(⎕UCS 10),'  return($XTto$CT(x)<$YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment lt 000 bi bi b i ',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* Boolean/Integer less than */',(⎕UCS 10),' return($XTto$CT(x)<=$YTto$CT(y));',(⎕UCS 10 10),'%Fragment lt 000 bid bid b d',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* Fuzzy less than */',(⎕UCS 10),' return(($XTto$CT(x)<$YTto$CT(y)) & !APEXFUZZEQ($XTto$CT(x),$YTto$CT(y),QUADct));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , APEXFUZZEQ, $XT$YTB, 000, ., D',(⎕UCS 10 10),'%Fragment le 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A<=B on Boolean */',(⎕UCS 10),' return((!x)|y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment le 000 bic bic b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A<=B on Boolean,int, char */',(⎕UCS 10),' return($XTto$CT(x) <= $YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment le 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* Fuzzy <= */',(⎕UCS 10),' return(($XTto$CT(x)<$YTto$CT(y)) | APEXFUZZEQ($XTto$CT(x),$YTto$CT(y),QUADct));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , APEXFUZZEQ, DDB, 000, ., D',(⎕UCS 10 10),'%Fragment eq 000 bic bic b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A=B on non-doubles */',(⎕UCS 10),' return($XTto$CT(x) == $YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment eq 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* A=B on doubles */',(⎕UCS 10),'  /* We use | instead of || on the assumption that ',(⎕UCS 10),'   * the zero-fuzz case will eliminate the second leg,',(⎕UCS 10),'   * and it also eliminate a CONDFUN.',(⎕UCS 10),'   */',(⎕UCS 10),' return(($XTto$CT(x) == $YTto$CT(y)) | APEXFUZZEQ($XTto$CT(x),$YTto$CT(y),QUADct));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , APEXFUZZEQ, DDB, 000, ., D',(⎕UCS 10 10),'%Fragment ne 000 bic bic b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{/* A !=B on non-doubles */',(⎕UCS 10),' return($XTto$CT(x) != $YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment ne 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* A!=B on doubles */',(⎕UCS 10),' return(($XTto$CT(x) != $YTto$CT(y)) & !APEXFUZZEQ($XTto$CT(x),$YTto$CT(y),QUADct));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , APEXFUZZEQ, DDB, 000, ., D',(⎕UCS 10 10),'%Fragment gt 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A>B on non-doubles */',(⎕UCS 10),' return(x & !y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment gt 000 bic bic b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A>B on Booleans */',(⎕UCS 10),' return($XTto$CT(x) > $YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment gt 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* A>B on doubles */',(⎕UCS 10),' return(($XTto$CT(x) > $YTto$CT(y)) & !APEXFUZZEQ($XTto$CT(x),$YTto$CT(y),QUADct));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , APEXFUZZEQ, DDB, 000, ., D',(⎕UCS 10 10),'%Fragment ge 000 b b b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A>=B on Booleans */',(⎕UCS 10),' return(x | !y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment ge 000 bic bic b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* A>=B on non-Doubles */',(⎕UCS 10),' return($XTto$CT(x) >= $YTto$CT(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment ge 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y, double QUADct)',(⎕UCS 10),'{ /* A>=B on doubles */ ',(⎕UCS 10),' return(($XTto$CT(x) >= $YTto$CT(y)) | APEXFUZZEQ($XTto$CT(x),$YTto$CT(y),QUADct));',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , APEXFUZZEQ, DDB, 000, ., D',(⎕UCS 10 10),'%Fragment and 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return($XTtoB(x)&$YTtoB(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment or 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return($XTtoB(x) | $YTtoB(y));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment nand 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return(!($XTto$CT(x)&$YTto$CT(y)));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment nor 000 bid bid b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ return(!($XTto$CT(x)|$YTto$CT(y)));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment circ 000 bid bid bid .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* Circle functions */',(⎕UCS 10),' xi = $XTtoI(x);',(⎕UCS 10),' if      (1 == xi)',(⎕UCS 10),'        z = sin($YTtoD(y));',(⎕UCS 10),' else if (2 == xi)',(⎕UCS 10),'        z = cos($YTtoD(y));',(⎕UCS 10),' else if (3 == xi)',(⎕UCS 10),'        z = tan($YTtoD(y));',(⎕UCS 10),' else if (4 == xi)',(⎕UCS 10),'        z = pow(1.0+($YTtoD(y)*$YTtoD(y)),0.5);',(⎕UCS 10),' else ',(⎕UCS 10),'        z = 42.0; /* Should be domain error or something */',(⎕UCS 10),' return(z); ',(⎕UCS 10),'}',(⎕UCS 10 10)
