('/* Various utility functions we need to generate from ',(⎕UCS 10),' * time to time.',(⎕UCS 10),' * Robert Bernecky 2006-02-17',(⎕UCS 10),' */',(⎕UCS 10 10),'%Fragment NOOP *** bidc bidc bidc . $CT',(⎕UCS 10),'% noop for conjunctions with derived/defined fns as operands',(⎕UCS 10 10),'%Fragment binarysearch 100 i i i .',(⎕UCS 10),'inline int BinarySearch(int[.] x, int y)',(⎕UCS 10),'{ /* Binary search (sorted) vector x for y */',(⎕UCS 10),'  /* From "Computer Algorithms", 2nd Ed., Sara Baase 1988 */',(⎕UCS 10),'  n = shape(x)[0];',(⎕UCS 10),'  first = 0;',(⎕UCS 10),'  last = n-1;',(⎕UCS 10),'  found = false;',(⎕UCS 10),'  while((first<last) && !found){',(⎕UCS 10),'        i = (first+last)/2;',(⎕UCS 10),'        if (y == x[i])',(⎕UCS 10),'                found = true;',(⎕UCS 10),'        elseif (y < x[i])',(⎕UCS 10),'                last = i-1;',(⎕UCS 10),'        else',(⎕UCS 10),'                first = i+1;',(⎕UCS 10),'        endif',(⎕UCS 10),'  endwhile;',(⎕UCS 10 10),'  if (!found)',(⎕UCS 10),'        i = n;',(⎕UCS 10),'  return(i);',(⎕UCS 10),'}',(⎕UCS 10),'                ',(⎕UCS 10 10),'%Fragment upgrade X11 x id i .',(⎕UCS 10 10),'inline int[.] Upgrade($YTYPE[.] y)',(⎕UCS 10),'{ /* Upgrade on integer/floating vector. ',(⎕UCS 10),'     Do APL upgrade of vector y using heapsort.',(⎕UCS 10),'     This version from "Numerical Recipes in C", p. 249',(⎕UCS 10),'     Robert Bernecky 2005-11-17',(⎕UCS 10),'     Knuth, Vol. III, pp. 145-148 gives a good example. ',(⎕UCS 10),'     APL model: (See workspace apex2003/wss/upgrade or',(⎕UCS 10),'                 apex2003/wif/upgrade)',(⎕UCS 10),'  */',(⎕UCS 10 10),' qio=1; /* Heapsort is sort of origin-1 */',(⎕UCS 10),' N = shape(y)[0];',(⎕UCS 10),' if (N <= 1)',(⎕UCS 10),'        z = iotaXII(N,qio); ',(⎕UCS 10),' else{',(⎕UCS 10),'        z = MakeHeap(y);',(⎕UCS 10),'        z = (UnHeap(z,y))-qio;',(⎕UCS 10),' }',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'inline int[.] MakeHeap($XTYPE[.] v)',(⎕UCS 10),'{ /* Build heap from vector v. v has at least two elements */',(⎕UCS 10),' N = shape(v)[0];',(⎕UCS 10),' qio = 1;',(⎕UCS 10),' heap = iotaXII(N+qio);',(⎕UCS 10),' ir=N;',(⎕UCS 10),' max= 1+N/2; ',(⎕UCS 10),' for(L=max-1; L>0; L--){',(⎕UCS 10),'        indxt=heap[L-qio];',(⎕UCS 10),'        q=v[indxt-qio];',(⎕UCS 10),'        heap = Heapness(L,ir,q,indxt,heap,v);',(⎕UCS 10),' }',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}',(⎕UCS 10 10),'inline int[.] UnHeap(int[.] heap, $YTYPE[.]v)',(⎕UCS 10),'{ /* Extract heap elements in top-to-bottom order */',(⎕UCS 10 10),' qio=1;',(⎕UCS 10),' for(ir=shape(heap)[0]-1; ir>=2; ir--){',(⎕UCS 10),'        indxt=heap[ir];',(⎕UCS 10),'        q=v[indxt-qio];',(⎕UCS 10),'        heap[ir]=heap[0];',(⎕UCS 10),'        heap=Heapness(qio,ir,q,indxt,heap,v);',(⎕UCS 10),' }',(⎕UCS 10),' t = heap[0];           /* This doesn''t look kosher to me... */',(⎕UCS 10),' heap[0]=heap[1];',(⎕UCS 10),' heap[1]=t;',(⎕UCS 10),' return(heap);',(⎕UCS 10),'}',(⎕UCS 10 10),'inline int[.] Heapness(int L, int ir, $YTYPE q, int indxt, int[.] heap, $YTYPE[.] v)',(⎕UCS 10),'{ /* Restore heap invariant: For Origin-1 a[i], i member 1...N,',(⎕UCS 10),'     a[i/2]>=a[i].',(⎕UCS 10),'  */',(⎕UCS 10 10),'qio=1;          /* Heap is origin-1 */',(⎕UCS 10),'P = L;          /* Parent node */',(⎕UCS 10),'C = P+P;        /* Child node */',(⎕UCS 10),'while (C<=ir){',(⎕UCS 10),'        /* Find larger sibling index into v */',(⎕UCS 10),'        if (C >= ir)    /* Fell off heap */',(⎕UCS 10),'                newC=C;',(⎕UCS 10),'        else{',(⎕UCS 10),'                lsibp=heap[C-qio];',(⎕UCS 10),'                lsib=v[lsibp-qio];',(⎕UCS 10),'                rsibp=heap[C+1-qio];',(⎕UCS 10),'                rsib=v[rsibp-qio];',(⎕UCS 10),'        if      (upgradeGT(lsib,rsib))  /* Left sib bigger */',(⎕UCS 10),'                newC=C;',(⎕UCS 10),'        else if (upgradeLT(lsib,rsib))  /* Right sib bigger */',(⎕UCS 10),'                newC=C+1;',(⎕UCS 10),'        else if (lsibp<rsibp)           /* Sibs equal. Preserve stable sort */',(⎕UCS 10),'                newC=C+1;',(⎕UCS 10),'        else',(⎕UCS 10),'                newC=C;',(⎕UCS 10),'        }',(⎕UCS 10 10),'/* Swap parent with larger child, if parent smaller */',(⎕UCS 10),'        bigsibp = heap[newC-qio];',(⎕UCS 10),'        bigsib = v[bigsibp-qio];',(⎕UCS 10),'        if      (upgradeLT(q,bigsib)){  /* Parent smaller -swap */',(⎕UCS 10),'                heap[P-qio]=bigsibp;',(⎕UCS 10),'                C=newC+newC;',(⎕UCS 10),'                P=newC;',(⎕UCS 10),'                }',(⎕UCS 10),'        else if (upgradeGT(q,bigsib))   /* Parent bigger - no swap */',(⎕UCS 10),'                C=ir+1;',(⎕UCS 10),'        else if (indxt<bigsibp){        /* Parent=child. Preserve stability */',(⎕UCS 10),'                heap[P-qio]=bigsibp;',(⎕UCS 10),'                C=newC+newC;',(⎕UCS 10),'                P=newC;',(⎕UCS 10),'                }',(⎕UCS 10),'        else                            /* Parent=child. Already stable */',(⎕UCS 10),'                C=ir+1;',(⎕UCS 10),' }',(⎕UCS 10),' heap[P-qio]=indxt;',(⎕UCS 10),'return(heap);',(⎕UCS 10),'}               ',(⎕UCS 10),'%Generate , iota, XII, X01, ., $CT',(⎕UCS 10 10),'%Fragment Lehmer X00 i i i . I',(⎕UCS 10),'inline int Lehmer(int qrl)',(⎕UCS 10),'{ /* Lehmer''s random number generator ',(⎕UCS 10),'   * CACM 1966-06, p. 432 ',(⎕UCS 10),'   */',(⎕UCS 10),'  val = tod(qrl)*16807.0;',(⎕UCS 10),'  z = toi(sacmod(val, 2147483647.0));',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , sacmod, DDD, 000, ., D',(⎕UCS 10 10),'%Fragment sacmod 000 d d d . D',(⎕UCS 10),'inline double sacmod(double x, double y)',(⎕UCS 10),'{ /* SAC _mod_ for floats */',(⎕UCS 10),' if ( 0.0 == y) {',(⎕UCS 10),'        t = 1.0;',(⎕UCS 10),' } else {',(⎕UCS 10),'        t = y;',(⎕UCS 10),' }',(⎕UCS 10),' t2 = floor(x/t);',(⎕UCS 10),' z = x - (y*t2);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment APEXFUZZEQ 000 d d b . D',(⎕UCS 10),'inline bool APEXFUZZEQ(double x, double y, double QUADct)',(⎕UCS 10),'{ /* ISO APL Tolerant equality predicate */',(⎕UCS 10),' absx = abs(x);',(⎕UCS 10),' absy = abs(y);',(⎕UCS 10),' tolerance = QUADct * max(absx,absy);',(⎕UCS 10),' z = abs(x-y) <= tolerance;',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment APEXFUZZEQ 000 bid bid b . $CT',(⎕UCS 10),'% This fragment isn''t needed for anything except double/float',(⎕UCS 10 10 10),'%Fragment TRANSPOSE x00 bidc bidc bidc . bidc',(⎕UCS 10),'inline $ZTYPE TRANSPOSE($YTYPE y)',(⎕UCS 10),'{ /* Generic monadic transpose on scalar */',(⎕UCS 10),' return(y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment TRANSPOSE x11 bidc bidc bidc . bidc',(⎕UCS 10),'inline $ZTYPE[.] TRANSPOSE($YTYPE[.] y)',(⎕UCS 10),'{ /* Generic monadic transpose on vector */',(⎕UCS 10),' return(y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment TRANSPOSE x** bidc bidc bidc . bidc',(⎕UCS 10),'inline $YTYPE[+] TRANSPOSE($YTYPE[+] y)',(⎕UCS 10),'{ /* Generic monadic transpose */',(⎕UCS 10),'  z = with {',(⎕UCS 10),'        ( . <= iv <= .)',(⎕UCS 10),'                : y[reverse( iv)]; ',(⎕UCS 10),'        }: genarray( reverse( shape(y)), $OTFILLY);',(⎕UCS 10),'  return(z); ',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment DFLOORNOFUZZ x00 x  d d . d',(⎕UCS 10),'inline int DFLOORNOFUZZ(double y)',(⎕UCS 10),'{ /* Exact floor (no fuzz) */',(⎕UCS 10),' return(toi(floor(y)));',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment DFLOOR x00 x  d d . d',(⎕UCS 10),'inline int DFLOOR(double y, double QUADct)',(⎕UCS 10),'{ /* Fuzzy floor */',(⎕UCS 10),'  /* Definition taken from SHARP APL Refman May 1991, p.6-23',(⎕UCS 10),'   * floor:  n <- (signum y) times nofuzzfloor 0.5+abs y)',(⎕UCS 10),'   *         z <- n-(QUADct times 1 max abs y)<(n-y)',(⎕UCS 10),'   * If you want a double result,  write: "y - 1| y".',(⎕UCS 10),'   */',(⎕UCS 10),'   n = tod(floor(0.5+fabs(y)));',(⎕UCS 10),'   if (y < 0.0)',(⎕UCS 10),'        n = -n;',(⎕UCS 10),'   else if (0.0 == y)',(⎕UCS 10),'        n = 0.0;',(⎕UCS 10),'   range = fabs(y);',(⎕UCS 10),'   if (1.0 > range)',(⎕UCS 10),'        range = 1.0;',(⎕UCS 10),'   fuzzlim = QUADct*range;',(⎕UCS 10),'   ny = n-y;',(⎕UCS 10),'   if (fuzzlim < ny)',(⎕UCS 10),'        z = n - 1.0;',(⎕UCS 10),'   else',(⎕UCS 10),'        z = n;',(⎕UCS 10),'   return(toi(z)); ',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment VECTORROTATEAMOUNT 000 i i i . i',(⎕UCS 10),'inline int VectorRotateAmount(int x, int y)',(⎕UCS 10),'{ /* Normalize x rotate for array of shape y on selected axis */',(⎕UCS 10),' /* normalize rotation count */',(⎕UCS 10 10),'if ((0==x) || (0==y))',(⎕UCS 10),'  z = 0;',(⎕UCS 10),'else if (x>0)',(⎕UCS 10),'        z = _mod_SxS_(x,y);',(⎕UCS 10),'     else',(⎕UCS 10),'        z = y - _mod_SxS_(abs(x),y);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment VECTORROTATEAMOUNT *0* i i i . i',(⎕UCS 10),'inline int[+] VectorRotateAmount(int[+] x, int y)',(⎕UCS 10),'{ /* Normalize x rotate for array of shape y on selected axis */',(⎕UCS 10),' /* normalize rotation count */',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .)',(⎕UCS 10),'                : VectorRotateAmount( x[iv], y);',(⎕UCS 10),'        } : genarray( shape(x), 0);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , VECTORROTATEAMOUNT, III, 000, ., I',(⎕UCS 10 10),'%Fragment ABC *00 bidc bidc i . I',(⎕UCS 10),'inline int ABC(int I, int Xshape)',(⎕UCS 10),'{ /* (OLD) Array bounds check for indexed ref X[scalarI] & indexed assign */',(⎕UCS 10),' z = I;',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment ABC *** bidc bidc i . I',(⎕UCS 10),'inline int[+] ABC(int[+] I, int Xshape)',(⎕UCS 10),'{ /* (OLD) Array bounds check for indexed ref X[nonscalarI] & indexed assign */',(⎕UCS 10),' z = I;',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment RadixGradeHistograms x11 x i i . ',(⎕UCS 10),'inline int[.,.] RadixGradeHistograms( int[.] y)',(⎕UCS 10),'{ /* Create histograms for integer radix up/downgrade */',(⎕UCS 10),'  rad = 256;',(⎕UCS 10),'  radixbase = 8;',(⎕UCS 10),'  bitsperint = 32;',(⎕UCS 10),'  numpasses = bitsperint/radixbase;',(⎕UCS 10),'  hist = genarray( [rad * numpasses], 0);',(⎕UCS 10),'  hindex = rad * iota( numpasses);',(⎕UCS 10),'  for( i=0; i<shape(y)[0]; i++) {',(⎕UCS 10),'    for( p=0; p<numpasses; p++) {',(⎕UCS 10),'     v = RadixGradeGetIdx( p, y[i]);',(⎕UCS 10),'     ndx = hindex[p] + v;',(⎕UCS 10),'     hist[ndx] = hist[ndx] + 1;',(⎕UCS 10),'    }',(⎕UCS 10),'  }',(⎕UCS 10),'  z = reshape( [ numpasses, rad], hist);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment RadixGradeOffsets x11 i i i .',(⎕UCS 10),'inline int[.] RadixGradeOffsets( int rad, int pas, int[.,.] hist)',(⎕UCS 10),'{ /* Make per-pass initial offsets into pass result vector */',(⎕UCS 10),'  rd2 = rad / 2;',(⎕UCS 10),'  nnv = sum( drop( [rd2], hist[pas])); /* # of negative results */',(⎕UCS 10),'  z = genarray( [rad], 0);',(⎕UCS 10),'  if( 0 == pas) {',(⎕UCS 10),'    /* Fancy footwork here handles negative numbers */',(⎕UCS 10),'    z[0] = nnv; ',(⎕UCS 10),'    for( i=0; i<(rd2-1); i++) {',(⎕UCS 10),'      z[i+1] = z[i] + hist[pas,i];',(⎕UCS 10),'    }',(⎕UCS 10),'    for( i=rd2; i<rad-1; i++) {',(⎕UCS 10),'      z[i+1] = z[i] + hist[pas,i];',(⎕UCS 10),'    }',(⎕UCS 10),'  } else {',(⎕UCS 10),'    for( i=0; i<(rad-1); i++) {',(⎕UCS 10),'      z[i+1] = z[i] + hist[pas,i];',(⎕UCS 10),'    }',(⎕UCS 10),'  }',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment RadixGradeGetIdx x00 i i i .',(⎕UCS 10),'inline int RadixGradeGetIdx( int pas, int v)',(⎕UCS 10),'{ /* Get masked value for pass pas and value v */',(⎕UCS 10),'  bitsperint = 32;',(⎕UCS 10),'  radixbase = 8;',(⎕UCS 10),'  numpasses = bitsperint/radixbase;',(⎕UCS 10),'  rad = 256;',(⎕UCS 10),'  z = BitAND(( rad - 1), ',(⎕UCS 10),'             BitShiftRight((( numpasses - 1) - pas) * radixbase, v)); ',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment V2O 011 i i i .',(⎕UCS 10),'inline int V2O( int[.] shp, int[.] iv)',(⎕UCS 10),'{ /* Vector iv to offset into array of shape shp */',(⎕UCS 10),'  /* See V2O.dws workspace */',(⎕UCS 10),'  offset = 0;',(⎕UCS 10),'  wt = 1;',(⎕UCS 10),'  for( i=shape(shp)[0]-1; i>=0; i--) {',(⎕UCS 10),'    offset = offset + ( wt * iv[i]);',(⎕UCS 10),'    wt = wt * shp[i];',(⎕UCS 10),'  }',(⎕UCS 10),'  return( offset);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment O2V 110 i i i .',(⎕UCS 10),'inline int[.] O2V( int[.] shp, int offset)',(⎕UCS 10),'{ /* Offset into array of shape shp to index vector */',(⎕UCS 10),'  /* See V2O.dws workspace */',(⎕UCS 10),'  iv = genarray( shape(shp), 1);',(⎕UCS 10),'  wts = iv;',(⎕UCS 10),'  for( i=shape(shp)[0]-2; i>=0; i--) {',(⎕UCS 10),'    wts[i] = wts[i+1] * shp[i+1];',(⎕UCS 10),'  }',(⎕UCS 10 10),'  for( i=shape(shp)[0]-1; i>=0; i--) {',(⎕UCS 10),'    iv[i] = _mod_SxS_( offset/wts[i], shp[i]);',(⎕UCS 10),'    offset = offset - (iv[i]*wts[i]);',(⎕UCS 10),'  }',(⎕UCS 10),'  return( iv);',(⎕UCS 10),'}',(⎕UCS 10 10))
