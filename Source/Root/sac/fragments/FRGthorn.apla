('% Monadic and dyadic thorn formatting functions',(⎕UCS 10 10),'% We don''t do this yet, but should keep it in mind...',(⎕UCS 10),'% Dyalog APL Version 10.1 Ref Man p153 says that monadic format',(⎕UCS 10),'% has these properties:',(⎕UCS 10),'%   1. the decimal points for floating point or scaled formats are aligned.',(⎕UCS 10),'%   2. The E characters for scaled formats are aligned, with trailing zeros',(⎕UCS 10),'%      added to the mantissae if necessary.',(⎕UCS 10),'%   3. Integer formats are aligned to the left of the decimal point column,',(⎕UCS 10),'%      if any, or right-adjusted in the field otherwise.',(⎕UCS 10),'%   4. Each formatted column is separated from its neighbours by a single',(⎕UCS 10),'%      blank column.',(⎕UCS 10),'%   5. The exponent values in scaled formats are left-adjusted to remove any blanks',(⎕UCS 10),'        and + signs.',(⎕UCS 10),'%   6. Scaled notation is used of the magnitude of the non-integer number is too large',(⎕UCS 10),'%      to represent with QAADpp significant digits or if the number requires more',(⎕UCS 10),'%      than five leading zeros after the decimal point. E.g.:',(⎕UCS 10),'%          QUADpp{<-} 5',(⎕UCS 10),'%          thorn 123456.7',(⎕UCS 10),'%      1.2346E5',(⎕UCS 10),'%          thorn 0.0000001234',(⎕UCS 10),'%      1.234E_7',(⎕UCS 10),'%   7. Negative numbers are formatted with ascii ''-'', not high-minus.',(⎕UCS 10 10 10),'%%%%%%%%%%%%% monadic character thorn %%%%%%%%%%%%%%%%%',(⎕UCS 10 10),'%Fragment thrn X** X C C  .',(⎕UCS 10),'inline char[*] $FNAME($YTYPE[*] y, int QUADpp)',(⎕UCS 10),'{ /* Monadic format on characters */',(⎕UCS 10),'  return( y);',(⎕UCS 10),'}',(⎕UCS 10 10),'%%%%%%%%%%%%% monadic Boolean thorn %%%%%%%%%%%%%%%%%',(⎕UCS 10 10),'%Fragment thrn X01 X B C  .',(⎕UCS 10),'inline char[.] $FNAME($YTYPE y, int QUADpp)',(⎕UCS 10),'{ /* Monadic format on Boolean scalar  */',(⎕UCS 10),'  z = y ? ''1'' : ''0'';',(⎕UCS 10),'  return([z]);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment thrn X** X B C  .',(⎕UCS 10),'inline char[+] $FNAME($YTYPE[+] y, int QUADpp)',(⎕UCS 10),'{ /* Monadic format on Boolean non-scalars */',(⎕UCS 10),'  z = format(y, QUADpp);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%%%%%%%%%%%%% monadic integer  thorn %%%%%%%%%%%%%%%%%',(⎕UCS 10 10),'%Fragment thrn X01 X I C .',(⎕UCS 10),'inline char[.] $FNAME($YTYPE y, int QUADpp)',(⎕UCS 10),'{ /* Monadic format on integer scalar  */',(⎕UCS 10),'  z = format(y);',(⎕UCS 10),' return( z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment thrn  X** X I C  .',(⎕UCS 10),'inline char[+] $FNAME($YTYPE[+] y, int QUADpp)',(⎕UCS 10),'{ /* Monadic format on integer non-scalar */',(⎕UCS 10),'  z = format(y);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10),' ',(⎕UCS 10),'%%%%%%%%%%%%% monadic double  thorn %%%%%%%%%%%%%%%%%',(⎕UCS 10 10),'%Fragment thrn X01 X D C  .',(⎕UCS 10),'inline char[.] $FNAME($YTYPE y, int QUADpp)',(⎕UCS 10),'{ /* Monadic format on double scalar  */',(⎕UCS 10),' z = format(y, QUADpp);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment thrn X** X D C .',(⎕UCS 10),'inline char[+] $FNAME($YTYPE[+] y, int QUADpp)',(⎕UCS 10),'{ /* Monadic format on double non-scalar */',(⎕UCS 10),'  /* Refer to UTThorn.dws <threal> for APL model of this */',(⎕UCS 10),'  z = format(y, QUADpp);',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%%%%%%%%%%%%%%%%%%%%%%%%%%% Dyadic Thorn fragments %%%%%%%%%%%%%%%%%%%%%5',(⎕UCS 10 10),'%Fragment thrn 101 BID BID C .',(⎕UCS 10),'inline char[+] $FNAME($XTYPE[2] x,  $YTYPE y)',(⎕UCS 10),'{ /* Dyadic thorn on Boolean, Integer, or double scalar */',(⎕UCS 10),' widths = toi(x[[0]]);',(⎕UCS 10),' precision = toi(x[[1]]);',(⎕UCS 10),' z, junk = APEXDthrn( [y], widths);',(⎕UCS 10),' if ( widths<shape(z)[0]) { ',(⎕UCS 10),'        z = genarray([widths], ''*'');',(⎕UCS 10),' }',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , APEXDthrn,  X$YTC, X11, ., I ',(⎕UCS 10 10),'%Fragment thcharsto 110 C C I   .',(⎕UCS 10),'inline int thcharsto(char[.] ch, char[.] fry)',(⎕UCS 10),'{ /* Find chars left of decimal point (or end) */',(⎕UCS 10),' lim = (shape(fry))[0];',(⎕UCS 10),' z = lim;',(⎕UCS 10),' for(i=0; i<lim; i++) {',(⎕UCS 10),'        if ((fry[[i]] == ch[[0]]) || (fry[[i]] == ch[[1]])) {',(⎕UCS 10),'                z = i;',(⎕UCS 10),'                i = lim;',(⎕UCS 10),'        }',(⎕UCS 10),' }',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'% We should have dyadic thorn for arrays...',(⎕UCS 10),'% with  scalar, 2-element vector, and shape-of-Y-cols X argument...',(⎕UCS 10 10))
