('% Code fragments for search functions',(⎕UCS 10),'% These include x iota y, x epsilon y, x epsbar y',(⎕UCS 10),'%',(⎕UCS 10),'% Rewritten for SAC 2006-11-14 Robert Bernecky',(⎕UCS 10 10 10),'%Fragment iota 111 bi bi i PV',(⎕UCS 10),'inline $ZTYPE $FNAMEPV($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)',(⎕UCS 10),'{',(⎕UCS 10),'/* FIXME! How does a PV interact with QUADIO? */',(⎕UCS 10),'/* Build the index table. This is lots faster than an upgrade,',(⎕UCS 10),' *  and we also do not have to do binary search.',(⎕UCS 10),' * We make the table one element bigger than needed, and',(⎕UCS 10),' * put the not-found index in it.',(⎕UCS 10),' */',(⎕UCS 10 10),' /* Build table as: tbl[i] = x iota i  */',(⎕UCS 10),' tbl = with {',(⎕UCS 10),'         ( . <= iv <= .)',(⎕UCS 10),'                : shape(x)[[0]]+QUADio;',(⎕UCS 10),'        } : genarray([1]+shape(x));',(⎕UCS 10),' tbl = with { ',(⎕UCS 10),'        ( . <= iv <= .)',(⎕UCS 10),'                : y[iv];',(⎕UCS 10),'        }: modarray(shape(x), iv[[0]]);',(⎕UCS 10 10),'/* Now, we can index the table with elements of the',(⎕UCS 10),' * right argument, giving their location in x.',(⎕UCS 10),' * We need a range check, though...',(⎕UCS 10),' */',(⎕UCS 10 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .) {',(⎕UCS 10),'                v = max(to$CT(y[iv]),0);',(⎕UCS 10),'                v = min(v,shape(x)); /* Note that tbl is 1 element',(⎕UCS 10),'                                        than x, so this is OK.  */',(⎕UCS 10),'                } : tbl[[v]];',(⎕UCS 10),'        } : genarray(shape(y)l);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment iota 100  bic bic i .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE[.] x, $YTYPE y$SYSVARGDECL)',(⎕UCS 10),'{ /* Non-fuzzy Vector iota Scalar */',(⎕UCS 10),' sx = shape(x)[[0]];',(⎕UCS 10),' z = sx;',(⎕UCS 10),' for(i=0; i<sx; i++) {',(⎕UCS 10),'        if (to$CT(x[[i]]) == to$CT(y)){',(⎕UCS 10),'                z = i;',(⎕UCS 10),'                i = sx;',(⎕UCS 10),'        }',(⎕UCS 10),' }',(⎕UCS 10),' return(z+QUADio);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment iota 100  d d i .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE[.] x, $YTYPE y$SYSVARGDECL)',(⎕UCS 10),'{ /* Fuzzy Vector iota Scalar */',(⎕UCS 10),' sx = shape(x)[[0]];',(⎕UCS 10),' z = sx;',(⎕UCS 10),' for(i=0; i<sx; i++) {',(⎕UCS 10),'        if (eqDDB(to$CT(x[[i]]),to$CT(y),QUADct)){',(⎕UCS 10),'                z = i;',(⎕UCS 10),'                i = sx;',(⎕UCS 10),'        }',(⎕UCS 10),' }',(⎕UCS 10),' return(z+QUADio);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , eq, DDB, 000, ., $CT',(⎕UCS 10 10),'%Fragment iota 1** b bid i .',(⎕UCS 10),'inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)',(⎕UCS 10),'{ /* Boolean iota number */',(⎕UCS 10),'  /* Right argument almost always scalar */',(⎕UCS 10),'  /* However, we''ll do more work for the nonce, because it''s easy */',(⎕UCS 10),'  sx = shape(x)[[0]];',(⎕UCS 10),'  table = [sx, sx, sx];',(⎕UCS 10),'  table[[0]] = BooleanIotaScalar(x, false);',(⎕UCS 10),'  table[[1]] = BooleanIotaScalar(x, true);',(⎕UCS 10),'  z = with {',(⎕UCS 10),'        (. <= iv <= .){ ',(⎕UCS 10),'                if (toi( y[iv]) == 0) {',(⎕UCS 10),'                        index = 0;',(⎕UCS 10),'                } else if (toi( y[iv]) == 1) {',(⎕UCS 10),'                        index = 1;',(⎕UCS 10),'                } else {',(⎕UCS 10),'                        index = 2;',(⎕UCS 10),'                }',(⎕UCS 10),'                } : table[[index]];',(⎕UCS 10),'        } : genarray( shape(y), -666);',(⎕UCS 10),'  return(z + QUADio);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , BooleanIotaScalar , BBI, 1**, ., $CT',(⎕UCS 10 10),'%Fragment BooleanIotaScalar 1** b b i .',(⎕UCS 10),'inline int  BooleanIotaScalar( bool[.] x, bool y)',(⎕UCS 10),'{ ',(⎕UCS 10),' sx = (shape(x))[[0]];',(⎕UCS 10),' z = sx;',(⎕UCS 10),' for (i=0; i<sx; i++) {',(⎕UCS 10),'        if ( x[[i]] == y) {',(⎕UCS 10),'                z = i;',(⎕UCS 10),'                i = sx;',(⎕UCS 10),'        }',(⎕UCS 10),' } ',(⎕UCS 10),'  return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment iota 100 c c i QUADAV',(⎕UCS 10),'inline $ZTYPE[*] $FNAME($XTYPE[256] x, $YTYPE y$SYSVARGDECL)',(⎕UCS 10),'{ /* QUADav iota character scalar */',(⎕UCS 10),' return(toi(y)+QUADio);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment iota 1** c c i QUADAV',(⎕UCS 10),'inline $ZTYPE[*] $FNAME($XTYPE[256] x, $YTYPE[+] y$SYSVARGDECL)',(⎕UCS 10),'{ /* QUADav iota character non-scalar */',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .)',(⎕UCS 10),'                : toi(y[iv]);',(⎕UCS 10),'        } : genarray(shape(y), 0);',(⎕UCS 10),' return(z+QUADio);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment iota 1** c c i .',(⎕UCS 10),'inline $ZTYPE[*] $FNAME($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)',(⎕UCS 10),'{ /* Character vector iota character non-scalar */',(⎕UCS 10),' table = genarray([256],shape(x)[[0]]); /* Not found */',(⎕UCS 10),' for(i=shape(x)[[0]]-1; i>=0; i--)',(⎕UCS 10),'        table[toi(x[[i]])] = i;',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .)',(⎕UCS 10),'                : table[[toi(y[iv])]];',(⎕UCS 10),'        }: genarray(shape(y), 0);',(⎕UCS 10),' return(z+QUADio);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment iota 1** bid bid i .',(⎕UCS 10),'inline $ZTYPE[+] $FNAME($XTYPE[.] x, $YTYPE[+] y$SYSVARGDECL)',(⎕UCS 10),'{',(⎕UCS 10),'/* General case uses HeapGrade */',(⎕UCS 10),' sx = (shape(x))[[0]];',(⎕UCS 10),' PV = UpgradeHeap(x); /* faster to search x if its sorted! */',(⎕UCS 10),' PV = EPIORemoveDups(x, PV); /* This could be in UpgradeHeap, probably */ ',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .) {',(⎕UCS 10),'                P = BinarySearch(x, y[iv], PV);',(⎕UCS 10),'                /* following for real/complex when quadct != 0 ',(⎕UCS 10),'                }: (P == sx) ? sx : PV[[ MinMatch( x, PV, P)]];',(⎕UCS 10),'                */',(⎕UCS 10),'                }: (P == sx) ? sx : PV[[P]];',(⎕UCS 10),'        }: genarray( shape(y), sx);',(⎕UCS 10),' return(z+QUADio);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , UpgradeHeap , X$YTI,   X10, ., $CT',(⎕UCS 10),'%Generate , BinarySearch, $XT$YTI, 110, ., $CT',(⎕UCS 10),'%Generate , MinMatch    , $XT$YTI, 110, ., $CT',(⎕UCS 10),'%Generate , EPIORemoveDups    , $XT$YTI, 110, ., $CT',(⎕UCS 10 10),'%Fragment EPIORemoveDups 110 bidc bidc i .',(⎕UCS 10),'inline int[.] EPIORemoveDups ($XTYPE[+] x, int[.] PV)',(⎕UCS 10),'{ /* Remove dups from PV of sorted left argument to indexof(right arg of membership */',(⎕UCS 10),' z = PV; ',(⎕UCS 10),' shp = (shape(PV))[[0]];',(⎕UCS 10),' if (0 != shp) {',(⎕UCS 10),'        sink = 0;',(⎕UCS 10),'        source = 1;',(⎕UCS 10),'        while (source < shp) {',(⎕UCS 10),'                if ( x[[z[[sink]]]] != x[[PV[[source]]]]) {',(⎕UCS 10),'                        sink++;',(⎕UCS 10),'                        z[[sink]] = PV[[source]];',(⎕UCS 10),'                }',(⎕UCS 10),'                source++;',(⎕UCS 10),'        }',(⎕UCS 10),' z = take([sink+1], z);',(⎕UCS 10),' }',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment BinarySearch 110 bidc bidc i . ',(⎕UCS 10),'inline int BinarySearch($XTYPE[+] x, $YTYPE y, int[.] PV)',(⎕UCS 10),'{ /* Binary search x[PV] for y',(⎕UCS 10),'   * PV is a permutation vector guaranteed to bring y into',(⎕UCS 10),'   * non-descending order',(⎕UCS 10),'   * If not-found, result is shape(x) ',(⎕UCS 10),'   */',(⎕UCS 10),' found = false;',(⎕UCS 10),' first = 0;',(⎕UCS 10),' sx  = (shape(PV))[[0]];',(⎕UCS 10),' indx = -1;                   /* Bobbo kant kode if this appears! */',(⎕UCS 10),' last = sx - 1;',(⎕UCS 10),' while ((first <= last) && !found) {',(⎕UCS 10),'        indx = (first+last)/2;  /* index of middle entry */',(⎕UCS 10),'        xval = to$CT(x[[PV[[indx]]]]);',(⎕UCS 10),'        yval = to$CT(y); /* This is wrong - type coercion may fail! */',(⎕UCS 10),'        if (    yval == xval) {',(⎕UCS 10),'                found = true;',(⎕UCS 10),'        } else if (yval < xval) {',(⎕UCS 10),'                last = indx - 1;',(⎕UCS 10),'        } else {',(⎕UCS 10),'                first = indx + 1;',(⎕UCS 10),'        }',(⎕UCS 10),' }',(⎕UCS 10),' z = found ? indx : sx;',(⎕UCS 10),' return(z);',(⎕UCS 10),'} ',(⎕UCS 10 10),'%Fragment MinMatch 110 bidc bidc i .',(⎕UCS 10),'inline int MinMatch ($XTYPE[+] x, int[.] PV, int i)',(⎕UCS 10),'{ /* Search permutation vector for minimum match.',(⎕UCS 10),'   * i is an index into PV. PV is a permutation vector for',(⎕UCS 10),'   * x that places x in non-descending order.',(⎕UCS 10),'   *  We want minimum index into x that matches x[[PV[[i]]]]',(⎕UCS 10),'   *  Because upgrade is stable, we only have to look left',(⎕UCS 10),'   *  (except for real/complex x with non-zero {quad}ct)',(⎕UCS 10),'   */',(⎕UCS 10),' v = x[[PV[[i]]]];',(⎕UCS 10),' j = i - 1;',(⎕UCS 10),' r = i;',(⎕UCS 10),' while (j >= 0) {',(⎕UCS 10),'        if ( v == x[[PV[[j]]]]) {',(⎕UCS 10),'                r = j;        /* new minimum index */',(⎕UCS 10),'        } else {',(⎕UCS 10),'                j = -1;       /* no more matches. Stop */  ',(⎕UCS 10),'        }',(⎕UCS 10),'        j = j - 1;',(⎕UCS 10),' }      ',(⎕UCS 10),' return(r);',(⎕UCS 10),'}  ',(⎕UCS 10 10),'%',(⎕UCS 10),'% -------------------- epsilon fragments -----------------------------',(⎕UCS 10),'%',(⎕UCS 10),'%Fragment eps 000 bi bi b .',(⎕UCS 10),'%Fragment eps 000 c  c  b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y)',(⎕UCS 10),'{ /* Non-fuzzy membership SxS*/',(⎕UCS 10),' z = to$CT(x) == to$CT(y);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment eps 000 d d b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y$SYSVARGDECL)',(⎕UCS 10),'{ /* Fuzzy membership SxS */',(⎕UCS 10),' z = TEQ$CT(to$CT(x),to$CT(y)$SYSVARGKER);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment eps 010  bic bic b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE[.] y$SYSVARGDECL)',(⎕UCS 10),'{ /* Non-fuzzy membership SxA */',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (0*shape(y) <= iv < shape(y))',(⎕UCS 10),'                : to$CT(x) == to$CT(y[iv]);',(⎕UCS 10),'        } : foldfix(|, false, true);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment eps 010  d   d  b .',(⎕UCS 10),'%Fragment eps 010  bi  d  b .',(⎕UCS 10),'%Fragment eps 010  d  bi  b .',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE[.] y$SYSVARGDECL)',(⎕UCS 10),'{ /* Fuzzy membership SxA*/',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (0*shape(y) <= iv < shape(y))',(⎕UCS 10),'                : eqDDB(to$CT(x),to$CT(y[[i]]),QUADct);',(⎕UCS 10),'        } : foldfix(|, false, true);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , eq, DDB, 000, ., $CT',(⎕UCS 10 10),'%Fragment eps *0* bic bic b .',(⎕UCS 10),'inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE y$SYSVARGDECL)',(⎕UCS 10),'{ /* Non-fuzzy membership AxS */',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .) ',(⎕UCS 10),'                : (to$CT(x) == to$CT(y);',(⎕UCS 10),'        } : foldfix(|, false, true);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment eps *0* bid d b .',(⎕UCS 10),'inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE y$SYSVARGDECL)',(⎕UCS 10),'{ /* Fuzzy membership AxS */',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (0*shape(y) <= iv < shape(y))',(⎕UCS 10),'                : eqDDB(to$CT(x[iv]),to$CT(y),QUADct);',(⎕UCS 10),'        } : foldfix(|, false, true);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , eq, DDB, 000, ., $CT',(⎕UCS 10 10),'%Fragment eps *** c c b .',(⎕UCS 10),'inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[+] y$SYSVARGDECL)',(⎕UCS 10),'{ /* character membership AxA*/',(⎕UCS 10),' ry = comaX$YT$YT(y);',(⎕UCS 10),' tbl = genarray([256],false);',(⎕UCS 10),' for(i=0; i<shape(ry)[[0]]; i++) {',(⎕UCS 10),'  tbl[[toi(ry[[i]])]] = true;',(⎕UCS 10),' }',(⎕UCS 10 10),' z = with { ',(⎕UCS 10),'        (. <= iv <= .)',(⎕UCS 10),'                : tbl[[toi(x[iv])]];',(⎕UCS 10),'        } : genarray(shape(x), false);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , coma, X$YT$YT, X*1, ., $YT',(⎕UCS 10),' ',(⎕UCS 10),'%Fragment eps *** c c b QUADAV',(⎕UCS 10),'inline $ZTYPE[*] $FNAME($XTYPE[*] x, $YTYPE[256] y$SYSVARGDECL)',(⎕UCS 10),'{ /* A member QUADav. This is kinda silly... */',(⎕UCS 10),' z = genarray(shape(x), true);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment eps *** bid c    b .',(⎕UCS 10),'%Fragment eps *** c   bid  b .',(⎕UCS 10),'inline $ZTYPE[*] $FNAME($XTYPE[*] x, $YTYPE[*] y$SYSVARGDECL)',(⎕UCS 10),'{ /* Char member non-char, and vice versa */',(⎕UCS 10),' z = genarray(shape(x), false);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10 10),'%Fragment eps *** bidc bidc bidc .',(⎕UCS 10),'inline $ZTYPE[+] $FNAME($XTYPE[+] x, $YTYPE[+] y$SYSVARGDECL)',(⎕UCS 10),'{ /*  Fuzzy, non-fuzzy Membership AxA*/',(⎕UCS 10),'/* General case: uses HeapGrade */',(⎕UCS 10),' sy = (shape(y))[[0]];',(⎕UCS 10),' PV = UpgradeHeap(y); /* faster to search y if its sorted! */',(⎕UCS 10),' PV = EPIORemoveDups(y, PV); /* This could be in UpgradeHeap, probably */ ',(⎕UCS 10),' z = with {',(⎕UCS 10),'        (. <= iv <= .) {',(⎕UCS 10),'                P = BinarySearch(y, x[iv], PV);',(⎕UCS 10),'                /* Binary search could quickstop on a match here... */',(⎕UCS 10),'                }: P != sy;',(⎕UCS 10),'        }: genarray( shape(x), false);',(⎕UCS 10),' return(z);',(⎕UCS 10),'}',(⎕UCS 10),'%Generate , UpgradeHeap , X$YTI,   X10, ., $CT',(⎕UCS 10),'%Generate , BinarySearch, $XT$YTI, 110, ., $CT',(⎕UCS 10),'%Generate , MinMatch    , $XT$YTI, 110, ., $CT',(⎕UCS 10),'%Generate , EPIORemoveDups    , $XT$YTI, 110, ., $CT',(⎕UCS 10 10),'% ------------------ ebar fragments -------------------------------',(⎕UCS 10 10),'%',(⎕UCS 10),'%',(⎕UCS 10),'%Fragment epsb 111 bidc bidc b .',(⎕UCS 10),'inline $ZTYPE[.] $FNAME($XTYPE[.] x, $YTYPE[.] y$SYSVARGDECL)',(⎕UCS 10),'{',(⎕UCS 10),'WONTWORK',(⎕UCS 10),'}',(⎕UCS 10),'%',(⎕UCS 10),'function $FNAME(x1: array[$XTYPE]; ',(⎕UCS 10),'                y1: array[$YTYPE]',(⎕UCS 10),'                returns array[boolean])',(⎕UCS 10 10),'% We look for the left arg in the right arg.',(⎕UCS 10),'% We should implement Boyer-Moore here, but time is',(⎕UCS 10),'% tight. 1996-02-12',(⎕UCS 10),'% This is OK for short phrases. Should have algorithm',(⎕UCS 10),'% selector in code generator for this.',(⎕UCS 10 10),'$SFCASES{{ % General case (0)',(⎕UCS 10),'MATCHRESTVECTOR($XTYPE,$YTYPE,$XT,$YT,$CT)',(⎕UCS 10 10),' if IsEmpty(x1) then array_fill(0,array_limh(y1),true) % x1 empty',(⎕UCS 10),' else',(⎕UCS 10),' let ',(⎕UCS 10),'  lasti := array_limh(y1) - array_limh(x1); % Last y1 index where',(⎕UCS 10),'                                            % match can occur',(⎕UCS 10),' in',(⎕UCS 10),'   for y0 in y1 at i returns array of',(⎕UCS 10),'    if $XTto$CT(x1[0]) ~= $YTto$CT(y0) ',(⎕UCS 10),'     % Quick out if no match on first character',(⎕UCS 10),'      | i > lasti          % or past end of y1',(⎕UCS 10),'    then false',(⎕UCS 10),'    else MatchRestVector(x1,y1,i)',(⎕UCS 10),'    end if',(⎕UCS 10),'   end for',(⎕UCS 10),' end let',(⎕UCS 10),' end if',(⎕UCS 10),'end function',(⎕UCS 10),'}}',(⎕UCS 10),' ',(⎕UCS 10),'%',(⎕UCS 10),'%Fragment epsb 122 bidc bidc b .',(⎕UCS 10),'%',(⎕UCS 10),'inline $ZTYPE $FNAME($XTYPE x, $YTYPE y$SYSVARGDECL)',(⎕UCS 10),'{',(⎕UCS 10),'}',(⎕UCS 10),'function $FNAME(x1: array[$XTYPE]; ',(⎕UCS 10),'                y2: array[$YTYPE]',(⎕UCS 10),'                returns array[array[boolean]])',(⎕UCS 10 10),'% We look for the left arg in the right arg.',(⎕UCS 10),'% We should implement Boyer-Moore here, but time is',(⎕UCS 10),'% tight. 1996-02-12',(⎕UCS 10),'% This is OK for short phrases. Should have algorithm',(⎕UCS 10),'% selector in code generator for this.',(⎕UCS 10),'$SFCASES{{ % General case (0)',(⎕UCS 10 10),' MATCHRESTVECTOR($XTYPE,$YTYPE,$XT,$YT,$CT)',(⎕UCS 10 10),' if IsEmpty(x1) = 0 then ',(⎕UCS 10),'     array_fill(array_fill(0,array_limh(y2),',(⎕UCS 10),'        % Stupid empty array kludge needed here',(⎕UCS 10),'          array_fill(0,array_limh(y2[0]),true) % x1 empty',(⎕UCS 10),' else',(⎕UCS 10),'  for y1 in y2 returns array of ',(⎕UCS 10),'   let ',(⎕UCS 10),'    lasti := array_limh(y1) - array_limh(x1); % Last y1 index where',(⎕UCS 10),'                                              % match can occur',(⎕UCS 10),'   in',(⎕UCS 10),'     for y0 in y1 at i returns array of',(⎕UCS 10),'      if $XTto$CT(x1[0]) ~= $YTto$CT(y0) ',(⎕UCS 10),'       % Quick out if no match on first character',(⎕UCS 10),'        | i > lasti          % or past end of y1',(⎕UCS 10),'      then false',(⎕UCS 10),'      else MatchRestVector(x1,y1,i)',(⎕UCS 10),'      end if',(⎕UCS 10),'     end for',(⎕UCS 10),'   end let',(⎕UCS 10),'  end for',(⎕UCS 10),' end if',(⎕UCS 10),'}}',(⎕UCS 10),'end function',(⎕UCS 10 10))
