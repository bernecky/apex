⌷ctl←
<array><shape>26 6</shape>
<array><shape>215</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Scalar-Scalar inner product */£%A;  z =  $FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$XT$GZT, 000, ., $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>000</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>215</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Scalar-Scalar inner product */£%A;  z =  $FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$XT$GZT, 000, ., $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>000</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>215</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Scalar-Scalar inner product */£%A;  z =  $FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$XT$GZT, 000, ., $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>000</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>315</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Scalar-Vector inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $XT$CT$GCT, 011, ., $CT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>010</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>315</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Scalar-Vector inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $XT$CT$GCT, 011, ., $CT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>010</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>315</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Scalar-Vector inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $XT$CT$GCT, 011, ., $CT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>010</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>313</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Vector-Scalar inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$CT$GZT, 101, ., $CT£%A;%Generate $FNM,   sl,      X$GZT$ZT,   X10, $SPECRED, $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>100</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>313</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Vector-Scalar inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$CT$GZT, 101, ., $CT£%A;%Generate $FNM,   sl,      X$GZT$ZT,   X10, $SPECRED, $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>100</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>313</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Vector-Scalar inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$CT$GZT, 101, ., $CT£%A;%Generate $FNM,   sl,      X$GZT$ZT,   X10, $SPECRED, $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>100</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>323</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Vector-Vector inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$CT$GZT, 111, ., $CT£%A;%Generate $FNM,         sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>110</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>323</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Vector-Vector inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$CT$GZT, 111, ., $CT£%A;%Generate $FNM,         sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>110</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>323</shape><string>inline $ZTYPE $FNAME$IPALG($XTYPE[.] x, $YTYPE[.] y$SYSVARFGDECL)£%A;{ /* Vector-Vector inner product */£%A;  z =  $FLVALUEX$GZT$ZT$SPECRED($FRVALUE$CT$CT$GZT(to$CT(x),to$CT(y)$SYSVARGKER)$SYSVARFKER);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $CT$CT$GZT, 111, ., $CT£%A;%Generate $FNM,         sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>110</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>554</shape><string>inline $ZTYPE[*] $FNAME$IPALG($XTYPE x, $YTYPE[*] y$SYSVARFGDECL)£%A;{ /* TRANSPOSE case of inner product z = scalar f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1], shape(yt));£%A; z = with {£%A;     (. &lt;= iv &lt;= .) {£%A;               vy = yt[iv];£%A;    } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(xct,vy$SYSVARGKER)$SYSVARFKER);£%A;       } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate ,     $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>0**</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>554</shape><string>inline $ZTYPE[*] $FNAME$IPALG($XTYPE x, $YTYPE[*] y$SYSVARFGDECL)£%A;{ /* TRANSPOSE case of inner product z = scalar f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1], shape(yt));£%A; z = with {£%A;     (. &lt;= iv &lt;= .) {£%A;               vy = yt[iv];£%A;    } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(xct,vy$SYSVARGKER)$SYSVARFKER);£%A;       } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,   TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate ,     $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>0**</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>437</shape><string>inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Inner product z =  f.g scalar-y */£%A; shp = drop([-1], shape(x));£%A; z = with {£%A;       (. &lt;= iv &lt;= .) {£%A;       } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(to$GCT(x[iv]),to$GCT(y)$SYSVARGKER)$SYSVARFKER);£%A;       } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,   $FRVALUE, $GCT$GCT$GZT, 101, ., $GCT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>*0*</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>437</shape><string>inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Inner product z =  f.g scalar-y */£%A; shp = drop([-1], shape(x));£%A; z = with {£%A;       (. &lt;= iv &lt;= .) {£%A;       } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(to$GCT(x[iv]),to$GCT(y)$SYSVARGKER)$SYSVARFKER);£%A;       } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,   $FRVALUE, $GCT$GCT$GZT, 101, ., $GCT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>*0*</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>437</shape><string>inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE y$SYSVARFGDECL)£%A;{ /* Inner product z =  f.g scalar-y */£%A; shp = drop([-1], shape(x));£%A; z = with {£%A;       (. &lt;= iv &lt;= .) {£%A;       } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(to$GCT(x[iv]),to$GCT(y)$SYSVARGKER)$SYSVARFKER);£%A;       } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,   $FRVALUE, $GCT$GCT$GZT, 101, ., $GCT£%A;%Generate $FNM,    sl,      X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>*0*</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>715</shape><string>inline $ZTYPE[*] $FNAME$IPALG($XTYPE[.] x, $YTYPE[*] y$SYSVARFGDECL)£%A;{ /* TRANSPOSE case of inner product z = vector_f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; /* if (1 != shape(xct)[[0]]) FIXME; length error check */£%A;£%A; shp = drop([-1],shape(xct)) ++ drop([1], shape(y));£%A; z = with {£%A;        (. &lt;= iv &lt;= .) {£%A;               vx = xct[take([dim(x)-1], iv)];£%A;                vy = yt[ reverse(take([1-dim(y)], iv))];£%A;       } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);£%A;         } :genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,    TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate ,     $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT£%A;%Generate $FNM, sl, X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>1**</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>1139</shape><string>inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)£%A;{ /* CDC STAR-100 APL Algorithm for inner product */£%A;£%A; /* This computes, for z=x f.g y,£%A;  *          z[i;] = z[i;]f x[i;j]g y[j;]£%A;  *  Thus, it runs stride-1, and we only fetch left argument£%A;  *  elements once. It includes skipping a g row iteration and£%A;  *  an f row-reduce iteration when x[i;j] generates an identity for f.£%A;  *  R. Bernecky 2005-11-24£%A;  */£%A;  rowsx = drop([-1],shape(x));£%A;  colsx = shape(x)[[dim(x)-1]];£%A;  colsy = shape(y)[[dim(y)-1]];£%A;  Zrow = genarray([colsy],$OTFILL);£%A;  /* Parallel over rows of x */£%A;  z = with {£%A;    (. &lt;= [row] &lt;= .) {£%A;       Crow = Zrow;£%A;       for (colx=0; colx&lt;colsx; colx++) {£%A;         xel = x[row,colx];£%A;         xel = to$GCT(xel);£%A;         if (to$GCT($FGID) != xel) { /* Skip iteration if it's an identity */£%A;           VEC = $FRVALUE$GCT$GCT$GZT(xel,to$GCT(y[[colx]])$SYSVARGKER);£%A;           Crow = $FNM$ZT$ZT$ZT( to$CT(VEC), Crow $SYSVARFKER);£%A;         }£%A;       }£%A;     } : Crow;£%A;  } : genarray( rowsx, Zrow);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT£%A;%Generate , $FNM,        $ZT$ZT$ZT,  111 , ., $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>*1*</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>1139</shape><string>inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)£%A;{ /* CDC STAR-100 APL Algorithm for inner product */£%A;£%A; /* This computes, for z=x f.g y,£%A;  *          z[i;] = z[i;]f x[i;j]g y[j;]£%A;  *  Thus, it runs stride-1, and we only fetch left argument£%A;  *  elements once. It includes skipping a g row iteration and£%A;  *  an f row-reduce iteration when x[i;j] generates an identity for f.£%A;  *  R. Bernecky 2005-11-24£%A;  */£%A;  rowsx = drop([-1],shape(x));£%A;  colsx = shape(x)[[dim(x)-1]];£%A;  colsy = shape(y)[[dim(y)-1]];£%A;  Zrow = genarray([colsy],$OTFILL);£%A;  /* Parallel over rows of x */£%A;  z = with {£%A;    (. &lt;= [row] &lt;= .) {£%A;       Crow = Zrow;£%A;       for (colx=0; colx&lt;colsx; colx++) {£%A;         xel = x[row,colx];£%A;         xel = to$GCT(xel);£%A;         if (to$GCT($FGID) != xel) { /* Skip iteration if it's an identity */£%A;           VEC = $FRVALUE$GCT$GCT$GZT(xel,to$GCT(y[[colx]])$SYSVARGKER);£%A;           Crow = $FNM$ZT$ZT$ZT( to$CT(VEC), Crow $SYSVARFKER);£%A;         }£%A;       }£%A;     } : Crow;£%A;  } : genarray( rowsx, Zrow);£%A;  return(z);£%A;}£%A;%Generate , $FRVALUE, $GCT$GCT$GZT, 011, ., $GCT£%A;%Generate , $FNM,        $ZT$ZT$ZT,  111 , ., $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>*2*</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>1115</shape><string>inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)£%A;{ /* CDC STAR-100 APL Algorithm for inner product */£%A; /* This computes, for z=x f.g y,£%A;  *            z[i;] = z[i;]f x[i;j]g y[j;]£%A;  *  Thus, it runs stride-1, and we only fetch left argument£%A;  *  elements once. It is similar to dotSTAR, except that:£%A;  *   1. "f" is such that we can't avoid the reduce step.£%A;  *   2. "x[i;j] f" is such that it may produce an identity on y[j;].£%A;  *      If so, we don't apply f to that row.£%A;  *  R. Bernecky 2005-11-24£%A;  */£%A;  rowsx = drop([-1],shape(x));£%A;  colsx = shape(x)[[dim(x)-1]];£%A;  colsy = shape(y)[[dim(y)-1]];£%A;  Zrow = genarray([colsy],$OTFILL);£%A;  /* Parallel over rows of x */£%A;  z = with {£%A;    (. &lt;= [row] &lt;= .) {£%A;      Crow = Zrow;£%A;      for (colx=0; colx&lt;colsx; colx++) {£%A;        xel = x[row,colx];£%A;        xel = to$GCT( xel);£%A;        if (to$GCT($FGID) != xel) { /* Skip iteration if it's an f identity */£%A;          Crow = $FNM$ZT$ZT$ZT( to$CT( y[colx]), Crow $SYSVARFKER);£%A;        }£%A;      }£%A;    } : Crow;£%A;  }: genarray( rowsx, Zrow);£%A;  return(z);£%A;}£%A;%Generate , $FNM,         $ZT$ZT$ZT,  111 , ., $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>*1*</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>1115</shape><string>inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+]x, $YTYPE[+]y$SYSVARFGDECL)£%A;{ /* CDC STAR-100 APL Algorithm for inner product */£%A; /* This computes, for z=x f.g y,£%A;  *            z[i;] = z[i;]f x[i;j]g y[j;]£%A;  *  Thus, it runs stride-1, and we only fetch left argument£%A;  *  elements once. It is similar to dotSTAR, except that:£%A;  *   1. "f" is such that we can't avoid the reduce step.£%A;  *   2. "x[i;j] f" is such that it may produce an identity on y[j;].£%A;  *      If so, we don't apply f to that row.£%A;  *  R. Bernecky 2005-11-24£%A;  */£%A;  rowsx = drop([-1],shape(x));£%A;  colsx = shape(x)[[dim(x)-1]];£%A;  colsy = shape(y)[[dim(y)-1]];£%A;  Zrow = genarray([colsy],$OTFILL);£%A;  /* Parallel over rows of x */£%A;  z = with {£%A;    (. &lt;= [row] &lt;= .) {£%A;      Crow = Zrow;£%A;      for (colx=0; colx&lt;colsx; colx++) {£%A;        xel = x[row,colx];£%A;        xel = to$GCT( xel);£%A;        if (to$GCT($FGID) != xel) { /* Skip iteration if it's an f identity */£%A;          Crow = $FNM$ZT$ZT$ZT( to$CT( y[colx]), Crow $SYSVARFKER);£%A;        }£%A;      }£%A;    } : Crow;£%A;  }: genarray( rowsx, Zrow);£%A;  return(z);£%A;}£%A;%Generate , $FNM,         $ZT$ZT$ZT,  111 , ., $CT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>*2*</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>731</shape><string>inline $ZTYPE[*] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* QUICKSTOP0 case of inner product z = matrix f.g matrix */£%A;  /* The reduction quick-stops if any of its results are zero */£%A;  /* E.g., char ^.= char */£%A;£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1],shape(x)) ++ drop([1], shape(y));£%A; z = with {£%A;   (. &lt;= iv &lt;= .) {£%A;      vx = xct[take([dim(x)-1], iv)];£%A;      vy = yt[ reverse(take([1-dim(y)], iv))];£%A;    } : $FNMslX$GZT$ZTQUICKSTOP($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);£%A; } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,       TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate , $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT£%A;%Generate $FNM,        sl,      X$GZT$ZT,   X10, QUICKSTOP, $ZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>***</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>618</shape><string>inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* Generic case of inner product z = x f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1],shape(x)) ++ drop([1], shape(y));£%A; z = with {£%A;   (. &lt;= iv &lt;= .) {£%A;     vx = xct[take([dim(x)-1], iv)];£%A;     vy = yt[ reverse(take([1-dim(y)], iv))];£%A;   } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);£%A; } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,       TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate ,     $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT£%A;%Generate $FNM, sl      , X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>***</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>618</shape><string>inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* Generic case of inner product z = x f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1],shape(x)) ++ drop([1], shape(y));£%A; z = with {£%A;   (. &lt;= iv &lt;= .) {£%A;     vx = xct[take([dim(x)-1], iv)];£%A;     vy = yt[ reverse(take([1-dim(y)], iv))];£%A;   } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);£%A; } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,       TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate ,     $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT£%A;%Generate $FNM, sl      , X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>***</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>618</shape><string>inline $ZTYPE[+] $FNAME$IPALG($XTYPE[+] x, $YTYPE[+] y$SYSVARFGDECL)£%A;{ /* Generic case of inner product z = x f.g y */£%A; yt = to$GCT(TRANSPOSE(y));£%A; xct = to$GCT(x);£%A; shp = drop([-1],shape(x)) ++ drop([1], shape(y));£%A; z = with {£%A;   (. &lt;= iv &lt;= .) {£%A;     vx = xct[take([dim(x)-1], iv)];£%A;     vy = yt[ reverse(take([1-dim(y)], iv))];£%A;   } : $FNMslX$GZT$ZT$SPECRED($FRVALUE$GCT$GCT$GZT(vx,vy$SYSVARGKER)$SYSVARFKER);£%A; } : genarray(shp, $OTFILL);£%A; return(z);£%A;}£%A;%Generate ,       TRANSPOSE, X$YT$YT, X**, ., $YT£%A;%Generate ,     $FRVALUE, $GCT$GCT$GZT, 111, ., $GCT£%A;%Generate $FNM, sl      , X$GZT$ZT,   X10, $SPECRED, $GZT£%A;£%A;</string></array>
<array><shape>3</shape><string>dot</string></array>
<array><shape>3</shape><string>***</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array>
<array><shape>4</shape><string>bidc</string></array></array>
