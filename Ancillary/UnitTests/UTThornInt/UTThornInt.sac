
breakme; // compiles forever

use Array: all;
use StdIO : all;
use Numerical : all;
use CommandLine: all;
use String: {to_string,tochar,sscanf};
use ArrayFormat: all;
use Bits: all;

/* Compiled by APEX Version: /home/apex/apex3/wss/sac3014.dws2013-07-29 16:18:26.006 */
/*
% This is the APEX stdlib.sis include file.
% Standard equates and constants for APL compiler
% Also standard coercion functions
*/

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

#define BtoB(x) ((x))
#define ItoI(x) ((x))
#define DtoD(x) ((x))
#define CtoC(x) ((x))

#define BtoI(x) toi((x))
#define BtoD(x) tod((x))
#define ItoB(x) to_bool((x))
#define ItoD(x) tod((x))
#define DtoB(x) to_bool((x))
#define DtoI(x) toi((x))


inline int maxXDI(double y, double QUADct)
{ /* Ceiling */
 return(-DFLOOR(-y, QUADct));
}


inline int modXII(int y)
{ return(abs(toI(y)));
}

inline int[+] modXII(int[+] y)
{ /* Monadic scalar functions on array */
  z = with {
        ( . <= iv <= .)
                : modXII(toI(y[iv]));
        } : genarray(shape(y), 0);
  return(z);
}

inline bool[+] modXBB(bool[+] y)
{ /* Monadic scalar functions on array */
  z = with {
        ( . <= iv <= .)
                : modXBB(toB(y[iv]));
        } : genarray(shape(y), false);
  return(z);
}

inline int barIBI(int x, bool y)
{ return(ItoI(x)-BtoI(y));
}

inline bool ltIBB(int x, bool y)
{ /* A<B on Boot/Int/Char */
  return(ItoI(x)<BtoI(y));
}

inline int mpyIII(int x, int y)
{ return(ItoI(x)*ItoI(y));
}

inline double divIID(int x, int y)
{ dx = ItoD(x);
  dy = ItoD(y);
  z = (dx == dy) ? 1.0  : dx/dy;
  return(z);
}

inline bool neIBB(int x, bool y)
{/* A !=B on non-doubles */
 return(ItoI(x) != BtoI(y));
}

inline int barIII(int x, int y)
{ return(ItoI(x)-ItoI(y));
}

inline bool eqIBB(int x, bool y)
{ /* A=B on non-doubles */
 return(ItoI(x) == BtoI(y));
}

inline int maxBII(bool x, int y)
{ /* x max y */
 return (max(BtoI(x),ItoI(y)));
}

inline bool andBBB(bool x, bool y)
{ return(BtoB(x)&BtoB(y));
}

inline int plusIII(int x, int y)
{ return(ItoI(x)+ItoI(y));
}

inline int barBBI(bool x, bool y)
{ return(BtoI(x)-BtoI(y));
}

inline bool ltBBB(bool x, bool y)
{ return((!x)&y);
}

/* NB.  APEX Extension of ISO APL to allow comparison of characters */
/* relationals */
inline int mpyBII(bool x, int y)
{ return(BtoI(x)*ItoI(y));
}

inline int[+] mpyBII(bool x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : mpyIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] eqCCB(char[+] x, char y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : eqCCB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[+] maxIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : maxIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] ltIBB(int[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : ltIBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] geIIB(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : geIIB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline bool[+] mpyBBB(bool[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : mpyBBB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline int[+] plusIBI(int[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : plusIBI(xel,yel);
        } : genarray(sy, 0);
  return(z);
}






inline int[+] plusIBI(int[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : plusIBI(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline int[+] plusIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] maxIBI(int x, bool[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : maxIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] ltBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : ltBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[.] rotrXII(int[.] y)
{ /* Vector reverse */
  z = Array::reverse( 0, y);
  return( z);
}

inline char[.] comaXCC(char[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline int[.] comaXII(int[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline int[.] comaXII(int y)
{ /* Ravel of scalar */
  return([y]);
}

inline int[.] comaXII(int[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] comaXCC(char[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] rhoICC(int x, char[*] y)
{ /* Scalar reshape non-scalar (to vector) */
 z = rhoICC( [toi(x)],y);
 return(z);
}


inline int[.] rhoIII(int x, int[*] y)
{ /* Scalar reshape non-scalar (to vector) */
 z = rhoIII( [toi(x)],y);
 return(z);
}


inline int[*] rhoIII(int[.] x, int[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _mod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), 0);
   return( z);
}



inline char[*] rhoICC(int[.] x, char[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _mod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), ' ');
   return( z);
}



inline bool[*] rhoIBB(int[.] x, bool[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _mod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), false);
   return( z);
}



inline int[.] takeIII(int x, int[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[*] dropIII(int x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[.] iotaXII(int y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[.]  rhoXCI(char[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXII(int[1] y, int QUADio)
{ /* Index generator on 1-element vector */
 /* HELP! Needs length error check */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y[[0]]));
  return( z);
}

inline int[.]  rhoXII(int[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline char[.] thrnXIC(int y, int QUADpp)
{ /* Monadic format on integer scalar  */
  z = format(y);
 return( z);
}

inline char[.] thrnXBC(bool y, int QUADpp)
{ /* Monadic format on Boolean scalar  */
  z = y ? '1' : '0';
  return([z]);
}

inline char[+] thrnXIC(int[+] y, int QUADpp)
{ /* Monadic format on integer non-scalar */
  z = format(y);
  return(z);
}


inline bool[*] quadXBB(bool[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline int[.]  rhoXBI(bool[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[2] comaIII(int x, int y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline char[2] comaCCC(char x, char y)
{/* SxS catenate first (or last) axis */
 return([toC(x)]++[toC(y)]);
}

inline int[.] comaBII(bool x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline int[.] comaIII(int x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline int[2] comaIBI(int x, bool y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline int[.] comaIII(int[.] x, int[.] y)
{ /* VxV catenate first or last axis */
 return(toI(x)++toI(y));
}

inline bool[2] comaBBB(bool x, bool y)
{/* SxS catenate first (or last) axis */
 return([toB(x)]++[toB(y)]);
}

inline bool[.] comaBBB(bool[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toB(x)++[toB(y)]);
}

inline bool[.] comaBBB(bool[.] x, bool[.] y)
{ /* VxV catenate first or last axis */
 return(toB(x)++toB(y));
}

inline bool sameCCB(char[+] x, char[+] y)
{ /* Non-scalar match non-scalar */
   z = (( _dim_A_( x) == _dim_A_( y))          &&
       ( all( _shape_A_( x) == _shape_A_( y))) &&
       ( all( eqCCB(toC( x),  toC( y)))));
  return(z);
}



inline bool sameIIB(int[+] x, int[+] y)
{ /* Non-scalar match non-scalar */
   z = (( _dim_A_( x) == _dim_A_( y))          &&
       ( all( _shape_A_( x) == _shape_A_( y))) &&
       ( all( eqIIB(toI( x),  toI( y)))));
  return(z);
}



inline int[*] indr(int[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline char[*] indr(char[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline bool[*] indr(bool[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline char[+] inds0(char[+] X, int  I0, char Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = CtoC(X);
 Y = Yin;

 
 z[[I0]]=CtoC((Y));

 
 return(z);
}



inline char[+] inds1(char[+] X, int [+] I0, char Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = CtoC(X);
 Y = Yin;

 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=CtoC((Y));

 }

 return(z);
}



inline char[+] inds01(char[+] X, int  I0,int [+] I1, char[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = CtoC(X);
  for(i1=0; i1<shape(I1)[[0]]; i1++){

 z[[I0,I1[[i1]]]]=CtoC((Y[[i1]]));

  }

 return(z);
}



inline int[+] indsxxx0(int[+] X, int  I3, int Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = ItoI(X);
 Y = Yin;

 for(i0=0; i0<shape(X)[[0]]; i0++){
 for(i1=0; i1<shape(X)[[1]]; i1++){
  for(i2=0; i2<shape(X)[[2]]; i2++){

 z[[i0,i1,i2,I3]]=ItoI((Y));

 }
 }
  }

 return(z);
}



inline bool[*] jotdotgeIIB(int [+] x, int [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), false);
 z = with {
        (. <= iv <= .) {
         xitem = toI(x[iv]);
        } : geIIB(xitem, toI(y));
        } : genarray(shape(x), cell);
 return(z);
}

inline int[*] jotdotmpyIII(int [+] x, int [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), 0);
 z = with {
        (. <= iv <= .) {
         xitem = toI(x[iv]);
        } : mpyIII(xitem, toI(y));
        } : genarray(shape(x), cell);
 return(z);
}

inline int[.] slBII(bool[.] x, int[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], 0);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline int[.] slBII(bool x, int y)
{ /* Scalar replicate scalar */
 z = with {
        (. <= iv <= .)
                : y;
        } : genarray([toi(x)]);
 return(z);
}

inline bool[.] slBBB(bool x, bool y)
{ /* Scalar replicate scalar */
 z = with {
        (. <= iv <= .)
                : y;
        } : genarray([toi(x)]);
 return(z);
}

inline int[.] slBII(bool x, int[.] y)
{ /* Scalar replicate vector */
 cell = genarray([toi(x)], 0);
 z = with {
        (. <= iv <= .)
                : genarray([toi(x)], y[iv]);
        } : genarray(shape(y), cell);
 return(comaXII(z));
}


inline int[+] slBII(bool x, int[+] y)
{ /* Boolean scalar compress non-scalar */
  sy = shape(y);
  z = (true == toB(x)) ?  y  : genarray(drop([-1],sy)++[0],0);
  return(z);
}

inline int[.] mpybslXII(int[.] y)
{ /* Scan of vector */
/* This does the scan in the wrong direction, but since
 * we assume associative functions only, it should be ok.
 */
 size = shape(y);
 z = genarray(size,ItoI(1));
 if (0 != size[[0]]) {
        /* real work to do */
        z[[0]] = ItoI(y[[0]]); /* Not sure about the coercion... */
        for ( i=1; i<size[[0]]; i++) {
                z[[i]] = mpyIII(ItoI(z[[i-1]]),ItoI(y[[i]]));
        }
  }
 return(z);
}


inline int[+] plusslXBIFOLD(bool[+] y)
{ /* last axis reduce rank-2 or greater matrix w/folding */
  sy = shape(y);
  zrho = drop([-1], sy);
  z = with {
         (. <= iv <= .)
                : plusslXBIFOLD(y[iv]);
        } : genarray(zrho, 0);
  return(z);
}


inline int mpyslXIIQUICKSTOP(int[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : ItoI(y[iv]);
        } : foldfix( mpyIII, ItoI(1), ItoI(0));
  return(z);
}


inline int[.] maxsl1XIIFOLD(int[.,.] y)
{ /* first-axis reduce rank-2 matrix */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : maxslXIIFOLD(yt[iv]);
        } : genarray(zrho, 0);
  return(z);
}




inline int[.] minsl1XIIFOLD(int[.,.] y)
{ /* first-axis reduce rank-2 matrix */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : minslXIIFOLD(yt[iv]);
        } : genarray(zrho, 0);
  return(z);
}




inline int[.] plusbslXII(int[.] y)
{ /* Scan of vector */
/* This does the scan in the wrong direction, but since
 * we assume associative functions only, it should be ok.
 */
 size = shape(y);
 z = genarray(size,ItoI(0));
 if (0 != size[[0]]) {
        /* real work to do */
        z[[0]] = ItoI(y[[0]]); /* Not sure about the coercion... */
        for ( i=1; i<size[[0]]; i++) {
                z[[i]] = plusIII(ItoI(z[[i-1]]),ItoI(y[[i]]));
        }
  }
 return(z);
}


inline int plusslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline bool andslXBBQUICKSTOP(bool[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : BtoB(y[iv]);
        } : foldfix( andBBB, ItoB(1), ItoB(0));
  return(z);
}


inline bool[.] maxsl1XBBQUICKSTOP(bool[.,.] y)
{ /* first-axis reduce rank-2 matrix with quickstop */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : maxslXBBQUICKSTOP(yt[iv]);
        } : genarray(zrho, false);
  return(z);
}





inline bool[.] minsl1XBBQUICKSTOP(bool[.,.] y)
{ /* first-axis reduce rank-2 matrix with quickstop */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : minslXBBQUICKSTOP(yt[iv]);
        } : genarray(zrho, false);
  return(z);
}





inline bool modXBB(bool y)
{ /* Absolute value Boolean (NOP) */
 return(toB(y));
}

inline bool eqCCB(char x, char y)
{ /* A=B on non-doubles */
 return(CtoC(x) == CtoC(y));
}

inline int maxIII(int x, int y)
{ /* x max y */
 return (max(ItoI(x),ItoI(y)));
}

inline bool geIIB(int x, int y)
{ /* A>=B on non-Doubles */
 return(ItoI(x) >= ItoI(y));
}

inline bool mpyBBB(bool x, bool y)
{ return(BtoB(x) & BtoB(y));
}

inline int plusIBI(int x, bool y)
{ return(ItoI(x)+BtoI(y));
}

inline bool[+] geIIB(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : geIIB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] geIIB(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : geIIB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] mpyBBB(bool x, bool[+] y)
{ /* SxA scalar function */
  xel = toB(x);
  z = with {
     ( . <= iv <= .) {
              yel = toB(y[iv]);
                    } : mpyBBB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] mpyBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : mpyBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[+] plusIBI(int x, bool[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] eqCCB(char[+] x, char[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : eqCCB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline bool[+] eqIIB(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : eqIIB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline int[+] mpyIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : mpyIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[.] comaXBB(bool[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline int[*] indrfr(int fr, int[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline int[*] indrfr0(int[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline int[*] indrfr(int fr, int[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,0);
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline char[*] indrfr(int fr, char[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline char[*] indrfr0(char[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline char[*] indrfr(int fr, char[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,' ');
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline bool[*] indrfr(int fr, bool[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, false);
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline bool[*] indrfr0(bool[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, false);
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline bool[*] indrfr(int fr, bool[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,false);
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline int DFLOOR(double y, double QUADct)
{ /* Fuzzy floor */
  /* Definition taken from SHARP APL Refman May 1991, p.6-23
   * floor:  n <- (signum y) times nofuzzfloor 0.5+abs y)
   *         z <- n-(QUADct times 1 max abs y)<(n-y)
   * If you want a double result,  write: "y - 1| y".
   */
   n = tod(floor(0.5+fabs(y)));
   if (y < 0.0)
        n = -n;
   else if (0.0 == y)
        n = 0.0;
   range = fabs(y);
   if (1.0 > range)
        range = 1.0;
   fuzzlim = QUADct*range;
   ny = n-y;
   if (fuzzlim < ny)
        z = n - 1.0;
   else
        z = n;
   return(toi(z));
}

inline int V2O( int[.] shp, int[.] iv)
{ /* Vector iv to offset into array of shape shp */
  /* See V2O.dws workspace */
  offset = 0;
  wt = 1;
  for( i=shape(shp)[0]-1; i>=0; i--) {
    offset = offset + ( wt * iv[i]);
    wt = wt * shp[i];
  }
  return( offset);
}

inline int[.] O2V( int[.] shp, int offset)
{ /* Offset into array of shape shp to index vector */
  /* See V2O.dws workspace */
  iv = genarray( shape(shp), 1);
  wts = iv;
  for( i=shape(shp)[0]-2; i>=0; i--) {
    wts[i] = wts[i+1] * shp[i+1];
  }

  for( i=shape(shp)[0]-1; i>=0; i--) {
    iv[i] = _mod_SxS_( offset/wts[i], shp[i]);
    offset = offset - (iv[i]*wts[i]);
  }
  return( iv);
}

inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

inline int ABC(int I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[scalarI] & indexed assign */
 z = I;
 return(z);
}

inline int[+] ABC(int[+] I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[nonscalarI] & indexed assign */
 z = I;
 return(z);
}

inline int[+] TRANSPOSE(int[+] y)
{ /* Generic monadic transpose */
  z = with {
        ( . <= iv <= .)
                : y[reverse( iv)];
        }: genarray( reverse( shape(y)), 0);
  return(z);
}

inline bool[+] TRANSPOSE(bool[+] y)
{ /* Generic monadic transpose */
  z = with {
        ( . <= iv <= .)
                : y[reverse( iv)];
        }: genarray( reverse( shape(y)), false);
  return(z);
}

inline int plusslXBIFOLD(bool[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : BtoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline int maxslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( maxIII, ItoI(minint()));
  return(z);
}


inline int minslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( minIII, ItoI(maxint()));
  return(z);
}


inline bool maxslXBBQUICKSTOP(bool[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : BtoB(y[iv]);
        } : foldfix( maxBBB, ItoB(0), ItoB(1));
  return(z);
}


inline bool minslXBBQUICKSTOP(bool[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : BtoB(y[iv]);
        } : foldfix( minBBB, ItoB(1), ItoB(0));
  return(z);
}


inline bool eqIIB(int x, int y)
{ /* A=B on non-doubles */
 return(ItoI(x) == ItoI(y));
}

inline int minIII(int x, int y)
{ /* x min y */
 return (min(ItoI(x),ItoI(y)));
}

inline bool maxBBB(bool x, bool y)
{ return (x&y);
}

inline bool minBBB(bool x, bool y)
{ return (x&y);
}

inline bool[+] eqCCB(char x, char[+] y)
{ /* SxA scalar function */
  xel = toC(x);
  z = with {
     ( . <= iv <= .) {
              yel = toC(y[iv]);
                    } : eqCCB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] eqIIB(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : eqIIB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] eqIIB(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : eqIIB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline char[.] DthornIntIIC(int[.] wp, int y ,int QUADio)
{ 
/*
 ?
*/
A_73= ABC(toi(false)-QUADio,shape(wp)[0]);
A_75=wp[[A_73]];
 w_0=( A_75);
 A_77= ABC(toi(true)-QUADio,shape(wp)[0]);
A_79=wp[[A_77]];
 p_0=( A_79);
 QUADct_0=toD(( false));
 A_82=rhoICC(w_0,' ');
 r_0=( A_82);
 /* dsf scalar(s) */
A_84=barIBI(w_0,true);
 A_85= ABC(toi(A_84)-QUADio,shape(r_0)[0]);
A_87=inds0(r_0,A_85,'0');
 r_1=( A_87);
 /* dsf scalar(s) */
A_90=ltIBB(y,false);
 sig_0=( A_90);
 A_92= ABC(toi(sig_0)-QUADio,shape([-1, 1])[0]);
A_94=[-1, 1][[A_92]];
 /* dsf scalar(s) */
A_95=mpyIII(y,A_94);
 cury_0=( A_95);
 ld_0=( false);
 digits_0=( ['0','1','2','3','4','5','6','7','8','9']);
 A_100=iotaXII( w_0,QUADio);
 A_101=rotrXII( A_100);
 A_CTR102_= 0;
A_CTR102z_ = (shape(A_101)[[0]])-1;
r_3=toC(r_1);
ld_2=toI(ld_0);
cury_2=toI(cury_0);
digits_2=toC(digits_0);
for(; A_CTR102_ <= A_CTR102z_; A_CTR102_++){
i_0 = A_101[[A_CTR102_]];
 /* dsf scalar(s) */
A_107=divIID(cury_2,10);
 A_109=maxXDI( A_107,QUADct_0);
 nexty_0=( A_109);
 /* dsf scalar(s) */
A_112=neIBB(cury_2,false);
 /* dsf scalar(s) */
A_114=barIBI(i_0,true);
 A_115=comaIII(ld_2,A_114);
 A_113= ABC(toi(A_112)-QUADio,shape(A_115)[0]);
A_117=A_115[[A_113]];
 ld_2=( A_117);
 /* dsf scalar(s) */
A_119=mpyIII(nexty_0,10);
 /* dsf Scalar & clique */
A_120=barIII(cury_2,A_119);
 A_121=modXII( A_120);
 dig_0=( A_121);
 A_123= ABC(toi(dig_0)-QUADio,shape(digits_2)[0]);
A_125=digits_2[[A_123]];
 A_126= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_128=inds0(r_3,A_126,A_125);
 r_3=( A_128);
 cury_2=( nexty_0);
 /* dsf scalar(s) */
A_132=eqIBB(nexty_0,false);
 A_134= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_136=digits_2[[A_134]];
 A_137=comaCCC(A_136,' ');
 A_133= ABC(toi(A_132)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_133]];
 A_140= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_142=inds0(digits_2,A_140,A_139);
 digits_2=( A_142);
 }
 /* dsf scalar(s) */
A_145=maxBII(false,ld_2);
 ld_3=( A_145);
 A_148= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_150=r_3[[A_148]];
 A_151=comaCCC(A_150,'-');
 A_147= ABC(toi(sig_0)-QUADio,shape(A_151)[0]);
A_153=A_151[[A_147]];
 A_154= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_156=inds0(r_3,A_154,A_153);
 r_4=( A_156);
 A_158=rhoXCI( r_4);
 /* dsf scalar(s) */
A_160=neIBB(cury_2,false);
 /* dsf scalar(s) */
A_161=mpyBII(A_160,A_158);
 A_163=iotaXII( A_161,QUADio);
 A_164= ABC(toi(A_163)-QUADio,shape(r_4)[0]);
A_166=inds1(r_4,A_164,'*');
 r_5=( A_166);
 return(r_5);
}

inline int[.] PmtlXII(int[.] y )
{ 
/*
 ?
*/
A_24=rhoIII(9,10);
 A_25=comaBII(true,A_24);
 A_26=mpybslXII( A_25);
 Pten_0=( A_26);
 A_31=jotdotgeIIB(y,Pten_0);
 A_39=plusslXBIFOLD( A_31);
 r_0=( A_39);
 return(r_0);
}

inline bool matchnegCCB(char[.] x, char[.] y,int QUADio)
{ 
/*
 ?
*/
A_28=comaXCC( x);
 rx_0=( A_28);
 A_30=rhoXCI( rx_0);
 A_32=iotaXII( A_30,QUADio);
 /* dsf scalar(s) */
A_34=eqCCB(rx_0,'\x2d');
 A_35=slBII(A_34,A_32);
 A_36= ABC(toi(A_35)-QUADio,shape(rx_0)[0]);
A_38=inds1(rx_0,A_36,'-');
rx_1=( A_38);
 A_40=comaXCC( y);
 ry_0=( A_40);
 A_42=rhoXCI( ry_0);
 A_44=iotaXII( A_42,QUADio);
 /* dsf scalar(s) */
A_46=eqCCB(ry_0,'\x2d');
 A_47=slBII(A_46,A_44);
 A_48= ABC(toi(A_47)-QUADio,shape(ry_0)[0]);
A_50=inds1(ry_0,A_48,'-');
ry_1=( A_50);
 A_53=sameCCB(rx_1,ry_1);
 A_54=rhoXCI( y);
 A_55=rhoXCI( x);
 A_57=sameIIB(A_55,A_54);
 /* dsf scalar(s) */
A_58=andBBB(A_57,A_53);
 r_0=( A_58);
 return(r_0);
}

inline char[.] thintIIC(int PP, int y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_67=slBII(true,y);
 y_0=( A_67);
 A_69=rhoXII( y_0);
 A_70=takeIII(-1,A_69);
 A_71=rhoXII( y_0);
 A_72=dropIII(-1,A_71);
 A_73=mpyslXIIQUICKSTOP( A_72);
 A_77=comaIII(A_73,A_70);
 A_78=rhoIII(A_77,y_0);
 m_0=( A_78);
 A_80=modXII( m_0);
 A_81=maxsl1XIIFOLD( A_80);
 /* dsf scalar(s) */
A_85=maxIII(2,A_81);
 A_86=PmtlXII( A_85);
 widths_0=( A_86);
 A_88=minsl1XIIFOLD( m_0);
 maxneg_0=( A_88);
 /* dsf scalar(s) */
A_94=ltIBB(maxneg_0,false);
 neg_0=( A_94);
 A_96=modXII( maxneg_0);
 /* dsf scalar(s) */
A_97=maxIII(2,A_96);
 A_98=PmtlXII( A_97);
 maxneg_1=( A_98);
 /* dsf clique */
A_101=geIIB(maxneg_1,widths_0);
 /* dsf Check needed */
A_102=mpyBBB(neg_0,A_101);
 /* dsf Check needed */
A_103=plusIBI(widths_0,A_102);
 widths_1=( A_103);
 A_105=rhoXII( y_0);
 A_106=rhoIII(A_105,widths_1);
 A_107=comaXII( A_106);
 w_0=( A_107);
 /* dsf scalar(s) */
A_109=plusIBI(widths_1,true);
 A_110=comaBII(false,A_109);
 A_111=plusbslXII( A_110);
 psw_0=( A_111);
 /* dsf scalar(s) */
A_116=plusIBI(widths_1,true);
 A_117=plusslXIIFOLD( A_116);
 /* dsf scalar(s) */
A_121=plusIII(-1,A_117);
 A_123=rhoXII( m_0);
 A_122= ABC(toi(false)-QUADio,shape(A_123)[0]);
A_125=A_123[[A_122]];
 A_126=comaIII(A_125,A_121);
 shpz_0=( A_126);
 A_128=rhoICC(shpz_0,' ');
 r_0=( A_128);
 A_131=rhoXII( m_0);
 A_130= ABC(toi(false)-QUADio,shape(A_131)[0]);
A_133=A_131[[A_130]];
 A_135=iotaXII( A_133,QUADio);
 A_CTR136_= 0;
A_CTR136z_ = (shape(A_135)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR136_ <= A_CTR136z_; A_CTR136_++){
i_0 = A_135[[A_CTR136_]];
 A_139=rhoXII( m_0);
 A_138= ABC(toi(true)-QUADio,shape(A_139)[0]);
A_141=A_139[[A_138]];
 A_143=iotaXII( A_141,QUADio);
 A_CTR144_= 0;
A_CTR144z_ = (shape(A_143)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR144_ <= A_CTR144z_; A_CTR144_++){
j_0 = A_143[[A_CTR144_]];
 A_147= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_146= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_149=m_0[[A_147,A_146]];
 A_150= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_152=w_0[[A_150]];
 A_153=comaIBI(A_152,false);
 A_155=DthornIntIIC(A_153,A_149,QUADio);
 A_156= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_158=w_0[[A_156]];
 A_160=iotaXII( A_158,QUADio);
 A_161= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_163=psw_0[[A_161]];
 /* dsf scalar(s) */
A_164=plusIII(A_163,A_160);
 A_166= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_165= ABC(toi(A_164)-QUADio,shape(r_3)[1]);
A_168=inds01(r_3,A_166,A_165,A_155);
 r_3=( A_168);
 }
 }
 A_172=rhoXCI( r_3);
 A_173=takeIII(-1,A_172);
 A_174=rhoXII( y_0);
 A_175=dropIII(-1,A_174);
 A_176=comaIII(A_175,A_173);
 A_177=rhoICC(A_176,r_3);
 r_4=( A_177);
 return(r_4);
}

inline bool[.] testthornXIB(int PP,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_68=thrnXIC( 2,QUADpp_0);
 A_70=thintIIC(QUADpp_0,2,QUADio);
 A_72=matchnegCCB(A_70,A_68,QUADio);
 r_0=( A_72);
 A_75=thrnXIC( -2,QUADpp_0);
 A_77=thintIIC(QUADpp_0,-2,QUADio);
 A_79=matchnegCCB(A_77,A_75,QUADio);
 A_80=comaBBB(r_0,A_79);
 r_1=( A_80);
 A_83=thrnXBC( false,QUADpp_0);
 A_85=thintCLONE6IBC(QUADpp_0,false,QUADio);
 A_87=matchnegCCB(A_85,A_83,QUADio);
 A_88=comaBBB(r_1,A_87);
 r_2=( A_88);
 A_90=comaXII( -13);
 A_92=thrnXIC( A_90,QUADpp_0);
 A_93=comaXII( -13);
 A_95=thintCLONE7IIC(QUADpp_0,A_93,QUADio);
 A_97=matchnegCCB(A_95,A_92,QUADio);
 A_98=comaBBB(r_2,A_97);
 r_3=( A_98);
 A_101=iotaXII( 4,QUADio);
 A_102=jotdotmpyIII([10, 199],A_101);
 A_109=rhoIII([2, 4],A_102);
 m_0=( A_109);
 A_112=thrnXIC( A_109,QUADpp_0);
 A_114=thintCLONE8IIC(QUADpp_0,m_0,QUADio);
 A_116=matchnegCLONE9CCB(A_114,A_112,QUADio);
 A_117=comaBBB(r_3,A_116);
 r_4=( A_117);
 A_120=thrnXIC( -123,QUADpp_0);
 A_122=thintIIC(QUADpp_0,-123,QUADio);
 A_124=matchnegCCB(A_122,A_120,QUADio);
 A_125=comaBBB(r_4,A_124);
 r_5=( A_125);
 twop31m1_0=( 2147483647);
 A_129=thrnXIC( twop31m1_0,QUADpp_0);
 A_131=thintIIC(QUADpp_0,twop31m1_0,QUADio);
 A_133=matchnegCCB(A_131,A_129,QUADio);
 A_134=comaBBB(r_5,A_133);
 r_6=( A_134);
 A_137=iotaXII( 10,QUADio);
 /* dsf scalar(s) */
A_138=plusIII(-2,A_137);
 A_140=thrnXIC( A_138,QUADpp_0);
 A_142=iotaXII( 10,QUADio);
 /* dsf scalar(s) */
A_143=plusIII(-2,A_142);
 A_145=thintCLONE10IIC(QUADpp_0,A_143,QUADio);
 A_147=matchnegCCB(A_145,A_140,QUADio);
 A_148=comaBBB(r_6,A_147);
 r_7=( A_148);
 A_151=iotaXII( 999,QUADio);
 /* dsf scalar(s) */
A_152=plusIII(-20,A_151);
 A_153=rhoIII([2, 3, 4, 5],A_152);
 m_1=( A_153);
 A_156=thrnXIC( m_1,QUADpp_0);
 A_158=thintCLONE11IIC(QUADpp_0,m_1,QUADio);
 A_160=matchnegCLONE12CCB(A_158,A_156,QUADio);
 A_161=comaBBB(r_7,A_160);
 r_8=( A_161);
 A_163= ABC(toi(false)-QUADio,shape(m_1)[3]);
A_168=indsxxx0(m_1,A_163,1000000000);
m_2=( A_168);
 A_171=thrnXIC( m_2,QUADpp_0);
 A_173=thintCLONE13IIC(QUADpp_0,m_2,QUADio);
 A_175=matchnegCLONE14CCB(A_173,A_171,QUADio);
 A_176=comaBBB(r_8,A_175);
 r_9=( A_176);
 return(r_9);
}

int main()
{ 
/*
 ?
*/
QUADio_0=toI(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 QUADio_1=toI(( false));
 QUADrl_1=( 16807);
 QUADpp_1=( 16);
 QUADpw_1=( 80);
 A_54=testthornXIB( QUADpp_1,QUADio_1);
 r_0=( A_54);
 A_58=quadXBB( A_54,QUADpp_1,QUADpw_1);
 A_60=testthornXIB( 5,QUADio_1);
 A_61=comaBBB(r_0,A_60);
 r_1=( A_61);
 A_65=quadXBB( A_61,QUADpp_1,QUADpw_1);
 A_66=andslXBBQUICKSTOP( r_1);
 /* dsf scalar(s) */
A_70=barBBI(true,A_66);
r_2=( A_70);
 A_74=quadXII( r_2,QUADpp_1,QUADpw_1);
 return(r_2);
}

inline char[.] thintCLONE6IBC(int PP, bool y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_68=slBBB(true,y);
 y_0=( A_68);
 A_70=rhoXBI( y_0);
 A_71=takeIII(-1,A_70);
 A_72=rhoXBI( y_0);
 A_73=dropIII(-1,A_72);
 A_74=mpyslXIIQUICKSTOP( A_73);
 A_78=comaIII(A_74,A_71);
 A_79=rhoIBB(A_78,y_0);
 m_0=( A_79);
 A_81=modXBB( m_0);
 A_82=maxsl1XBBQUICKSTOP( A_81);
 /* dsf scalar(s) */
A_86=maxIBI(2,A_82);
 A_87=PmtlXII( A_86);
 widths_0=( A_87);
 A_89=minsl1XBBQUICKSTOP( m_0);
 maxneg_0=( A_89);
 /* dsf scalar(s) */
A_95=ltBBB(maxneg_0,false);
 neg_0=( A_95);
 A_97=modXBB( maxneg_0);
 /* dsf scalar(s) */
A_98=maxIBI(2,A_97);
 A_99=PmtlXII( A_98);
 maxneg_1=( A_99);
 /* dsf clique */
A_102=geIIB(maxneg_1,widths_0);
 /* dsf Check needed */
A_103=mpyBBB(neg_0,A_102);
 /* dsf Check needed */
A_104=plusIBI(widths_0,A_103);
 widths_1=( A_104);
 A_106=rhoXBI( y_0);
 A_107=rhoIII(A_106,widths_1);
 A_108=comaXII( A_107);
 w_0=( A_108);
 /* dsf scalar(s) */
A_110=plusIBI(widths_1,true);
 A_111=comaBII(false,A_110);
 A_112=plusbslXII( A_111);
 psw_0=( A_112);
 /* dsf scalar(s) */
A_117=plusIBI(widths_1,true);
 A_118=plusslXIIFOLD( A_117);
 /* dsf scalar(s) */
A_122=plusIII(-1,A_118);
 A_124=rhoXBI( m_0);
 A_123= ABC(toi(false)-QUADio,shape(A_124)[0]);
A_126=A_124[[A_123]];
 A_127=comaIII(A_126,A_122);
 shpz_0=( A_127);
 A_129=rhoICC(shpz_0,' ');
 r_0=( A_129);
 A_132=rhoXBI( m_0);
 A_131= ABC(toi(false)-QUADio,shape(A_132)[0]);
A_134=A_132[[A_131]];
 A_136=iotaXII( A_134,QUADio);
 A_CTR137_= 0;
A_CTR137z_ = (shape(A_136)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR137_ <= A_CTR137z_; A_CTR137_++){
i_0 = A_136[[A_CTR137_]];
 A_140=rhoXBI( m_0);
 A_139= ABC(toi(true)-QUADio,shape(A_140)[0]);
A_142=A_140[[A_139]];
 A_144=iotaXII( A_142,QUADio);
 A_CTR145_= 0;
A_CTR145z_ = (shape(A_144)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR145_ <= A_CTR145z_; A_CTR145_++){
j_0 = A_144[[A_CTR145_]];
 A_148= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_147= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_150=m_0[[A_148,A_147]];
 A_151= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_153=w_0[[A_151]];
 A_154=comaIBI(A_153,false);
 A_156=DthornIntCLONE15IBC(A_154,A_150,QUADio);
 A_157= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_159=w_0[[A_157]];
 A_161=iotaXII( A_159,QUADio);
 A_162= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_164=psw_0[[A_162]];
 /* dsf scalar(s) */
A_165=plusIII(A_164,A_161);
 A_167= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_166= ABC(toi(A_165)-QUADio,shape(r_3)[1]);
A_169=inds01(r_3,A_167,A_166,A_156);
 r_3=( A_169);
 }
 }
 A_173=rhoXCI( r_3);
 A_174=takeIII(-1,A_173);
 A_175=rhoXBI( y_0);
 A_176=dropIII(-1,A_175);
 A_177=comaIII(A_176,A_174);
 A_178=rhoICC(A_177,r_3);
 r_4=( A_178);
 return(r_4);
}

inline char[.] thintCLONE7IIC(int PP, int[.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_67=slBII(true,y);
 y_0=( A_67);
 A_69=rhoXII( y_0);
 A_70=takeIII(-1,A_69);
 A_71=rhoXII( y_0);
 A_72=dropIII(-1,A_71);
 A_73=mpyslXIIQUICKSTOP( A_72);
 A_77=comaIII(A_73,A_70);
 A_78=rhoIII(A_77,y_0);
 m_0=( A_78);
 A_80=modXII( m_0);
 A_81=maxsl1XIIFOLD( A_80);
 /* dsf scalar(s) */
A_85=maxIII(2,A_81);
 A_86=PmtlXII( A_85);
 widths_0=( A_86);
 A_88=minsl1XIIFOLD( m_0);
 maxneg_0=( A_88);
 /* dsf scalar(s) */
A_94=ltIBB(maxneg_0,false);
 neg_0=( A_94);
 A_96=modXII( maxneg_0);
 /* dsf scalar(s) */
A_97=maxIII(2,A_96);
 A_98=PmtlXII( A_97);
 maxneg_1=( A_98);
 /* dsf clique */
A_101=geIIB(maxneg_1,widths_0);
 /* dsf Check needed */
A_102=mpyBBB(neg_0,A_101);
 /* dsf Check needed */
A_103=plusIBI(widths_0,A_102);
 widths_1=( A_103);
 A_105=rhoXII( y_0);
 A_106=rhoIII(A_105,widths_1);
 A_107=comaXII( A_106);
 w_0=( A_107);
 /* dsf scalar(s) */
A_109=plusIBI(widths_1,true);
 A_110=comaBII(false,A_109);
 A_111=plusbslXII( A_110);
 psw_0=( A_111);
 /* dsf scalar(s) */
A_116=plusIBI(widths_1,true);
 A_117=plusslXIIFOLD( A_116);
 /* dsf scalar(s) */
A_121=plusIII(-1,A_117);
 A_123=rhoXII( m_0);
 A_122= ABC(toi(false)-QUADio,shape(A_123)[0]);
A_125=A_123[[A_122]];
 A_126=comaIII(A_125,A_121);
 shpz_0=( A_126);
 A_128=rhoICC(shpz_0,' ');
 r_0=( A_128);
 A_131=rhoXII( m_0);
 A_130= ABC(toi(false)-QUADio,shape(A_131)[0]);
A_133=A_131[[A_130]];
 A_135=iotaXII( A_133,QUADio);
 A_CTR136_= 0;
A_CTR136z_ = (shape(A_135)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR136_ <= A_CTR136z_; A_CTR136_++){
i_0 = A_135[[A_CTR136_]];
 A_139=rhoXII( m_0);
 A_138= ABC(toi(true)-QUADio,shape(A_139)[0]);
A_141=A_139[[A_138]];
 A_143=iotaXII( A_141,QUADio);
 A_CTR144_= 0;
A_CTR144z_ = (shape(A_143)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR144_ <= A_CTR144z_; A_CTR144_++){
j_0 = A_143[[A_CTR144_]];
 A_147= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_146= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_149=m_0[[A_147,A_146]];
 A_150= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_152=w_0[[A_150]];
 A_153=comaIBI(A_152,false);
 A_155=DthornIntIIC(A_153,A_149,QUADio);
 A_156= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_158=w_0[[A_156]];
 A_160=iotaXII( A_158,QUADio);
 A_161= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_163=psw_0[[A_161]];
 /* dsf scalar(s) */
A_164=plusIII(A_163,A_160);
 A_166= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_165= ABC(toi(A_164)-QUADio,shape(r_3)[1]);
A_168=inds01(r_3,A_166,A_165,A_155);
 r_3=( A_168);
 }
 }
 A_172=rhoXCI( r_3);
 A_173=takeIII(-1,A_172);
 A_174=rhoXII( y_0);
 A_175=dropIII(-1,A_174);
 A_176=comaIII(A_175,A_173);
 A_177=rhoICC(A_176,r_3);
 r_4=( A_177);
 return(r_4);
}

inline char[.,.] thintCLONE8IIC(int PP, int[.,.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_67=slBII(true,y);
 y_0=( A_67);
 A_69=rhoXII( y_0);
 A_70=takeIII(-1,A_69);
 A_71=rhoXII( y_0);
 A_72=dropIII(-1,A_71);
 A_73=mpyslXIIQUICKSTOP( A_72);
 A_77=comaIII(A_73,A_70);
 A_78=rhoIII(A_77,y_0);
 m_0=( A_78);
 A_80=modXII( m_0);
 A_81=maxsl1XIIFOLD( A_80);
 /* dsf scalar(s) */
A_85=maxIII(2,A_81);
 A_86=PmtlXII( A_85);
 widths_0=( A_86);
 A_88=minsl1XIIFOLD( m_0);
 maxneg_0=( A_88);
 /* dsf scalar(s) */
A_94=ltIBB(maxneg_0,false);
 neg_0=( A_94);
 A_96=modXII( maxneg_0);
 /* dsf scalar(s) */
A_97=maxIII(2,A_96);
 A_98=PmtlXII( A_97);
 maxneg_1=( A_98);
 /* dsf clique */
A_101=geIIB(maxneg_1,widths_0);
 /* dsf Check needed */
A_102=mpyBBB(neg_0,A_101);
 /* dsf Check needed */
A_103=plusIBI(widths_0,A_102);
 widths_1=( A_103);
 A_105=rhoXII( y_0);
 A_106=rhoIII(A_105,widths_1);
 A_107=comaXII( A_106);
 w_0=( A_107);
 /* dsf scalar(s) */
A_109=plusIBI(widths_1,true);
 A_110=comaBII(false,A_109);
 A_111=plusbslXII( A_110);
 psw_0=( A_111);
 /* dsf scalar(s) */
A_116=plusIBI(widths_1,true);
 A_117=plusslXIIFOLD( A_116);
 /* dsf scalar(s) */
A_121=plusIII(-1,A_117);
 A_123=rhoXII( m_0);
 A_122= ABC(toi(false)-QUADio,shape(A_123)[0]);
A_125=A_123[[A_122]];
 A_126=comaIII(A_125,A_121);
 shpz_0=( A_126);
 A_128=rhoICC(shpz_0,' ');
 r_0=( A_128);
 A_131=rhoXII( m_0);
 A_130= ABC(toi(false)-QUADio,shape(A_131)[0]);
A_133=A_131[[A_130]];
 A_135=iotaXII( A_133,QUADio);
 A_CTR136_= 0;
A_CTR136z_ = (shape(A_135)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR136_ <= A_CTR136z_; A_CTR136_++){
i_0 = A_135[[A_CTR136_]];
 A_139=rhoXII( m_0);
 A_138= ABC(toi(true)-QUADio,shape(A_139)[0]);
A_141=A_139[[A_138]];
 A_143=iotaXII( A_141,QUADio);
 A_CTR144_= 0;
A_CTR144z_ = (shape(A_143)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR144_ <= A_CTR144z_; A_CTR144_++){
j_0 = A_143[[A_CTR144_]];
 A_147= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_146= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_149=m_0[[A_147,A_146]];
 A_150= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_152=w_0[[A_150]];
 A_153=comaIBI(A_152,false);
 A_155=DthornIntIIC(A_153,A_149,QUADio);
 A_156= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_158=w_0[[A_156]];
 A_160=iotaXII( A_158,QUADio);
 A_161= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_163=psw_0[[A_161]];
 /* dsf scalar(s) */
A_164=plusIII(A_163,A_160);
 A_166= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_165= ABC(toi(A_164)-QUADio,shape(r_3)[1]);
A_168=inds01(r_3,A_166,A_165,A_155);
 r_3=( A_168);
 }
 }
 A_172=rhoXCI( r_3);
 A_173=takeIII(-1,A_172);
 A_174=rhoXII( y_0);
 A_175=dropIII(-1,A_174);
 A_176=comaIII(A_175,A_173);
 A_177=rhoICC(A_176,r_3);
 r_4=( A_177);
 return(r_4);
}

inline bool matchnegCLONE9CCB(char[.,.] x, char[.,.] y,int QUADio)
{ 
/*
 ?
*/
A_28=comaXCC( x);
 rx_0=( A_28);
 A_30=rhoXCI( rx_0);
 A_32=iotaXII( A_30,QUADio);
 /* dsf scalar(s) */
A_34=eqCCB(rx_0,'\x2d');
 A_35=slBII(A_34,A_32);
 A_36= ABC(toi(A_35)-QUADio,shape(rx_0)[0]);
A_38=inds1(rx_0,A_36,'-');
rx_1=( A_38);
 A_40=comaXCC( y);
 ry_0=( A_40);
 A_42=rhoXCI( ry_0);
 A_44=iotaXII( A_42,QUADio);
 /* dsf scalar(s) */
A_46=eqCCB(ry_0,'\x2d');
 A_47=slBII(A_46,A_44);
 A_48= ABC(toi(A_47)-QUADio,shape(ry_0)[0]);
A_50=inds1(ry_0,A_48,'-');
ry_1=( A_50);
 A_53=sameCCB(rx_1,ry_1);
 A_54=rhoXCI( y);
 A_55=rhoXCI( x);
 A_57=sameIIB(A_55,A_54);
 /* dsf scalar(s) */
A_58=andBBB(A_57,A_53);
 r_0=( A_58);
 return(r_0);
}

inline char[.] thintCLONE10IIC(int PP, int[.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_67=slBII(true,y);
 y_0=( A_67);
 A_69=rhoXII( y_0);
 A_70=takeIII(-1,A_69);
 A_71=rhoXII( y_0);
 A_72=dropIII(-1,A_71);
 A_73=mpyslXIIQUICKSTOP( A_72);
 A_77=comaIII(A_73,A_70);
 A_78=rhoIII(A_77,y_0);
 m_0=( A_78);
 A_80=modXII( m_0);
 A_81=maxsl1XIIFOLD( A_80);
 /* dsf scalar(s) */
A_85=maxIII(2,A_81);
 A_86=PmtlXII( A_85);
 widths_0=( A_86);
 A_88=minsl1XIIFOLD( m_0);
 maxneg_0=( A_88);
 /* dsf scalar(s) */
A_94=ltIBB(maxneg_0,false);
 neg_0=( A_94);
 A_96=modXII( maxneg_0);
 /* dsf scalar(s) */
A_97=maxIII(2,A_96);
 A_98=PmtlXII( A_97);
 maxneg_1=( A_98);
 /* dsf clique */
A_101=geIIB(maxneg_1,widths_0);
 /* dsf Check needed */
A_102=mpyBBB(neg_0,A_101);
 /* dsf Check needed */
A_103=plusIBI(widths_0,A_102);
 widths_1=( A_103);
 A_105=rhoXII( y_0);
 A_106=rhoIII(A_105,widths_1);
 A_107=comaXII( A_106);
 w_0=( A_107);
 /* dsf scalar(s) */
A_109=plusIBI(widths_1,true);
 A_110=comaBII(false,A_109);
 A_111=plusbslXII( A_110);
 psw_0=( A_111);
 /* dsf scalar(s) */
A_116=plusIBI(widths_1,true);
 A_117=plusslXIIFOLD( A_116);
 /* dsf scalar(s) */
A_121=plusIII(-1,A_117);
 A_123=rhoXII( m_0);
 A_122= ABC(toi(false)-QUADio,shape(A_123)[0]);
A_125=A_123[[A_122]];
 A_126=comaIII(A_125,A_121);
 shpz_0=( A_126);
 A_128=rhoICC(shpz_0,' ');
 r_0=( A_128);
 A_131=rhoXII( m_0);
 A_130= ABC(toi(false)-QUADio,shape(A_131)[0]);
A_133=A_131[[A_130]];
 A_135=iotaXII( A_133,QUADio);
 A_CTR136_= 0;
A_CTR136z_ = (shape(A_135)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR136_ <= A_CTR136z_; A_CTR136_++){
i_0 = A_135[[A_CTR136_]];
 A_139=rhoXII( m_0);
 A_138= ABC(toi(true)-QUADio,shape(A_139)[0]);
A_141=A_139[[A_138]];
 A_143=iotaXII( A_141,QUADio);
 A_CTR144_= 0;
A_CTR144z_ = (shape(A_143)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR144_ <= A_CTR144z_; A_CTR144_++){
j_0 = A_143[[A_CTR144_]];
 A_147= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_146= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_149=m_0[[A_147,A_146]];
 A_150= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_152=w_0[[A_150]];
 A_153=comaIBI(A_152,false);
 A_155=DthornIntIIC(A_153,A_149,QUADio);
 A_156= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_158=w_0[[A_156]];
 A_160=iotaXII( A_158,QUADio);
 A_161= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_163=psw_0[[A_161]];
 /* dsf scalar(s) */
A_164=plusIII(A_163,A_160);
 A_166= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_165= ABC(toi(A_164)-QUADio,shape(r_3)[1]);
A_168=inds01(r_3,A_166,A_165,A_155);
 r_3=( A_168);
 }
 }
 A_172=rhoXCI( r_3);
 A_173=takeIII(-1,A_172);
 A_174=rhoXII( y_0);
 A_175=dropIII(-1,A_174);
 A_176=comaIII(A_175,A_173);
 A_177=rhoICC(A_176,r_3);
 r_4=( A_177);
 return(r_4);
}

inline char[.,.,.,.] thintCLONE11IIC(int PP, int[.,.,.,.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_67=slBII(true,y);
 y_0=( A_67);
 A_69=rhoXII( y_0);
 A_70=takeIII(-1,A_69);
 A_71=rhoXII( y_0);
 A_72=dropIII(-1,A_71);
 A_73=mpyslXIIQUICKSTOP( A_72);
 A_77=comaIII(A_73,A_70);
 A_78=rhoIII(A_77,y_0);
 m_0=( A_78);
 A_80=modXII( m_0);
 A_81=maxsl1XIIFOLD( A_80);
 /* dsf scalar(s) */
A_85=maxIII(2,A_81);
 A_86=PmtlXII( A_85);
 widths_0=( A_86);
 A_88=minsl1XIIFOLD( m_0);
 maxneg_0=( A_88);
 /* dsf scalar(s) */
A_94=ltIBB(maxneg_0,false);
 neg_0=( A_94);
 A_96=modXII( maxneg_0);
 /* dsf scalar(s) */
A_97=maxIII(2,A_96);
 A_98=PmtlXII( A_97);
 maxneg_1=( A_98);
 /* dsf clique */
A_101=geIIB(maxneg_1,widths_0);
 /* dsf Check needed */
A_102=mpyBBB(neg_0,A_101);
 /* dsf Check needed */
A_103=plusIBI(widths_0,A_102);
 widths_1=( A_103);
 A_105=rhoXII( y_0);
 A_106=rhoIII(A_105,widths_1);
 A_107=comaXII( A_106);
 w_0=( A_107);
 /* dsf scalar(s) */
A_109=plusIBI(widths_1,true);
 A_110=comaBII(false,A_109);
 A_111=plusbslXII( A_110);
 psw_0=( A_111);
 /* dsf scalar(s) */
A_116=plusIBI(widths_1,true);
 A_117=plusslXIIFOLD( A_116);
 /* dsf scalar(s) */
A_121=plusIII(-1,A_117);
 A_123=rhoXII( m_0);
 A_122= ABC(toi(false)-QUADio,shape(A_123)[0]);
A_125=A_123[[A_122]];
 A_126=comaIII(A_125,A_121);
 shpz_0=( A_126);
 A_128=rhoICC(shpz_0,' ');
 r_0=( A_128);
 A_131=rhoXII( m_0);
 A_130= ABC(toi(false)-QUADio,shape(A_131)[0]);
A_133=A_131[[A_130]];
 A_135=iotaXII( A_133,QUADio);
 A_CTR136_= 0;
A_CTR136z_ = (shape(A_135)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR136_ <= A_CTR136z_; A_CTR136_++){
i_0 = A_135[[A_CTR136_]];
 A_139=rhoXII( m_0);
 A_138= ABC(toi(true)-QUADio,shape(A_139)[0]);
A_141=A_139[[A_138]];
 A_143=iotaXII( A_141,QUADio);
 A_CTR144_= 0;
A_CTR144z_ = (shape(A_143)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR144_ <= A_CTR144z_; A_CTR144_++){
j_0 = A_143[[A_CTR144_]];
 A_147= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_146= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_149=m_0[[A_147,A_146]];
 A_150= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_152=w_0[[A_150]];
 A_153=comaIBI(A_152,false);
 A_155=DthornIntIIC(A_153,A_149,QUADio);
 A_156= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_158=w_0[[A_156]];
 A_160=iotaXII( A_158,QUADio);
 A_161= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_163=psw_0[[A_161]];
 /* dsf scalar(s) */
A_164=plusIII(A_163,A_160);
 A_166= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_165= ABC(toi(A_164)-QUADio,shape(r_3)[1]);
A_168=inds01(r_3,A_166,A_165,A_155);
 r_3=( A_168);
 }
 }
 A_172=rhoXCI( r_3);
 A_173=takeIII(-1,A_172);
 A_174=rhoXII( y_0);
 A_175=dropIII(-1,A_174);
 A_176=comaIII(A_175,A_173);
 A_177=rhoICC(A_176,r_3);
 r_4=( A_177);
 return(r_4);
}

inline bool matchnegCLONE12CCB(char[.,.,.,.] x, char[.,.,.,.] y,int QUADio)
{ 
/*
 ?
*/
A_28=comaXCC( x);
 rx_0=( A_28);
 A_30=rhoXCI( rx_0);
 A_32=iotaXII( A_30,QUADio);
 /* dsf scalar(s) */
A_34=eqCCB(rx_0,'\x2d');
 A_35=slBII(A_34,A_32);
 A_36= ABC(toi(A_35)-QUADio,shape(rx_0)[0]);
A_38=inds1(rx_0,A_36,'-');
rx_1=( A_38);
 A_40=comaXCC( y);
 ry_0=( A_40);
 A_42=rhoXCI( ry_0);
 A_44=iotaXII( A_42,QUADio);
 /* dsf scalar(s) */
A_46=eqCCB(ry_0,'\x2d');
 A_47=slBII(A_46,A_44);
 A_48= ABC(toi(A_47)-QUADio,shape(ry_0)[0]);
A_50=inds1(ry_0,A_48,'-');
ry_1=( A_50);
 A_53=sameCCB(rx_1,ry_1);
 A_54=rhoXCI( y);
 A_55=rhoXCI( x);
 A_57=sameIIB(A_55,A_54);
 /* dsf scalar(s) */
A_58=andBBB(A_57,A_53);
 r_0=( A_58);
 return(r_0);
}

inline char[.,.,.,.] thintCLONE13IIC(int PP, int[.,.,.,.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_67=slBII(true,y);
 y_0=( A_67);
 A_69=rhoXII( y_0);
 A_70=takeIII(-1,A_69);
 A_71=rhoXII( y_0);
 A_72=dropIII(-1,A_71);
 A_73=mpyslXIIQUICKSTOP( A_72);
 A_77=comaIII(A_73,A_70);
 A_78=rhoIII(A_77,y_0);
 m_0=( A_78);
 A_80=modXII( m_0);
 A_81=maxsl1XIIFOLD( A_80);
 /* dsf scalar(s) */
A_85=maxIII(2,A_81);
 A_86=PmtlXII( A_85);
 widths_0=( A_86);
 A_88=minsl1XIIFOLD( m_0);
 maxneg_0=( A_88);
 /* dsf scalar(s) */
A_94=ltIBB(maxneg_0,false);
 neg_0=( A_94);
 A_96=modXII( maxneg_0);
 /* dsf scalar(s) */
A_97=maxIII(2,A_96);
 A_98=PmtlXII( A_97);
 maxneg_1=( A_98);
 /* dsf clique */
A_101=geIIB(maxneg_1,widths_0);
 /* dsf Check needed */
A_102=mpyBBB(neg_0,A_101);
 /* dsf Check needed */
A_103=plusIBI(widths_0,A_102);
 widths_1=( A_103);
 A_105=rhoXII( y_0);
 A_106=rhoIII(A_105,widths_1);
 A_107=comaXII( A_106);
 w_0=( A_107);
 /* dsf scalar(s) */
A_109=plusIBI(widths_1,true);
 A_110=comaBII(false,A_109);
 A_111=plusbslXII( A_110);
 psw_0=( A_111);
 /* dsf scalar(s) */
A_116=plusIBI(widths_1,true);
 A_117=plusslXIIFOLD( A_116);
 /* dsf scalar(s) */
A_121=plusIII(-1,A_117);
 A_123=rhoXII( m_0);
 A_122= ABC(toi(false)-QUADio,shape(A_123)[0]);
A_125=A_123[[A_122]];
 A_126=comaIII(A_125,A_121);
 shpz_0=( A_126);
 A_128=rhoICC(shpz_0,' ');
 r_0=( A_128);
 A_131=rhoXII( m_0);
 A_130= ABC(toi(false)-QUADio,shape(A_131)[0]);
A_133=A_131[[A_130]];
 A_135=iotaXII( A_133,QUADio);
 A_CTR136_= 0;
A_CTR136z_ = (shape(A_135)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR136_ <= A_CTR136z_; A_CTR136_++){
i_0 = A_135[[A_CTR136_]];
 A_139=rhoXII( m_0);
 A_138= ABC(toi(true)-QUADio,shape(A_139)[0]);
A_141=A_139[[A_138]];
 A_143=iotaXII( A_141,QUADio);
 A_CTR144_= 0;
A_CTR144z_ = (shape(A_143)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR144_ <= A_CTR144z_; A_CTR144_++){
j_0 = A_143[[A_CTR144_]];
 A_147= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_146= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_149=m_0[[A_147,A_146]];
 A_150= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_152=w_0[[A_150]];
 A_153=comaIBI(A_152,false);
 A_155=DthornIntIIC(A_153,A_149,QUADio);
 A_156= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_158=w_0[[A_156]];
 A_160=iotaXII( A_158,QUADio);
 A_161= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_163=psw_0[[A_161]];
 /* dsf scalar(s) */
A_164=plusIII(A_163,A_160);
 A_166= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_165= ABC(toi(A_164)-QUADio,shape(r_3)[1]);
A_168=inds01(r_3,A_166,A_165,A_155);
 r_3=( A_168);
 }
 }
 A_172=rhoXCI( r_3);
 A_173=takeIII(-1,A_172);
 A_174=rhoXII( y_0);
 A_175=dropIII(-1,A_174);
 A_176=comaIII(A_175,A_173);
 A_177=rhoICC(A_176,r_3);
 r_4=( A_177);
 return(r_4);
}

inline bool matchnegCLONE14CCB(char[.,.,.,.] x, char[.,.,.,.] y,int QUADio)
{ 
/*
 ?
*/
A_28=comaXCC( x);
 rx_0=( A_28);
 A_30=rhoXCI( rx_0);
 A_32=iotaXII( A_30,QUADio);
 /* dsf scalar(s) */
A_34=eqCCB(rx_0,'\x2d');
 A_35=slBII(A_34,A_32);
 A_36= ABC(toi(A_35)-QUADio,shape(rx_0)[0]);
A_38=inds1(rx_0,A_36,'-');
rx_1=( A_38);
 A_40=comaXCC( y);
 ry_0=( A_40);
 A_42=rhoXCI( ry_0);
 A_44=iotaXII( A_42,QUADio);
 /* dsf scalar(s) */
A_46=eqCCB(ry_0,'\x2d');
 A_47=slBII(A_46,A_44);
 A_48= ABC(toi(A_47)-QUADio,shape(ry_0)[0]);
A_50=inds1(ry_0,A_48,'-');
ry_1=( A_50);
 A_53=sameCCB(rx_1,ry_1);
 A_54=rhoXCI( y);
 A_55=rhoXCI( x);
 A_57=sameIIB(A_55,A_54);
 /* dsf scalar(s) */
A_58=andBBB(A_57,A_53);
 r_0=( A_58);
 return(r_0);
}

inline char[.] DthornIntCLONE15IBC(int[.] wp, bool y ,int QUADio)
{ 
/*
 ?
*/
A_73= ABC(toi(false)-QUADio,shape(wp)[0]);
A_75=wp[[A_73]];
 w_0=( A_75);
 A_77= ABC(toi(true)-QUADio,shape(wp)[0]);
A_79=wp[[A_77]];
 p_0=( A_79);
 QUADct_0=toD(( false));
 A_82=rhoICC(w_0,' ');
 r_0=( A_82);
 /* dsf scalar(s) */
A_84=barIBI(w_0,true);
 A_85= ABC(toi(A_84)-QUADio,shape(r_0)[0]);
A_87=inds0(r_0,A_85,'0');
 r_1=( A_87);
 /* dsf scalar(s) */
A_90=ltBBB(y,false);
 sig_0=( A_90);
 A_92= ABC(toi(sig_0)-QUADio,shape([-1, 1])[0]);
A_94=[-1, 1][[A_92]];
 /* dsf scalar(s) */
A_95=mpyBII(y,A_94);
 cury_0=( A_95);
 ld_0=( false);
 digits_0=( ['0','1','2','3','4','5','6','7','8','9']);
 A_100=iotaXII( w_0,QUADio);
 A_101=rotrXII( A_100);
 A_CTR102_= 0;
A_CTR102z_ = (shape(A_101)[[0]])-1;
r_3=toC(r_1);
ld_2=toI(ld_0);
cury_2=toI(cury_0);
digits_2=toC(digits_0);
for(; A_CTR102_ <= A_CTR102z_; A_CTR102_++){
i_0 = A_101[[A_CTR102_]];
 /* dsf scalar(s) */
A_107=divIID(cury_2,10);
 A_109=maxXDI( A_107,QUADct_0);
 nexty_0=( A_109);
 /* dsf scalar(s) */
A_112=neIBB(cury_2,false);
 /* dsf scalar(s) */
A_114=barIBI(i_0,true);
 A_115=comaIII(ld_2,A_114);
 A_113= ABC(toi(A_112)-QUADio,shape(A_115)[0]);
A_117=A_115[[A_113]];
 ld_2=( A_117);
 /* dsf scalar(s) */
A_119=mpyIII(nexty_0,10);
 /* dsf Scalar & clique */
A_120=barIII(cury_2,A_119);
 A_121=modXII( A_120);
 dig_0=( A_121);
 A_123= ABC(toi(dig_0)-QUADio,shape(digits_2)[0]);
A_125=digits_2[[A_123]];
 A_126= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_128=inds0(r_3,A_126,A_125);
 r_3=( A_128);
 cury_2=( nexty_0);
 /* dsf scalar(s) */
A_132=eqIBB(nexty_0,false);
 A_134= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_136=digits_2[[A_134]];
 A_137=comaCCC(A_136,' ');
 A_133= ABC(toi(A_132)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_133]];
 A_140= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_142=inds0(digits_2,A_140,A_139);
 digits_2=( A_142);
 }
 /* dsf scalar(s) */
A_145=maxBII(false,ld_2);
 ld_3=( A_145);
 A_148= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_150=r_3[[A_148]];
 A_151=comaCCC(A_150,'-');
 A_147= ABC(toi(sig_0)-QUADio,shape(A_151)[0]);
A_153=A_151[[A_147]];
 A_154= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_156=inds0(r_3,A_154,A_153);
 r_4=( A_156);
 A_158=rhoXCI( r_4);
 /* dsf scalar(s) */
A_160=neIBB(cury_2,false);
 /* dsf scalar(s) */
A_161=mpyBII(A_160,A_158);
 A_163=iotaXII( A_161,QUADio);
 A_164= ABC(toi(A_163)-QUADio,shape(r_4)[0]);
A_166=inds1(r_4,A_164,'*');
 r_5=( A_166);
 return(r_5);
}

