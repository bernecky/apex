% SAC Code fragments for indexed assign
% R. Bernecky 2006-01-16
% 
% All fragments are {QUAD}io=0; callers must subtract {QUAD}io from indices.

% Also, as of 2005-11-02, support for removing 1's from the shape
% vectors involved in the operation has not been implemented yet.

% Related to that is FIXME: in X[i;j;k...]<-Y, we need validation
% that the array shapes are conformable. 


% Cases of indexed assign:
% 1. x[scalar;;]<- scalar          NB. Leading axis 
% 2. x[non-scalar;;]<- scalar      NB. Leading axis
% 3. x[scalar;;]<- non-scalar      NB. Leading axis, cell shapes must match
% 4. x[non-scalar;;]<- non-scalar  NB. Leading axis,
%                                  NB.  frame and cell shapes must match
% 5. x[;scalar;;]<- scalar         NB. Non-Leading axis 
% 6. x[;non-scalar;;]<- scalar     NB. Non-Leading axis
% 7. x[;scalar;;]<- non-scalar     NB. Non-Leading axis, cell shapes must match
% 8. x[;non-scalar;;]<- non-scalar NB. Non-Leading axis,
%                                  NB.  frame and cell shapes must match
% 9. x[;;]<- scalar                NB. All elements change here
% 10.x[;;]<- y                     NB. All elements change here
%                                  NB.  frame and cell shapes must match

%Fragment inds *0*x           Anything[]<-scalar
inline $ZTYPE[+] indsfr0($XTYPE[+] x, $YTYPE y)
{ /* Indexed Assign   X[;;;] <- ScalarY  */
 z = with(. <= iv <= .)
	genarray(shape(x),y);
 return(z);
}
%Fragment inds ***x           Anything[]<-Anything
inline $ZTYPE[*] indsfr0($XTYPE[*] x, $YTYPE[*] y)
{ /* Indexed Assign   X[;;;] <- Y */
 z = reshape(shape(x),y);
 return(z);
}

%Fragment inds 111x           Vector[]<-vector
inline $ZTYPE indsfr0(int[0] i, $XTYPE[.] X, $YTYPE[.] Y)
{ /* Indexed Assign  V[] <- V */
/* FIXME: Need length check on vectors here */
 if (1 = (shape(Y)[0])
 	z = genarray(shape(X),Y[0]);
 else
 if ((shape(X)[0] = shape(Y)[0]]) /* Conformable */
	z = Y;
 else
	z = Y; /* SIGNAL ERROR HERE!!! FIXME */
return(Z);
}

%Fragment inds ****          X[;;i;;...] <- Y 
inline $ZTYPE[+] indsfr(int fr, int[*] i, $XTYPE[+] X, $YTYPE[+] Y)
{ /* X[;;;i;;;]<- nonscalar Y, where i has fr semicolons to its left */
 cellshape = shape(i)++drop([fr],shape(X));
 cell = genarray(cellshape,$OTFILL); /* not used, but SAC needs help */
 frameshape = take([fr],shape(X)); 
 z = with (. <= iv <= .)
	genarray(frameshape,indsfr0(i,X[iv], Y[iv]),cell);
 zshape = frameshape++cellshape;
 return(reshape(zshape,z));
}


inline $ZTYPE[+] indsfr(int fr, int[+] i, $XTYPE[+] X, $YTYPE Y)
{ /* X[;;;i;;;]<- scalar Y, where i has fr semicolons to its left */
 cellshape = drop([fr+1],shape(X));
 cell = genarray(cellshape,$OTFILL); /* not used, but SAC needs help */
 frameshape = take([fr],shape(X)); 
 z = with (. <= iv <= .)
	genarray(frameshape,indsfr0(i,X[iv], Y),cell);
 return(z);
}

inline $ZTYPE[+] indsfr(int fr, int i, $XTYPE[+] X, $YTYPE Y)
{ /* X[;;;i;;;]<- scalar Y, where i has fr semicolons to its left */
 cellshape = drop([fr+1],shape(X));
 cell = genarray(cellshape,$OTFILL); 
 frameshape = take([fr],shape(X)); 
 z = with (. <= iv <= .)
	genarray(frameshape,indsfr0(i,X[iv], Y),cell);
 zshape = frameshape++cellshape;
 return(z);
}

inline $ZTYPE[+] indsfr0(int i, $XTYPE[+] X, $YTYPE Y)
{ /* Case 1. X[scalarI;;]<- scalarY  NB. Leading axis  */
 cell = genarray(drop([1],shape(X)),to$ZT(Y));
 z = to$ZT(X);
 z[[i]] = cell;
 return(z);
}

inline $ZTYPE[+] indsfr0(int i, $XTYPE[+] X, $YTYPE[+] Y)
{ /* Case 1. X[scalarI;;]<- non-scalarY  NB. Leading axis  */
  /* This has to match on shape. FIXME! */
 z = to$ZT(X);
 z[[i]] = to$ZT(Y);
 return(z);
}

inline $ZTYPE[+] indsfr0(int[.] iv, $XTYPE[+] X, $YTYPE Y)
{ /* 2. X[non-scalarIV;;]<- scalarY      NB. Leading axis */
  /* This would almost work under a with-loop, but the potential
   * for duplicates in iv scuppers that. Ergo, FOR loop.
   */
 z = to$ZT(X);
 cellshape = drop([1],shape(X));
 cell = genarray (cellshape, to$ZT(Y));
 raveli = APEXRavel(iv);
 for(i=0; i<shape(raveli)[0]; i++)
   z[raveli[i]] = cell;
 return(z);
}

inline $ZTYPE[+] indsfr0(int[+] i, $XTYPE[+] X, $YTYPE[+] Y)
{ /* 4. x[non-scalar;;]<- non-scalar  NB. Leading axis */
 z = to$ZT(X);
 raveli = APEXRavel(i);
 for(k=0; k<shape(raveli)[0]; k++)
   z[raveli[k]] = to$ZT(Y[k]);
 return(z);
}

