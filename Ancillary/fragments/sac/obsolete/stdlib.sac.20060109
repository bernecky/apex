/*
% This is the APEX stdlib.sis include file.
% Standard equates and constants for APL compiler
% Also standard coercion functions
*/

#define toB(x) tob((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

void APEXERROR(char[.] msg)
{
/* Error function. This needs work, as it should kill
 * the running task, too. 
 */
 /*print(msg); */
return();
}

/* Structural function utility functions */
/* Ravel utility */
#define APEXRavel(y) (reshape([prod(shape(y))],y))

inline int VectorRotateAmount(int x, int y)
{ /* Normalize x rotate for array of shape y on selected axis */
 /* normalize rotation count */
 if (x>0)
        z = _mod_(x,y);
 else
        z = y - _mod_(_abs_(x),y);
 return(z);
}

#define APEXRESHAPE(TYPE)					\
inline TYPE[*] APEXReshape(int[.] x, TYPE[*] y)			\
{ /* APEX vector x reshape, with item reuse */			\
  ry = APEXRavel(y);						\
  zxrho = prod(x); /* THIS NEEDS XRHO FOR CODE SAFETY!! */	\
  yxrho = shape(ry)[0];						\
  if( zxrho <= yxrho) { /* No element resuse case */		\
        z = take([zxrho],ry);					\
 } else {							\
        ncopies = zxrho/yxrho; /* # complete copies of y. */	\
        /* FIXME: y empty case !*/				\
        z = with(. <= [i] <= .)					\
                genarray( [ncopies], y,y);			\
        /* Now append the leftover bits */			\
        z = APEXRavel(z) ++ take([zxrho-(ncopies*yxrho)],ry);	\
 }								\
 return(reshape(x,z));						\
}

APEXRESHAPE(bool)
APEXRESHAPE(int)
APEXRESHAPE(double)
APEXRESHAPE(char)

#define APEXmiota(N) with (. <= [iv] <= .) genarray([N], iv)


#define APEXPI 3.1415926535897932d
#define APEXE  2.718281828d
/*  APEXPINFINITYI largest integer */
#define APEXPINFINITYD  1.7976931348623156D308
/*  APEXMINFINITYI smallest integer */
#define APEXMINFINITYD -1.7976931348623156D308


/*
% Floating-point utilities
% This taken from page 93 of the 1993-01-06 version 
% of Committee Draft 1 of the Extended ISO APL Standard
% NO {quad}ct support yet! 
*/

inline int Dsignum(double y)
{ /* signum double */
 if (0.0 == y)
	z = 0;
 else if (0.0 > y)
	z = -1;
 else 
	z = 1;
 return(z);
}

inline int Isignum(int y)
{ /* signum int */
 if (0 == y)
	z = 0;
 else if (0 > y)
	z = -1;
 else 
	z = 1;
 return(z);
}

inline double Dresidue(double x, double y, double QUADct)
{ /* Double residue double */
  /* See Iresidue for definition */
  if (0.0 == x)
	nx = 1.0;
  else 
	nx = x;
  z = y - x * tod(Dfloor(y/nx, QUADct));
  return(z);
}


inline int Iresidue(int x, int y, double ignoreme)
{ /* Integer residue integer */
  /* Third argument is ignored - QUADct for Dresidue */
  /* This definition is taken from SHARP APL Refman May 1991, p.6-26.
   * It extends the definition of residue to fractional right arguments
   * and to zero, negative and fractional left arguments. 
   * r= y-x times floor y divide x+0=x 
   */
  if (0 == x)
	nx = 1;
  else 
	nx = x;
  z = y - x * (y/nx);
  return(z);
}

inline int DfloorNoFuzz(double y)
{ /* Exact floor (no fuzz) */
 return(toi(floor(y)));
}

inline int Dfloor(double y, double QUADct)
{ /* Fuzzy floor */
  /* Definition taken from SHARP APL Refman May 1991, p.6-23
   * floor:  n <- (signum y) times nofuzzfloor 0.5+abs y)
   *         z <- n-(QUADct times 1 max abs y)<(n-y)
   *
   * If you want a double result,  write: "y - 1| y".
   *
   */
   n = tod(DfloorNoFuzz(0.5+fabs(y)));
   if (y < 0.0)
	n = -n;
   else if (0.0 == y)
	n = 0.0;
   range = fabs(y);
   if (1.0 > range)
	range = 1.0;
   fuzzlim = QUADct*range;
   ny = n-y;
   if (fuzzlim < ny)
	z = n - 1.0;
   else
	z = n;
   return(toi(z)); 
}

inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

/*
% 1996-12-07 Pearl Harbor Day. Try to fix bug in DBank infdivm 
% benchmark. (4 5 rho 6) + rank 1 (4 1 rho 7) introduces singleton
% vectors into scalar fn calls.
% Hence, we need support for singletons within scalar fns.
% There is an similar, but independent, bug in rank support for
% the extension case.
*/


/* vector-scalar simple search loops 
 * This is origin-0 x1 iota y0
 * cfn is comparator function type suffix to use, e.g, b,i,d,c,
 */

#define FindFirst(x,y,cfn,QUADct)			\
 sx = shape(x)[0];					\
 z = sx; /* if not found */				\
 for(i=0; i<sx; i++)					\
  if (comparatorfn##cfn(to##cfn(x[i]),to##cfn(y),QUADct)) \
   { z = i;						\
     i = sx; 						\
   }

int FindFirstB(bool[.] x, bool y, double QUADct)
{
 /* x iota y (vector-scalar on Booleans */
 FindFirst(x,y,b,QUADct)
 return(z);
}

int FindFirstI(int[.] x, int y, double QUADct)
{
 /* x iota y (vector-scalar on integers */
 FindFirst(x,y,i,QUADct)
 return(z);
}

int FindFirstD(double[.] x, double y,double QUADct)
{
 /* x iota y (vector-scalar on doubles */
 FindFirst(x,y,d,QUADct)
 return(z);
}

int FindFirstC(char[.] x, char y, double QUADct)
{
 /* x iota y (vector-scalar on characters */
 FindFirst(x,y,c,QUADct)
 return(z);
}


inline bool equals(char x, char y,double QUADct)
{ /* Char comparator */
 z = (x == y);
 return(z);
}

inline bool equals(char[+] x, char[+] y, double QUADct)
{ /* Char item comparator */
  /* This definition is sort of flakey - it really compares ravels... */
  /* It oughta also ensure that the arguments shapes match... */
  z = with(0*shape(x) <= iv < shape(x))
	fold(&, true, x[iv] == y[iv]);
 return(z);
}

inline bool lessthan(char[+] x, char[+] y, double QUADct)
{ /* Char item comparator */
  /* It oughta also ensure that the arguments shapes match... */
  shp=shape(x)[0];
  z=false;
  for (i=0;i<shp;i++)
        if (x[i]!=y[i]){
                z= x[i]<y[i];
                i=shp;
        }
 return(z);
}

inline bool greaterthan(char[+] x, char[+] y, double QUADct)
{ /* Char item comparator */
  /* This definition is sort of flakey - it really compares ravels... */
  /* It oughta also ensure that the arguments shapes match... */
  shp=shape(x)[0];
  z=false;
  for (i=0;i<shp;i++)
        if (x[i]!=y[i]){
                z= x[i]>y[i];
                i=shp;
        }
 return(z);
}

inline bool comparatorfnb(bool x, bool y,double QUADct)
{ /* Boolean comparator */
 z = (x == y);
 return(z);
}

inline bool comparatorfni(int x, int y, double QUADct)
{ /* integer comparator */
 z = (x == y);
 return(z);
}

inline bool comparatorfnd(double x, double y, double QUADct)
{ /* double comparator with fuzz */
 L = _abs_(x-y);  /* Tolerant equality */
 R = QUADct*max(_abs_(x),_abs_(y));
 z = (L <= R);
 return(z);
}


inline bool comparatorfnc(char x, char y,double QUADct)
{ /* char comparator */
 z = (x == y);
 return(z);
}

inline bool comparatorfndnf(double x,double y, double QUADct)
{ /* double comparator, no fuzz */
 z = (x == y);
 return(z);
}

/*  Lehmer's random number generator */
#define lehmer(qrl) mod(qrl*16807,2147483647)


/* Transposes */
#define APEXTRANSPOSE(TYPE,OTFILL)			\
inline TYPE[*] APEXTranspose(TYPE[*] y)			\
{							\
  z = with(iv)						\
	( . <= iv <= .) : y[reverse( iv)];		\
        genarray( reverse( shape(y)), OTFILL);		\
  return(z);						\
}

APEXTRANSPOSE(bool,false)
APEXTRANSPOSE(int,0)
APEXTRANSPOSE(double,0.0)
APEXTRANSPOSE(char,' ')
/* End of transposes */

/* End of boilerplate */


