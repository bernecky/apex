/*
% Monadic Scalar Functions
*	These are included as if they were Arrays.sac.
* 	Robert Bernecky 2003-06-29


/*
 * Monadic array template.
 */

#define OP_A_TEMPLATE(name, expn, restype, argtype)     \
inline restype name (argtype A)				\
{/* Scalar-scalar */					\
  result = op (A);					\
  return(result);					\
}							\
inline restype[+] name (argtype[+] A)                   \
{                                                       \
  argtype array_elem;                                   \
                                                        \
  result = with (. <= iv <= .) {                        \
             array_elem = A[iv];                        \
           }                                            \
           genarray( shape(A), op (array_elem));        \
                                                        \
  return(result);                                       \
}

/* Taken from Array.sac */
#define NUM_TYPES_1(template, arg1)                             \
template(arg1, int, int)                                        \
template(arg1, float, float)                                    \
template(arg1, double, double)

#define APEX_Identity (YV, ztype, ytype)			\
inline ztype[*] APEX_Identity (rtype[*] YV)		\
{							\
 return(YV);						\
}

NUM_TYPES_1(APEX_Identity, YV)

/* Roll */ 
OP_A_TEMPLATE(query, "UNDER_CONSTRUCTION", int, int)

/* absolute value */
OP_A_TEMPLATE(mod, "", bool, bool)
OP_A_TEMPLATE(mod, abs int, int)
OP_A_TEMPLATE(mod, dabs double, double)

/* Negation */  
OP_A_TEMPLATE(bar, oops, bool, bool)
OP_A_TEMPLATE(bar, oops, int, int)
OP_A_TEMPLATE(bar, oops, double, double)

/* Monadic plus */  

OP_A_TEMPLATE(plus, oops, bool, bool)
OP_A_TEMPLATE(plus, oops, int, int)
OP_A_TEMPLATE(plus, oops, double, double)


%
%Fragment min  x b x b b       Floor Boolean (nop)
$YV
%Fragment min  x i x i i       Floor Integer (nop)
$YV
%Fragment min  x d x d i       Floor Double 
floor($YV)
%
%Fragment max  x b x b b       Ceiling Boolean (nop)
$YV
%Fragment max  x i x i i       Ceiling Integer (nop)
$YV
%Fragment max  x d x d i       Ceiling Double 
%
% This is done using floor and the identity:
%  (ceiling y) = (- floor -y)
-floor(-$YV)
%
%Fragment mpy  x b x b b       Times Boolean (nop)
$YV                             
%Fragment mpy  x i x i i       Times Integer (Signum)
Isignum($YV)
%Fragment mpy  x d x d i       Times Double (Signum)
Dsignum($YV)   
%
%Fragment not  x b x b b       Not Boolean
~$YV
%Fragment not  x i x b b       Not Integer
~$YV
%Fragment not  x d x b b       Not Double
~$YV
%
%Fragment div  x b x d d       Divide Boolean
1.0d/$YV
%Fragment div  x i x d d       Divide Integer
1.0d/$YV
%Fragment div  x d x d d       Divide Double
1.0d/$YV
%
%Fragment star x b x d d       Exp Boolean
exp(E,$YV)
%Fragment star x i x d d       Exp Integer
exp(E,$YV)
%Fragment star x d x d d       Exp Double
exp(E,$YV)
%
%Fragment log  x b x d d       Log Boolean
log($YV)
%Fragment log  x i x d d       Log Integer
log($YV)
%Fragment log  x d x d d       Log Double
log($YV)
%
%Fragment circ x b x d d       Circle Boolean
PI*$YV
%Fragment circ x i x d d       Circle Integer
PI*$YV
%Fragment circ x d x d d       Circle Double
PI*$YV
