module metaph2;
export {metaph2_testXXI};

// Compiled by APEX Version: FIXME!! 2021-06-27 18:01:39.294
use Array: all;
use ArrayFormat: all;
use Bits: all;
use Clock: {clock,mday,mon,year,to_time};
use CommandLine: all;
use Numerical : all;
use RTClock: all;
use StdIO : all;
use String: {to_string,tochar,sscanf};

// APEX stdlib.sis include file.
// Standard equates and constants for APL compiler
// Also standard coercion functions

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

#define BtoB(x) ((x))
#define ItoI(x) ((x))
#define DtoD(x) ((x))
#define CtoC(x) ((x))

#define BtoI(x) toi((x))
#define BtoD(x) tod((x))
#define ItoB(x) to_bool((x))
#define ItoD(x) tod((x))
#define DtoB(x) to_bool((x))
#define DtoI(x) toi((x))


inline bool notXBB(bool y)
{ /* Boolean NOT */
  return(!toB(y));
}

inline bool[+] notXBB(bool[+] y)
{ /* Monadic scalar functions on array */
  z = with {
        ( . <= iv <= .)
                : notXBB(toB(y[iv]));
        } : genarray(shape(y), false);
  return(z);
}

inline int plusBII(bool x, int y)
{ return(BtoI(x)+ItoI(y));
}

inline int barBBI(bool x, bool y)
{ return(BtoI(x)-BtoI(y));
}

inline int[+] barIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : barIII(xel,yel);
        } : genarray(sy, 0);
  return(z);
}






inline int[+] plusIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] mpyIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : mpyIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] barIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : barIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] plusIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : plusIII(xel,yel);
        } : genarray(sy, 0);
  return(z);
}






inline bool[+] eqCCB(char[+] x, char y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : eqCCB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] andBBB(bool[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : andBBB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline bool[+] orBBB(bool[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : orBBB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline bool[+] neCCB(char[+] x, char[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : neCCB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline bool[+] eqCCB(char x, char[+] y)
{ /* SxA scalar function */
  xel = toC(x);
  z = with {
     ( . <= iv <= .) {
              yel = toC(y[iv]);
                    } : eqCCB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] neCCB(char x, char[+] y)
{ /* SxA scalar function */
  xel = toC(x);
  z = with {
     ( . <= iv <= .) {
              yel = toC(y[iv]);
                    } : neCCB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] neCCB(char[+] x, char y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : neCCB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[+] plusBBI(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : plusBBI(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline bool[.] comaXBB(bool[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline int[.] comaXII(int[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] comaXCC(char[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] comaXCC(char[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline char[.] rotrICC(int x, char[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline bool[.] rotrIBB(int x, bool[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline char[.] rotrBCC(bool x, char[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline bool[.] rotrBBB(bool x, bool[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline char[.] rhoBCC(bool x, char[*] y)
{ /* [Scalar reshape non-scalar] (to vector) */
 z = rhoICC( [toi(x)],y);
 return(z);
}


inline bool[+] epsCCB(char[+] x, char[+] y)
{ /* character membership AxA*/
 ry = comaXCC(y);
 tbl = genarray([256],false);
 for(i=0; i<shape(ry)[[0]]; i++) {
  tbl[[toi(ry[[i]])]] = true;
 }

 z = with {
        (. <= iv <= .)
                : tbl[[toi(x[iv])]];
        } : genarray(shape(x), false);
 return(z);
}


inline char[*] rhoICC(int[.] x, char[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _aplmod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), ' ');
   return( z);
}



inline bool epsBIB(bool x, int[.] y)
{ /* Non-fuzzy membership SxA */
 z = with {
        (0*shape(y) <= iv < shape(y))
                : toI(x) == toI(y[iv]);
        } : foldfix(|, false, true);
 return(z);
}

inline char[.] rhoICC(int x, char y)
{ // [Scalar reshape scalar]
  z = genarray( [toi(x)],y);
  return(z);
}

inline int[*] iotaCCIQUADAV(char[256] x, char y,int QUADio)
{ /* QUADav iota character scalar */
 return(toi(y)+QUADio);
}

inline char[.] rhoICC(int x, char[*] y)
{ /* [Scalar reshape non-scalar] (to vector) */
 z = rhoICC( [toi(x)],y);
 return(z);
}


inline int[*] iotaCCIQUADAV(char[256] x, char[+] y,int QUADio)
{ /* QUADav iota character non-scalar */
 z = with {
        (. <= iv <= .)
                : toi(y[iv]);
        } : genarray(shape(y), 0);
 return(z+QUADio);
}

inline bool[.] epsbCCB(char[.] x, char[.] y)
{
WONTWORK
}
function epsbCCB(x1: array[char];
                y1: array[char]
                returns array[boolean])


$SFCASES{{ % General case (0)
MATCHRESTVECTOR(char,char,C,C,C)

 if IsEmpty(x1) then array_fill(0,array_limh(y1),true) % x1 empty
 else
 let
  lasti := array_limh(y1) - array_limh(x1); % Last y1 index where
                                            % match can occur
 in
   for y0 in y1 at i returns array of
    if CtoC(x1[0]) ~= CtoC(y0)
     % Quick out if no match on first character
      | i > lasti          % or past end of y1
    then false
    else MatchRestVector(x1,y1,i)
    end if
   end for
 end let
 end if
end function
}}

inline bool[.] rhoIBB(int[1] x, bool y)
{ // [1-element Vector reshape scalar]
  z = genarray( toi(x),y);
  return(z);
}

inline char[.] takeBCC(bool x, char[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[*] dropIII(int x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[*] dropBII(bool x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline char[.] takeICC(int x, char[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[.] takeBII(bool x, int[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[.]  rhoXBI(bool[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXII(int[1] y, int QUADio)
{ /* Index generator on 1-element vector */
 /* HELP! Needs length error check */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y[[0]]));
  return( z);
}

inline int[.]  rhoXCI(char[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXII(int y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[.]  rhoXII(int[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXBI(bool y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline char[256] quadavXXC()
{ /* QUADav - system character set */
 z = with{
        ([0] <= [i] < [256]) : _toc_S_(i);
        } : genarray( [256], ' ');
 return(z);
}

inline bool[.] comaBBB(bool[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toB(x)++[toB(y)]);
}

inline int[.] comaIBI(int[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toI(x)++[toI(y)]);
}

inline int[.] comaIII(int x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline int[.] comaIII(int[.] x, int y)
{/* VxS catenate first (or last) axis */
 return(toI(x)++[toI(y)]);
}

inline char[+] comaCCC(char[+] x, char[+] y)
{/* AxA last axis catenate. Ranks match */
 cellshape = (take([-1],shape(x)))+take([-1],shape(y));
 cell = genarray(cellshape, ' ');
 z = with {
         (. <= iv <= .)
                : toC(x[iv])++toC(y[iv]);
        } : genarray(drop([-1], shape(x)), cell);
 return(z);
}


inline char[.] comaCCC(char x, char[.] y)
{/* SxV catenate first (or last) axis */
 return([toC(x)]++toC(y));
}

inline int[2] comaIII(int x, int y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline bool sameIDB(int x, double y,double QUADct)
{ /* Scalar match scalar */
  z = eqDDB(toD(x), toD(y), QUADct);
 return(z);
}



inline char[*] indr(char[+] X, int[+] I)
{ /* X[nonscalarI;;;] */
 defcell = genarray(drop([1],shape(X)),' ');
 z = with {
        (. <= iv <= .)
                : X[[I[iv]]];
        } : genarray(shape(I), defcell);
 return(z);
}





inline char[+] inds1(char[+] X, int [+] I0, char[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = CtoC(X);
 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=CtoC((Y[[i0]]));

 }

 return(z);
}



inline char[+] inds1(char[+] X, int [+] I0, char Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = CtoC(X);
 Y = Yin;

 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=CtoC((Y));

 }

 return(z);
}



inline int[*] jotdotplusIII(int [+] x, int [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), 0);
 z = with {
        (. <= iv <= .) {
         xitem = toI(x[iv]);
        } : plusIII(xitem, toI(y));
        } : genarray(shape(x), cell);
 return(z);
}

inline int[.] slBII(bool[.] x, int[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], 0);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline char[.] slBCC(bool[.] x, char[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], ' ');
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline int[.] bslBII(bool[.] x, int[.] y)
{ /* Vector-vector expand */
 /* Stupid with-loops won't work here. */
 /* FIXME: Needs check that (+/x)= shape(y)[0] and x^.GE 0 */
 yi=0;
 z= genarray(shape(x),0);
 for (xi=0; xi<shape(x)[[0]]; xi++){
   if (toB(x[[xi]])) {
        z[[xi]]=y[[yi]];
        yi++;
   }
 }
 return(z);
}


inline bool[.] slBBB(bool[.] x, bool[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], false);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline char[.] slICC(int[.] x, char[.] y)
{/* Non-Boolean vector compress/replicate vector */
 /* HELP! non-boolean left argument needs a range check */
  intx = toi(x);
  zxrho = sum(intx);
  z = genarray([zxrho], ' ');
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    for(k=0; k<intx[[i]]; k++){
     z[[zi]] = y[[i]];
     zi++;
    }
  return(z);
}


inline bool[.] slIBB(int[.] x, bool[.] y)
{/* Non-Boolean vector compress/replicate vector */
 /* HELP! non-boolean left argument needs a range check */
  intx = toi(x);
  zxrho = sum(intx);
  z = genarray([zxrho], false);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    for(k=0; k<intx[[i]]; k++){
     z[[zi]] = y[[i]];
     zi++;
    }
  return(z);
}


inline int mpyslXIIQUICKSTOP(int[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : ItoI(y[iv]);
        } : foldfix( mpyIII, ItoI(1), ItoI(0));
  return(z);
}


inline int maxslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( maxIII, ItoI(minint()));
  return(z);
}


inline int[.] plusbslXII(int[.] y)
{ /* Scan of vector */
/* This does the scan in the wrong direction, but since
 * we assume associative functions only, it should be ok.
 */
 size = shape(y);
 z = genarray(size,ItoI(0));
 if (0 != size[[0]]) {
        /* real work to do */
        z[[0]] = ItoI(y[[0]]); /* Not sure about the coercion... */
        for ( i=1; i<size[[0]]; i++) {
                z[[i]] = plusIII(ItoI(z[[i-1]]),ItoI(y[[i]]));
        }
  }
 return(z);
}


inline int plusslXBIFOLD(bool[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : BtoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline int plusslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline int barIII(int x, int y)
{ return(ItoI(x)-ItoI(y));
}

inline int plusIII(int x, int y)
{ return(ItoI(x)+ItoI(y));
}

inline int mpyIII(int x, int y)
{ return(ItoI(x)*ItoI(y));
}

inline bool eqCCB(char x, char y)
{ /* A=B on non-doubles */
 return(CtoC(x) == CtoC(y));
}

inline bool andBBB(bool x, bool y)
{ return(BtoB(x)&BtoB(y));
}

inline bool orBBB(bool x, bool y)
{ return(BtoB(x) | BtoB(y));
}

inline bool neCCB(char x, char y)
{/* A !=B on non-doubles */
 return(CtoC(x) != CtoC(y));
}

inline int plusBBI(bool x, bool y)
{ return(BtoI(x)+BtoI(y));
}

inline bool eqDDB(double x, double y, double QUADct)
{ /* A=B on doubles */
  /* We use | instead of || on the assumption that
   * the zero-fuzz case will eliminate the second leg,
   * and it also eliminate a CONDFUN.
   */
 return((DtoD(x) == DtoD(y)) | APEXFUZZEQ(DtoD(x),DtoD(y),QUADct));
}


inline int maxIII(int x, int y)
{ /* x max y */
 return (max(ItoI(x),ItoI(y)));
}

inline int[+] barIII(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : barIII(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline int[+] plusIII(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : plusIII(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline bool[+] andBBB(bool x, bool[+] y)
{ /* SxA scalar function */
  xel = toB(x);
  z = with {
     ( . <= iv <= .) {
              yel = toB(y[iv]);
                    } : andBBB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] andBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : andBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] orBBB(bool x, bool[+] y)
{ /* SxA scalar function */
  xel = toB(x);
  z = with {
     ( . <= iv <= .) {
              yel = toB(y[iv]);
                    } : orBBB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] orBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : orBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[.] comaXBB(bool[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[*] indrfr(int fr, char[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline char[*] indrfr0(char[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline char[*] indrfr(int fr, char[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,' ');
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline int VectorRotateAmount(int x, int y)
{ /* Normalize x rotate for array of shape y on selected axis */
 /* normalize rotation count */

if ((0==x) || (0==y))
  z = 0;
else if (x>0)
        z = _aplmod_SxS_(x,y);
     else
        z = y - _aplmod_SxS_(abs(x),y);
 return(z);
}

inline int V2O( int[.] shp, int[.] iv)
{ /* Vector iv to offset into array of shape shp */
  /* See V2O.dws workspace */
  offset = 0;
  wt = 1;
  for( i=shape(shp)[0]-1; i>=0; i--) {
    offset = offset + ( wt * iv[i]);
    wt = wt * shp[i];
  }
  return( offset);
}

inline int[.] O2V( int[.] shp, int offset)
{ /* Offset into array of shape shp to index vector */
  /* See V2O.dws workspace */
  iv = genarray( shape(shp), 1);
  wts = iv;
  for( i=shape(shp)[0]-2; i>=0; i--) {
    wts[i] = wts[i+1] * shp[i+1];
  }

  for( i=shape(shp)[0]-1; i>=0; i--) {
    iv[i] = _aplmod_SxS_( offset/wts[i], shp[i]);
    offset = offset - (iv[i]*wts[i]);
  }
  return( iv);
}

inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

inline int[+] ABC(int[+] I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[nonscalarI] & indexed assign */
 z = I;
 return(z);
}

inline int ABC(int I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[scalarI] & indexed assign */
 z = I;
 return(z);
}

inline int[.] QIORXBI(bool[.] y ,int QUADio)
{ 
/*
 ?
*/
A_15=rhoXBI( y);
 A_17=iotaXII( A_15,QUADio);
A_18=slBII(y,A_17);
 r_0=( A_18);
 return(r_0);
}

inline char[.,.] vtomXCC(char[.] vector,int QUADio)
{ 
/*
 ?
*/
A_35=rhoBCC(false,vector);
 A_36=takeBCC(true,A_35);
 element_0=( A_36);
 A_38=takeBCC(true,vector);
 A_40=epsCCB(vector,A_38);
 A_41=comaXBB( A_40);
 b_0=( A_41);
 A_43=rhoXCI( vector);
 A_44=mpyslXIIQUICKSTOP( A_43);
 // dsf scalar(s)
A_48=plusBII(true,A_44);
 A_50=iotaXII( A_48,QUADio);
 A_51=comaBBB(b_0,true);
 A_52=slBII(A_51,A_50);
 t_0=( A_52);
 A_54=dropIII(-1,t_0);
 A_55=dropBII(true,t_0);
 // dsf Check needed
A_56=barIII(A_55,A_54);
 // dsf scalar(s)
A_57=plusIII(-1,A_56);
 l_0=( A_57);
 A_59=comaIBI(l_0,false);
 A_60=maxslXIIFOLD( A_59);
 c_0=( A_60);
 A_65=rhoXII( l_0);
 // dsf scalar(s)
A_66=mpyIII(c_0,A_65);
 A_67=rhoICC(A_66,element_0);
 t_1=( A_67);
 A_69=notXBB( b_0);
 A_70=slBCC(A_69,vector);
 A_71=comaIII(c_0,l_0);
 A_72=dropIII(-1,A_71);
 // dsf scalar(s)
A_73=barIII(c_0,A_72);
 A_74=bslBII(b_0,A_73);
 A_75=plusbslXII( A_74);
 A_79=notXBB( b_0);
 A_80=slBII(A_79,A_75);
 A_81=rhoXII( l_0);
 A_82=rhoXBI( b_0);
 // dsf scalar(s)
A_83=barIII(A_82,A_81);
 A_85=iotaXII( A_83,QUADio);
 // dsf scalar(s)
A_86=plusIII(A_85,A_80);
 A_87= ABC(toi(A_86)-QUADio,shape(t_1)[0]);
A_89=inds1(t_1,A_87,A_70);
t_2=( A_89);
 A_91=rhoXII( l_0);
 A_92=comaIII(A_91,c_0);
 A_93=rhoICC(A_92,t_2);
 matrix_0=( A_93);
 return(matrix_0);
}

inline char[.,.] metaphoneXCC(char[.,.] omega,int QUADio)
{ 
/*
 ?
*/
r_0=( omega);
 A_190=rhoXCI( omega);
 A_192=epsBIB(false,A_190);
 A_193=notXBB( A_192);
 A_195=iotaXBI( A_193,QUADio);
 A_CTR196_= 0;
A_CTR196z_ = (shape(A_195)[[0]])-1;
omega_5=toC(omega);
r_22=toC(r_0);
for(; A_CTR196_ <= A_CTR196z_; A_CTR196_++){
j_0 = A_195[[A_CTR196_]];
 A_204=rhoICC(256,' ');
 x_1=( A_204);
 A_207=iotaXII( 26,QUADio);
 A_208=quadavXXC( );
 A_211=iotaCCIQUADAV(A_208,'A',QUADio);
 // dsf scalar(s)
A_212=plusIII(A_211,A_207);
 A_214=quadavXXC( );
 A_213= ABC(toi(A_212)-QUADio,shape(A_214)[0]);
A_216=indr(A_214,A_213);
 A_217=rhoICC(52,A_216);
 A_219=iotaXII( 26,QUADio);
 A_220=quadavXXC( );
 A_223=iotaCCIQUADAV(A_220,['a','A'],QUADio);
 A_224=jotdotplusIII(A_223,A_219);
 A_231=comaXII( A_224);
 A_232= ABC(toi(A_231)-QUADio,shape(x_1)[0]);
A_234=inds1(x_1,A_232,A_217);
 x_2=( A_234);
 A_236=quadavXXC( );
 A_239=iotaCCIQUADAV(A_236,omega_5,QUADio);
 A_240= ABC(toi(A_239)-QUADio,shape(x_2)[0]);
A_242=indr(x_2,A_240);
 omega_1=( A_242);
 A_244=quadavXXC( );
 A_245=takeBCC(true,A_244);
 A_246=takeICC(4,A_245);
 A_247=takeICC(-6,A_246);
 A_248=rhoXCI( omega_1);
 A_249=takeBII(true,A_248);
 A_250=comaIII(A_249,6);
 A_251=rhoICC(A_250,A_247);
 A_252=comaCCC(A_251,omega_1);
 A_253=comaXCC( A_252);
 A_254=rotrICC(2,A_253);
 omega_2=( A_254);
 // dsf scalar(s)
A_257=eqCCB(omega_2,' ');
 A_258=rotrIBB(-1,A_257);
 A_259=quadavXXC( );
 A_260=takeBCC(true,A_259);
 A_261=comaCCC(' ',A_260);
 A_263=epsCCB(omega_2,A_261);
 A_264=notXBB( A_263);
 // dsf Check needed
A_265=andBBB(A_264,A_258);
 isFirst_1=( A_265);
 A_268=epsbCCB(['G','N'],omega_2);
 A_270=epsbCCB(['K','N'],omega_2);
 // dsf Check needed
A_271=orBBB(A_270,A_268);
 A_273=epsbCCB(['P','N'],omega_2);
 // dsf Check needed
A_274=orBBB(A_273,A_271);
 b_1=( A_274);
 A_277=epsbCCB(['W','H'],omega_2);
 A_279=epsbCCB(['W','R'],omega_2);
 // dsf Check needed
A_280=orBBB(A_279,A_277);
 A_282=epsbCCB(['A','E'],omega_2);
 // dsf Check needed
A_283=orBBB(A_282,A_280);
 // dsf Check needed
A_284=orBBB(b_1,A_283);
 b_2=( A_284);
 // dsf Check needed
A_286=andBBB(isFirst_1,b_2);
 b_3=( A_286);
 A_289=epsbCCB(['W','H'],omega_2);
 // dsf Check needed
A_290=andBBB(isFirst_1,A_289);
 A_291=rotrIBB(-1,A_290);
 // dsf Check needed
A_292=orBBB(b_3,A_291);
 A_293=notXBB( A_292);
 b_4=( A_293);
 // dsf scalar(s)
A_296=eqCCB(omega_2,'X');
 // dsf Check needed
A_297=andBBB(isFirst_1,A_296);
 x_3=( A_297);
 A_300=QIORXBI( A_297,QUADio);
 A_301= ABC(toi(A_300)-QUADio,shape(omega_2)[0]);
A_303=inds1(omega_2,A_301,'S');
 omega_3=( A_303);
 A_305=slBCC(b_4,omega_3);
 omega_4=( A_305);
 A_307=rotrBCC(true,omega_4);
 // dsf Scalar & clique
A_309=neCCB(omega_4,A_307);
 A_311=epsCCB(omega_4,['C',' ']);
 // dsf scalar(s)
A_312=orBBB(A_311,A_309);
 A_313=slBCC(A_312,omega_4);
 omega_5=( A_313);
 A_315=comaXCC( omega_5);
 r_2=( A_315);
 // dsf scalar(s)
A_318=eqCCB(omega_5,' ');
 A_319=rotrIBB(-1,A_318);
 A_320=quadavXXC( );
 A_321=takeBCC(true,A_320);
 A_322=comaCCC(' ',A_321);
 A_324=epsCCB(omega_5,A_322);
 A_325=notXBB( A_324);
 // dsf scalar(s)
A_326=andBBB(A_325,A_319);
 isFirst_2=( A_326);
 // dsf scalar(s)
A_329=eqCCB(omega_5,' ');
 A_330=rotrBBB(true,A_329);
 A_331=quadavXXC( );
 A_332=takeBCC(true,A_331);
 A_333=comaCCC(' ',A_332);
 A_335=epsCCB(omega_5,A_333);
 A_336=notXBB( A_335);
 // dsf scalar(s)
A_337=andBBB(A_336,A_330);
 isLast_0=( A_337);
 A_340=epsCCB(omega_5,['A','E','I','O','U']);
 isVowel_0=( A_340);
 A_343=epsCCB(omega_5,['E','I','Y']);
 frontv_0=( A_343);
 A_345=rhoXCI( omega_5);
 A_346=rhoIBB(A_345,false);
 drop_1=( A_346);
 A_348=notXBB( isFirst_2);
 // dsf scalar(s)
A_349=andBBB(isVowel_0,A_348);
 // dsf scalar(s)
A_350=orBBB(drop_1,A_349);
 drop_2=( A_350);
 A_352=rotrICC(-1,omega_5);
 // dsf scalar(s)
A_354=eqCCB('M',A_352);
 // dsf scalar(s)
A_355=orBBB(isLast_0,A_354);
 // dsf scalar(s)
A_357=eqCCB(omega_5,'B');
 // dsf scalar(s)
A_358=andBBB(A_357,A_355);
 // dsf scalar(s)
A_359=orBBB(drop_2,A_358);
 drop_3=( A_359);
 A_361=rotrBBB(true,frontv_0);
 A_362=notXBB( A_361);
 A_363=rotrICC(-1,omega_5);
 // dsf scalar(s)
A_365=neCCB('S',A_363);
 // dsf scalar(s)
A_366=orBBB(A_365,A_362);
 // dsf scalar(s)
A_368=eqCCB(omega_5,'C');
 // dsf scalar(s)
A_369=andBBB(A_368,A_366);
 c_0=( A_369);
 A_372=epsbCCB(['C','I','A'],omega_5);
 // dsf scalar(s)
A_373=andBBB(c_0,A_372);
 b_5=( A_373);
 A_376=QIORXBI( A_373,QUADio);
 A_377= ABC(toi(A_376)-QUADio,shape(r_2)[0]);
A_379=inds1(r_2,A_377,'X');
 r_3=( A_379);
 x_4=( b_5);
 A_382=rotrBBB(true,frontv_0);
 A_383=notXBB( x_4);
 // dsf scalar(s)
A_384=andBBB(A_383,A_382);
 // dsf scalar(s)
A_385=andBBB(c_0,A_384);
 z_1=( A_385);
 A_388=QIORXBI( A_385,QUADio);
 A_389= ABC(toi(A_388)-QUADio,shape(r_3)[0]);
A_391=inds1(r_3,A_389,'S');
 r_4=( A_391);
 // dsf scalar(s)
A_393=orBBB(x_4,z_1);
 x_5=( A_393);
 A_395=rotrBCC(true,omega_5);
 // dsf scalar(s)
A_397=eqCCB('H',A_395);
 A_398=notXBB( x_5);
 // dsf scalar(s)
A_399=andBBB(A_398,A_397);
 // dsf scalar(s)
A_400=andBBB(c_0,A_399);
 b_6=( A_400);
 A_402=rotrICC(-1,omega_5);
 // dsf scalar(s)
A_404=eqCCB(A_402,'S');
 A_405=rotrIBB(2,isVowel_0);
 A_406=notXBB( A_405);
 // dsf scalar(s)
A_407=andBBB(isFirst_2,A_406);
 // dsf scalar(s)
A_408=orBBB(A_407,A_404);
 // dsf scalar(s)
A_409=andBBB(b_6,A_408);
 z_2=( A_409);
 A_411=slBBB(b_6,z_2);
 A_412= ABC(toi(A_411)-QUADio,shape(['X','K'])[0]);
A_414=indr(['X','K'],A_412);
 A_416=QIORXBI( b_6,QUADio);
 A_417= ABC(toi(A_416)-QUADio,shape(r_4)[0]);
A_419=inds1(r_4,A_417,A_414);
 r_5=( A_419);
 A_421=rotrIBB(-1,b_6);
 // dsf scalar(s)
A_422=orBBB(drop_3,A_421);
 drop_4=( A_422);
 // dsf scalar(s)
A_424=orBBB(x_5,b_6);
 x_6=( A_424);
 A_426=notXBB( x_6);
 // dsf scalar(s)
A_427=andBBB(c_0,A_426);
 A_429=QIORXBI( A_427,QUADio);
 A_430= ABC(toi(A_429)-QUADio,shape(r_5)[0]);
A_432=inds1(r_5,A_430,'K');
 r_6=( A_432);
 x_7=( [:char]);
 z_3=( [:char]);
 b_7=( [:char]);
 // dsf scalar(s)
A_438=eqCCB('D',omega_5);
 x_8=( A_438);
 A_440=rotrBCC(true,omega_5);
 // dsf scalar(s)
A_442=eqCCB('G',A_440);
 // dsf Scalar & clique
A_443=andBBB(x_8,A_442);
 b_8=( A_443);
 A_446=QIORXBI( b_8,QUADio);
 A_447= ABC(toi(A_446)-QUADio,shape(r_6)[0]);
A_449=inds1(r_6,A_447,'J');
 r_7=( A_449);
 A_451=rotrIBB(-1,x_8);
 // dsf scalar(s)
A_452=orBBB(drop_4,A_451);
 drop_5=( A_452);
 A_454=notXBB( b_8);
 // dsf Scalar & clique
A_455=andBBB(x_8,A_454);
 A_457=QIORXBI( A_455,QUADio);
 A_458= ABC(toi(A_457)-QUADio,shape(r_7)[0]);
A_460=inds1(r_7,A_458,'T');
 r_8=( A_460);
 b_9=( [:char]);
 x_9=( [:char]);
 // dsf scalar(s)
A_465=eqCCB(omega_5,'G');
 z_4=( A_465);
 // dsf scalar(s)
A_468=neCCB(omega_5,'D');
 x_10=( A_468);
 A_470=rotrIBB(2,isVowel_0);
 // dsf scalar(s)
A_472=neCCB(omega_5,'H');
 A_473=rotrBBB(true,A_472);
 // dsf scalar(s)
A_474=orBBB(A_473,A_470);
 // dsf scalar(s)
A_475=andBBB(z_4,A_474);
 b_10=( A_475);
 A_477=rotrIBB(3,x_10);
 // dsf scalar(s)
A_479=neCCB(omega_5,'E');
 A_480=rotrIBB(2,A_479);
 // dsf Scalar & clique
A_481=orBBB(A_480,A_477);
 A_482=rotrBBB(true,isLast_0);
 A_483=notXBB( A_482);
 // dsf scalar(s)
A_484=andBBB(A_483,A_481);
 // dsf scalar(s)
A_486=neCCB(omega_5,'N');
 A_487=rotrBBB(true,A_486);
 // dsf scalar(s)
A_488=orBBB(A_487,A_484);
 // dsf scalar(s)
A_489=andBBB(b_10,A_488);
 b_11=( A_489);
 A_491=rotrBBB(true,frontv_0);
 A_492=notXBB( A_491);
 A_493=rotrIBB(-1,x_10);
 // dsf scalar(s)
A_494=orBBB(A_493,A_492);
 // dsf scalar(s)
A_495=andBBB(b_11,A_494);
 b_12=( A_495);
 A_497=rotrIBB(2,z_4);
 A_498=notXBB( A_497);
 A_499=rotrBBB(true,frontv_0);
 // dsf scalar(s)
A_500=andBBB(A_499,A_498);
 A_501=slBBB(b_12,A_500);
 A_502= ABC(toi(A_501)-QUADio,shape(['K','J'])[0]);
A_504=indr(['K','J'],A_502);
 A_506=QIORXBI( b_12,QUADio);
 A_507= ABC(toi(A_506)-QUADio,shape(r_8)[0]);
A_509=inds1(r_8,A_507,A_504);
 r_9=( A_509);
 // dsf scalar(s)
A_512=neCCB(omega_5,'H');
 A_513=rotrIBB(-4,A_512);
 A_515=epsCCB(omega_5,['B','D','H']);
 A_516=notXBB( A_515);
 A_517=rotrIBB(-3,A_516);
 // dsf scalar(s)
A_518=andBBB(A_517,A_513);
 // dsf scalar(s)
A_520=eqCCB(omega_5,'H');
 A_521=rotrBBB(true,A_520);
 // dsf scalar(s)
A_522=andBBB(A_521,A_518);
 A_523=notXBB( b_12);
 // dsf scalar(s)
A_524=andBBB(A_523,A_522);
 // dsf scalar(s)
A_525=andBBB(z_4,A_524);
 x_11=( A_525);
 A_528=QIORXBI( x_11,QUADio);
 A_529= ABC(toi(A_528)-QUADio,shape(r_9)[0]);
A_531=inds1(r_9,A_529,'F');
 r_10=( A_531);
 A_533=rotrIBB(-1,x_11);
 // dsf scalar(s)
A_534=orBBB(drop_5,A_533);
 drop_6=( A_534);
 // dsf scalar(s)
A_536=orBBB(b_12,x_11);
 A_537=notXBB( A_536);
 // dsf scalar(s)
A_538=andBBB(z_4,A_537);
 // dsf scalar(s)
A_539=orBBB(drop_6,A_538);
 drop_7=( A_539);
 z_5=( [:char]);
 x_12=( [:char]);
 b_13=( [:char]);
 A_544=rotrBBB(true,isVowel_0);
 A_545=notXBB( A_544);
 A_546=rotrIBB(-1,isVowel_0);
 // dsf Scalar & clique
A_547=andBBB(A_546,A_545);
 // dsf scalar(s)
A_549=eqCCB(omega_5,'H');
 // dsf scalar(s)
A_550=andBBB(A_549,A_547);
 // dsf scalar(s)
A_551=orBBB(drop_7,A_550);
 drop_8=( A_551);
 A_554=epsbCCB(['C','K'],omega_5);
 A_555=rotrIBB(-1,A_554);
 // dsf scalar(s)
A_556=orBBB(drop_8,A_555);
 drop_9=( A_556);
 A_559=epsbCCB(['P','H'],omega_5);
 b_14=( A_559);
 A_562=QIORXBI( A_559,QUADio);
 A_563= ABC(toi(A_562)-QUADio,shape(r_10)[0]);
A_565=inds1(r_10,A_563,'F');
 r_11=( A_565);
 A_567=rotrIBB(-1,b_14);
 // dsf scalar(s)
A_568=orBBB(drop_9,A_567);
 drop_10=( A_568);
 // dsf scalar(s)
A_571=eqCCB(omega_5,'Q');
 A_573=QIORXBI( A_571,QUADio);
 A_574= ABC(toi(A_573)-QUADio,shape(r_11)[0]);
A_576=inds1(r_11,A_574,'K');
 r_12=( A_576);
 A_579=epsbCCB(['S','H'],omega_5);
 b_15=( A_579);
 A_582=QIORXBI( A_579,QUADio);
 A_583= ABC(toi(A_582)-QUADio,shape(r_12)[0]);
A_585=inds1(r_12,A_583,'X');
 r_13=( A_585);
 A_587=rotrIBB(-1,b_15);
 // dsf scalar(s)
A_588=orBBB(drop_10,A_587);
 drop_11=( A_588);
 A_591=epsbCCB(['T','I','A'],omega_5);
 A_593=epsbCCB(['T','I','O'],omega_5);
 // dsf scalar(s)
A_594=orBBB(A_593,A_591);
 A_596=epsbCCB(['S','I','A'],omega_5);
 // dsf scalar(s)
A_597=orBBB(A_596,A_594);
 A_599=epsbCCB(['S','I','O'],omega_5);
 // dsf scalar(s)
A_600=orBBB(A_599,A_597);
 b_16=( A_600);
 A_603=QIORXBI( b_16,QUADio);
 A_604= ABC(toi(A_603)-QUADio,shape(r_13)[0]);
A_606=inds1(r_13,A_604,'X');
 r_14=( A_606);
 A_609=epsbCCB(['T','H'],omega_5);
 b_17=( A_609);
 A_612=QIORXBI( A_609,QUADio);
 A_613= ABC(toi(A_612)-QUADio,shape(r_14)[0]);
A_615=inds1(r_14,A_613,'0');
 r_15=( A_615);
 A_617=rotrIBB(-1,b_17);
 // dsf scalar(s)
A_618=orBBB(drop_11,A_617);
 drop_12=( A_618);
 // dsf scalar(s)
A_621=eqCCB(omega_5,'H');
 A_622=rotrIBB(2,A_621);
 // dsf scalar(s)
A_624=eqCCB(omega_5,'C');
 A_625=rotrBBB(true,A_624);
 // dsf Scalar & clique
A_626=orBBB(A_625,A_622);
 // dsf scalar(s)
A_628=eqCCB(omega_5,'T');
 // dsf Scalar & clique
A_629=andBBB(A_628,A_626);
 // dsf scalar(s)
A_630=orBBB(drop_12,A_629);
 drop_13=( A_630);
 // dsf scalar(s)
A_633=eqCCB(omega_5,'V');
 A_635=QIORXBI( A_633,QUADio);
 A_636= ABC(toi(A_635)-QUADio,shape(r_15)[0]);
A_638=inds1(r_15,A_636,'F');
 r_16=( A_638);
 A_640=notXBB( isVowel_0);
 A_641=rotrBBB(true,A_640);
 A_643=epsCCB(omega_5,['W','Y']);
 // dsf scalar(s)
A_644=andBBB(A_643,A_641);
 // dsf scalar(s)
A_645=orBBB(drop_13,A_644);
 drop_14=( A_645);
 // dsf scalar(s)
A_648=eqCCB(omega_5,'Z');
 A_650=QIORXBI( A_648,QUADio);
 A_651= ABC(toi(A_650)-QUADio,shape(r_16)[0]);
A_653=inds1(r_16,A_651,'S');
 r_17=( A_653);
 A_656=QIORXBI( drop_14,QUADio);
 A_657= ABC(toi(A_656)-QUADio,shape(r_17)[0]);
A_659=inds1(r_17,A_657,' ');
 r_18=( A_659);
 drop_15=( [:char]);
 A_662=notXBB( isFirst_2);
 // dsf scalar(s)
A_664=eqCCB(omega_5,'X');
 // dsf scalar(s)
A_665=andBBB(A_664,A_662);
 b_18=( A_665);
 // dsf scalar(s)
A_667=plusBBI(b_18,true);
 A_668=slICC(A_667,r_18);
 r_19=( A_668);
 // dsf scalar(s)
A_670=plusBBI(b_18,true);
 A_671=slIBB(A_670,b_18);
 b_19=( A_671);
 A_673=plusslXBIFOLD( b_19);
 A_677=rhoICC(A_673,['K','S']);
 A_679=QIORXBI( b_19,QUADio);
 A_680= ABC(toi(A_679)-QUADio,shape(r_19)[0]);
A_682=inds1(r_19,A_680,A_677);
 r_20=( A_682);
 b_20=( [:char]);
 // dsf scalar(s)
A_686=neCCB(r_20,' ');
 A_687=slBCC(A_686,r_20);
 r_21=( A_687);
 A_690=vtomXCC( r_21,QUADio);
 r_22=( A_690);
 }
 return(r_22);
}

inline int benchmetXII(int n ,int QUADio)
{ 
/*
 ?
*/
char_0=( [' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']);
A_23=comaIII(n,25);
 A_24=rhoICC(A_23,char_0);
 A_26=metaphoneXCC( A_24,QUADio);
 r_0=( A_26);
 A_28=quadavXXC( );
 A_31=iotaCCIQUADAV(A_28,r_0,QUADio);
 A_32=comaXII( A_31);
 A_33=plusslXIIFOLD( A_32);
 r_1=( A_33);
 return(r_1);
}

inline int metaph2_testXXI()
{ 
/*
 ?
*/
QUADio_0=toI(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 QUADio_1=toI(( false));
 QUADpp_1=( 16);
 QUADpw_1=( 80);
 n_0=( 1500000);
 QUADrl_1=( 16807);
 QUADct_1=( 1.0e-13);
 A_54=benchmetXII( n_0,QUADio_1);
 r_0=( A_54);
 A_58=quadXII( r_0,QUADpp_1,QUADpw_1);
 A_60=sameIDB(r_0,2233111160.0,QUADct_1);
// dsf scalar(s)
A_61=barBBI(true,A_60);
r_1=( A_61);
 A_65=quadXII( A_61,QUADpp_1,QUADpw_1);
 return(r_1);
}

