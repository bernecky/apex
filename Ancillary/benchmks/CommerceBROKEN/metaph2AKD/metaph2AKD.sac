use Array: all;
use StdIO : all;
use Numerical : all;
use CommandLine: all;
use String: {to_string,tochar,sscanf};
use ArrayFormat: all;
use Bits: all;

/* Compiled by APEX Version: /home/apex/apex3/wss/sac3013.dws2012-11-07 10:22:42.419 */
/*
% This is the APEX stdlib.sis include file.
% Standard equates and constants for APL compiler
% Also standard coercion functions
*/

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

#define BtoB(x) ((x))
#define ItoI(x) ((x))
#define DtoD(x) ((x))
#define CtoC(x) ((x))

#define BtoI(x) toi((x))
#define BtoD(x) tod((x))
#define ItoB(x) to_bool((x))
#define ItoD(x) tod((x))
#define DtoB(x) to_bool((x))
#define DtoI(x) toi((x))


inline bool notXBB(bool y)
{ /* Boolean NOT */
  return(!toB(y));
}

inline bool[+] notXBB(bool[+] y)
{ /* Monadic scalar functions on array */
  z = with {
        ( . <= iv <= .)
                : notXBB(toB(y[iv]));
        } : genarray(shape(y), false);
  return(z);
}

inline int plusBII(bool x, int y)
{ return(BtoI(x)+ItoI(y));
}

inline int barBBI(bool x, bool y)
{ return(BtoI(x)-BtoI(y));
}

inline int[+] barIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sx = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : barIII(xel,yel);
        } : genarray(sx, 0);
  return(z);
}






inline int[+] plusIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] mpyIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : mpyIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] barIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : barIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] plusIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sx = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : plusIII(xel,yel);
        } : genarray(sx, 0);
  return(z);
}






inline bool[+] eqCCB(char[+] x, char y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : eqCCB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] andBBB(bool[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sx = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : andBBB(xel,yel);
        } : genarray(sx, false);
  return(z);
}






inline bool[+] orBBB(bool[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sx = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : orBBB(xel,yel);
        } : genarray(sx, false);
  return(z);
}






inline bool[+] neCCB(char[+] x, char[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sx = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : neCCB(xel,yel);
        } : genarray(sx, false);
  return(z);
}






inline bool[+] eqCCB(char x, char[+] y)
{ /* SxA scalar function */
  xel = toC(x);
  z = with {
     ( . <= iv <= .) {
              yel = toC(y[iv]);
                    } : eqCCB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] neCCB(char x, char[+] y)
{ /* SxA scalar function */
  xel = toC(x);
  z = with {
     ( . <= iv <= .) {
              yel = toC(y[iv]);
                    } : neCCB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] neCCB(char[+] x, char y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : neCCB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[+] plusBBI(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : plusBBI(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline bool[.] comaXBB(bool[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline int[.] comaXII(int[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] comaXCC(char[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] comaXCC(char[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline char[.] rotrICC(int x, char[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline bool[.] rotrIBB(int x, bool[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline char[.] rotrBCC(bool x, char[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline bool[.] rotrBBB(bool x, bool[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline char[.] rhoBCC(bool x, char[*] y)
{ /* Scalar reshape non-scalar (to vector) */
 z = rhoICC( [toi(x)],y);
 return(z);
}


inline bool[+] epsCCB(char[+] x, char[+] y)
{ /* character membership AxA*/
 ry = comaXCC(y);
 tbl = genarray([256],false);
 for(i=0; i<shape(ry)[[0]]; i++) {
  tbl[[toi(ry[[i]])]] = true;
 }

 z = with {
        (. <= iv <= .)
                : tbl[[toi(x[iv])]];
        } : genarray(shape(x), false);
 return(z);
}


inline char[*] rhoICC(int[.] x, char[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _mod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), ' ');
   return( z);
}



inline bool epsBIB(bool x, int[.] y)
{ /* Non-fuzzy membership SxA */
 z = with {
        (0*shape(y) <= iv < shape(y))
                : toI(x) == toI(y[iv]);
        } : foldfix(|, false, true);
 return(z);
}

inline char[.] rhoICC(int x, char[*] y)
{ /* Scalar reshape non-scalar (to vector) */
 z = rhoICC( [toi(x)],y);
 return(z);
}


inline int[*] iotaCCIQUADAV(char[256] x, char y,int QUADio)
{ /* QUADav iota character scalar */
 return(toi(y)+QUADio);
}

inline int[*] iotaCCIQUADAV(char[256] x, char[+] y,int QUADio)
{ /* QUADav iota character non-scalar */
 z = with {
        (. <= iv <= .)
                : toi(y[iv]);
        } : genarray(shape(y), 0);
 return(z+QUADio);
}

inline bool[.] epsbCCB(char[.] x, char[.] y)
{
WONTWORK
}
function epsbCCB(x1: array[char];
                y1: array[char]
                returns array[boolean])


$SFCASES{{ % General case (0)
MATCHRESTVECTOR(char,char,C,C,C)

 if IsEmpty(x1) then array_fill(0,array_limh(y1),true) % x1 empty
 else
 let
  lasti := array_limh(y1) - array_limh(x1); % Last y1 index where
                                            % match can occur
 in
   for y0 in y1 at i returns array of
    if CtoC(x1[0]) ~= CtoC(y0)
     % Quick out if no match on first character
      | i > lasti          % or past end of y1
    then false
    else MatchRestVector(x1,y1,i)
    end if
   end for
 end let
 end if
end function
}}

inline bool[*] rhoIBB(int[.] x, bool[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _mod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), false);
   return( z);
}



inline char[.] takeBCC(bool x, char[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[*] dropIII(int x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[*] dropBII(bool x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline char[.] takeICC(int x, char[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[.] takeBII(bool x, int[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[.]  rhoXBI(bool[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXII(int[1] y, int QUADio)
{ /* Index generator on 1-element vector */
 /* HELP! Needs length error check */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y[[0]]));
  return( z);
}

inline int[.]  rhoXCI(char[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXII(int y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[.]  rhoXII(int[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXBI(bool y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline char[256] quadavXXC()
{ /* QUADav - system character set */
 z = with{
        ([0] <= [i] < [256]) : _toc_S_(i);
        } : genarray( [256], ' ');
 return(z);
}

inline bool[.] comaBBB(bool[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toB(x)++[toB(y)]);
}

inline int[.] comaIBI(int[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toI(x)++[toI(y)]);
}

inline int[.] comaIII(int x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline int[.] comaIII(int[.] x, int y)
{/* VxS catenate first (or last) axis */
 return(toI(x)++[toI(y)]);
}

inline char[+] comaCCC(char[+] x, char[+] y)
{/* AxA last axis catenate. Ranks match */
 cellshape = (take([-1],shape(x)))+take([-1],shape(y));
 cell = genarray(cellshape, ' ');
 z = with {
         (. <= iv <= .)
                : toC(x[iv])++toC(y[iv]);
        } : genarray(drop([-1], shape(x)), cell);
 return(z);
}


inline char[.] comaCCC(char x, char[.] y)
{/* SxV catenate first (or last) axis */
 return([toC(x)]++toC(y));
}

inline int[2] comaIII(int x, int y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline bool sameIIB(int x, int y)
{ /* Scalar match scalar */
  z = eqIIB(toI(x), toI(y));
 return(z);
}



inline char[*] indr(char[+] X, int[+] I)
{ /* X[nonscalarI;;;] */
 defcell = genarray(drop([1],shape(X)),' ');
 z = with {
        (. <= iv <= .)
                : X[[I[iv]]];
        } : genarray(shape(I), defcell);
 return(z);
}





inline char[+] inds1(char[+] X, int [+] I0, char[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = CtoC(X);
 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=CtoC(Y[[i0]]);

 }

 return(z);
}



inline char[+] inds1(char[+] X, int [+] I0, char Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = CtoC(X);
 Y = Yin;

 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=CtoC(Y);

 }

 return(z);
}



inline int CommandLineArgvXBI(bool y)
{ /* Get Command-line argument element #y as integer scalar */
  int z;
  junk, z = sscanf(argv(toi(y)), "%d");
  return( z);
}

inline int[*] jotdotplusIII(int [+] x, int [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), 0);
 z = with {
        (. <= iv <= .) {
         xitem = toI(x[iv]);
        } : plusIII(xitem, toI(y));
        } : genarray(shape(x), cell);
 return(z);
}

inline int[.] slBII(bool[.] x, int[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], 0);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline char[.] slBCC(bool[.] x, char[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], ' ');
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline int[.] bslBII(bool[.] x, int[.] y)
{ /* Vector-vector expand */
 /* Stupid with-loops won't work here. */
 /* FIXME: Needs check that (+/x)= shape(y)[0] and x^.GE 0 */
 yi=0;
 z= genarray(shape(x),0);
 for (xi=0; xi<shape(x)[[0]]; xi++){
   if (toB(x[[xi]])) {
        z[[xi]]=y[[yi]];
        yi++;
   }
 }
 return(z);
}


inline bool[.] slBBB(bool[.] x, bool[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], false);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline char[.] slICC(int[.] x, char[.] y)
{/* Non-Boolean vector compress/replicate vector */
 /* HELP! non-boolean left argument needs a range check */
  intx = toi(x);
  zxrho = sum(intx);
  z = genarray([zxrho], ' ');
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    for(k=0; k<intx[[i]]; k++){
     z[[zi]] = y[[i]];
     zi++;
    }
  return(z);
}


inline bool[.] slIBB(int[.] x, bool[.] y)
{/* Non-Boolean vector compress/replicate vector */
 /* HELP! non-boolean left argument needs a range check */
  intx = toi(x);
  zxrho = sum(intx);
  z = genarray([zxrho], false);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    for(k=0; k<intx[[i]]; k++){
     z[[zi]] = y[[i]];
     zi++;
    }
  return(z);
}


inline int mpyslXIIQUICKSTOP(int[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : ItoI(y[iv]);
        } : foldfix( mpyIII, ItoI(1), ItoI(0));
  return(z);
}


inline int maxslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( maxIII, ItoI(minint()));
  return(z);
}


inline int[.] plusbslXII(int[.] y)
{ /* Scan of vector */
/* This does the scan in the wrong direction, but since
 * we assume associative functions only, it should be ok.
 */
 size = shape(y);
 z = genarray(size,ItoI(0));
 if (0 != size[[0]]) {
        /* real work to do */
        z[[0]] = ItoI(y[[0]]); /* Not sure about the coercion... */
        for ( i=1; i<size[[0]]; i++) {
                z[[i]] = plusIII(ItoI(z[[i-1]]),ItoI(y[[i]]));
        }
  }
 return(z);
}


inline int plusslXBIFOLD(bool[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : BtoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline int plusslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline int barIII(int x, int y)
{ return(ItoI(x)-ItoI(y));
}

inline int plusIII(int x, int y)
{ return(ItoI(x)+ItoI(y));
}

inline int mpyIII(int x, int y)
{ return(ItoI(x)*ItoI(y));
}

inline bool eqCCB(char x, char y)
{ /* A=B on non-doubles */
 return(CtoC(x) == CtoC(y));
}

inline bool andBBB(bool x, bool y)
{ return(BtoB(x)&BtoB(y));
}

inline bool orBBB(bool x, bool y)
{ return(BtoB(x)|BtoB(y));
}

inline bool neCCB(char x, char y)
{/* A !=B on non-doubles */
 return(CtoC(x) != CtoC(y));
}

inline int plusBBI(bool x, bool y)
{ return(BtoI(x)+BtoI(y));
}

inline bool eqIIB(int x, int y)
{ /* A=B on non-doubles */
 return(ItoI(x) == ItoI(y));
}

inline int maxIII(int x, int y)
{ /* x max y */
 return (max(ItoI(x),ItoI(y)));
}

inline int[+] barIII(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : barIII(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline int[+] plusIII(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : plusIII(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline bool[+] andBBB(bool x, bool[+] y)
{ /* SxA scalar function */
  xel = toB(x);
  z = with {
     ( . <= iv <= .) {
              yel = toB(y[iv]);
                    } : andBBB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] andBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : andBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] orBBB(bool x, bool[+] y)
{ /* SxA scalar function */
  xel = toB(x);
  z = with {
     ( . <= iv <= .) {
              yel = toB(y[iv]);
                    } : orBBB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] orBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : orBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[.] comaXBB(bool[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[*] indrfr(int fr, char[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline char[*] indrfr0(char[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline char[*] indrfr(int fr, char[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,' ');
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline int VectorRotateAmount(int x, int y)
{ /* Normalize x rotate for array of shape y on selected axis */
 /* normalize rotation count */

if ((0==x) || (0==y))
  z = 0;
else if (x>0)
        z = _mod_SxS_(x,y);
     else
        z = y - _mod_SxS_(abs(x),y);
 return(z);
}

inline int V2O( int[.] shp, int[.] iv)
{ /* Vector iv to offset into array of shape shp */
  /* See V2O.dws workspace */
  offset = 0;
  wt = 1;
  for( i=shape(shp)[0]-1; i>=0; i--) {
    offset = offset + ( wt * iv[i]);
    wt = wt * shp[i];
  }
  return( offset);
}

inline int[.] O2V( int[.] shp, int offset)
{ /* Offset into array of shape shp to index vector */
  /* See V2O.dws workspace */
  iv = genarray( shape(shp), 1);
  wts = iv;
  for( i=shape(shp)[0]-2; i>=0; i--) {
    wts[i] = wts[i+1] * shp[i+1];
  }

  for( i=shape(shp)[0]-1; i>=0; i--) {
    iv[i] = _mod_SxS_( offset/wts[i], shp[i]);
    offset = offset - (iv[i]*wts[i]);
  }
  return( iv);
}

inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

inline int[+] ABC(int[+] I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[nonscalarI] & indexed assign */
 z = I;
 return(z);
}

inline int ABC(int I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[scalarI] & indexed assign */
 z = I;
 return(z);
}

inline int[.] QIORXBI(bool[.] y ,int QUADio)
{ 
/*
 ?
*/
A_18=rhoXBI( y);
 A_20=iotaXII( A_18,QUADio);
A_21=slBII(y,A_20);
 r_0=( A_21);
 return(r_0);
}

inline char[.,.] vtomXCC(char[.] vector,int QUADio)
{ 
/*
 ?
*/
A_38=rhoBCC(false,vector);
 A_39=takeBCC(true,A_38);
 element_0=( A_39);
 A_41=takeBCC(true,vector);
 A_43=epsCCB(vector,A_41);
 A_44=comaXBB( A_43);
 b_0=( A_44);
 A_46=rhoXCI( vector);
 A_47=mpyslXIIQUICKSTOP( A_46);
 /* dsf scalar(s) */
A_51=plusBII(true,A_47);
 A_53=iotaXII( A_51,QUADio);
 A_54=comaBBB(b_0,true);
 A_55=slBII(A_54,A_53);
 t_0=( A_55);
 A_57=dropIII(-1,t_0);
 A_58=dropBII(true,t_0);
 /* dsf Check needed */
A_59=barIII(A_58,A_57);
 /* dsf scalar(s) */
A_60=plusIII(-1,A_59);
 l_0=( A_60);
 A_62=comaIBI(l_0,false);
 A_63=maxslXIIFOLD( A_62);
 c_0=( A_63);
 A_68=rhoXII( l_0);
 /* dsf scalar(s) */
A_69=mpyIII(c_0,A_68);
 A_70=rhoICC(A_69,element_0);
 t_1=( A_70);
 A_72=notXBB( b_0);
 A_73=slBCC(A_72,vector);
 A_74=comaIII(c_0,l_0);
 A_75=dropIII(-1,A_74);
 /* dsf scalar(s) */
A_76=barIII(c_0,A_75);
 A_77=bslBII(b_0,A_76);
 A_78=plusbslXII( A_77);
 A_82=notXBB( b_0);
 A_83=slBII(A_82,A_78);
 A_84=rhoXII( l_0);
 A_85=rhoXBI( b_0);
 /* dsf scalar(s) */
A_86=barIII(A_85,A_84);
 A_88=iotaXII( A_86,QUADio);
 /* dsf Check needed */
A_89=plusIII(A_88,A_83);
 A_90= ABC(toi(A_89)-QUADio,shape(t_1)[0]);
A_92=inds1(t_1,A_90,A_73);
t_2=( A_92);
 A_94=rhoXII( l_0);
 A_95=comaIII(A_94,c_0);
 A_96=rhoICC(A_95,t_2);
 matrix_0=( A_96);
 return(matrix_0);
}

inline char[.,.] metaphoneXCC(char[.,.] omega,int QUADio)
{ 
/*
 ?
*/
r_0=( omega);
 A_193=rhoXCI( omega);
 A_195=epsBIB(false,A_193);
 A_196=notXBB( A_195);
 A_198=iotaXBI( A_196,QUADio);
 A_CTR199_= 0;
A_CTR199z_ = (shape(A_198)[[0]])-1;
omega_5=toC(omega);
r_22=toC(r_0);
for(; A_CTR199_ <= A_CTR199z_; A_CTR199_++){
j_0 = A_198[[A_CTR199_]];
 A_207=rhoICC(256,' ');
 x_1=( A_207);
 A_210=iotaXII( 26,QUADio);
 A_211=quadavXXC( );
 A_214=iotaCCIQUADAV(A_211,'A',QUADio);
 /* dsf scalar(s) */
A_215=plusIII(A_214,A_210);
 A_217=quadavXXC( );
 A_216= ABC(toi(A_215)-QUADio,shape(A_217)[0]);
A_219=indr(A_217,A_216);
 A_220=rhoICC(52,A_219);
 A_222=iotaXII( 26,QUADio);
 A_223=quadavXXC( );
 A_226=iotaCCIQUADAV(A_223,['a','A'],QUADio);
 A_227=jotdotplusIII(A_226,A_222);
 A_234=comaXII( A_227);
 A_235= ABC(toi(A_234)-QUADio,shape(x_1)[0]);
A_237=inds1(x_1,A_235,A_220);
 x_2=( A_237);
 A_239=quadavXXC( );
 A_242=iotaCCIQUADAV(A_239,omega_5,QUADio);
 A_243= ABC(toi(A_242)-QUADio,shape(x_2)[0]);
A_245=indr(x_2,A_243);
 omega_1=( A_245);
 A_247=quadavXXC( );
 A_248=takeBCC(true,A_247);
 A_249=takeICC(4,A_248);
 A_250=takeICC(-6,A_249);
 A_251=rhoXCI( omega_1);
 A_252=takeBII(true,A_251);
 A_253=comaIII(A_252,6);
 A_254=rhoICC(A_253,A_250);
 A_255=comaCCC(A_254,omega_1);
 A_256=comaXCC( A_255);
 A_257=rotrICC(2,A_256);
 omega_2=( A_257);
 /* dsf scalar(s) */
A_260=eqCCB(omega_2,' ');
 A_261=rotrIBB(-1,A_260);
 A_262=quadavXXC( );
 A_263=takeBCC(true,A_262);
 A_264=comaCCC(' ',A_263);
 A_266=epsCCB(omega_2,A_264);
 A_267=notXBB( A_266);
 /* dsf Check needed */
A_268=andBBB(A_267,A_261);
 isFirst_1=( A_268);
 A_271=epsbCCB(['G','N'],omega_2);
 A_273=epsbCCB(['K','N'],omega_2);
 /* dsf Check needed */
A_274=orBBB(A_273,A_271);
 A_276=epsbCCB(['P','N'],omega_2);
 /* dsf Check needed */
A_277=orBBB(A_276,A_274);
 b_1=( A_277);
 A_280=epsbCCB(['W','H'],omega_2);
 A_282=epsbCCB(['W','R'],omega_2);
 /* dsf Check needed */
A_283=orBBB(A_282,A_280);
 A_285=epsbCCB(['A','E'],omega_2);
 /* dsf Check needed */
A_286=orBBB(A_285,A_283);
 /* dsf Check needed */
A_287=orBBB(b_1,A_286);
 b_2=( A_287);
 /* dsf Check needed */
A_289=andBBB(isFirst_1,b_2);
 b_3=( A_289);
 A_292=epsbCCB(['W','H'],omega_2);
 /* dsf Check needed */
A_293=andBBB(isFirst_1,A_292);
 A_294=rotrIBB(-1,A_293);
 /* dsf Check needed */
A_295=orBBB(b_3,A_294);
 A_296=notXBB( A_295);
 b_4=( A_296);
 /* dsf scalar(s) */
A_299=eqCCB(omega_2,'X');
 /* dsf Check needed */
A_300=andBBB(isFirst_1,A_299);
 x_3=( A_300);
 A_303=QIORXBI( A_300,QUADio);
 A_304= ABC(toi(A_303)-QUADio,shape(omega_2)[0]);
A_306=inds1(omega_2,A_304,'S');
 omega_3=( A_306);
 A_308=slBCC(b_4,omega_3);
 omega_4=( A_308);
 A_310=rotrBCC(true,omega_4);
 /* dsf clique */
A_312=neCCB(omega_4,A_310);
 A_314=epsCCB(omega_4,['C',' ']);
 /* dsf Check needed */
A_315=orBBB(A_314,A_312);
 A_316=slBCC(A_315,omega_4);
 omega_5=( A_316);
 A_318=comaXCC( omega_5);
 r_2=( A_318);
 /* dsf scalar(s) */
A_321=eqCCB(omega_5,' ');
 A_322=rotrIBB(-1,A_321);
 A_323=quadavXXC( );
 A_324=takeBCC(true,A_323);
 A_325=comaCCC(' ',A_324);
 A_327=epsCCB(omega_5,A_325);
 A_328=notXBB( A_327);
 /* dsf Check needed */
A_329=andBBB(A_328,A_322);
 isFirst_2=( A_329);
 /* dsf scalar(s) */
A_332=eqCCB(omega_5,' ');
 A_333=rotrBBB(true,A_332);
 A_334=quadavXXC( );
 A_335=takeBCC(true,A_334);
 A_336=comaCCC(' ',A_335);
 A_338=epsCCB(omega_5,A_336);
 A_339=notXBB( A_338);
 /* dsf Check needed */
A_340=andBBB(A_339,A_333);
 isLast_0=( A_340);
 A_343=epsCCB(omega_5,['A','E','I','O','U']);
 isVowel_0=( A_343);
 A_346=epsCCB(omega_5,['E','I','Y']);
 frontv_0=( A_346);
 A_348=rhoXCI( omega_5);
 A_349=rhoIBB(A_348,false);
 drop_1=( A_349);
 A_351=notXBB( isFirst_2);
 /* dsf Check needed */
A_352=andBBB(isVowel_0,A_351);
 /* dsf Check needed */
A_353=orBBB(drop_1,A_352);
 drop_2=( A_353);
 A_355=rotrICC(-1,omega_5);
 /* dsf scalar(s) */
A_357=eqCCB('M',A_355);
 /* dsf Check needed */
A_358=orBBB(isLast_0,A_357);
 /* dsf scalar(s) */
A_360=eqCCB(omega_5,'B');
 /* dsf Check needed */
A_361=andBBB(A_360,A_358);
 /* dsf Check needed */
A_362=orBBB(drop_2,A_361);
 drop_3=( A_362);
 A_364=rotrBBB(true,frontv_0);
 A_365=notXBB( A_364);
 A_366=rotrICC(-1,omega_5);
 /* dsf scalar(s) */
A_368=neCCB('S',A_366);
 /* dsf Check needed */
A_369=orBBB(A_368,A_365);
 /* dsf scalar(s) */
A_371=eqCCB(omega_5,'C');
 /* dsf Check needed */
A_372=andBBB(A_371,A_369);
 c_0=( A_372);
 A_375=epsbCCB(['C','I','A'],omega_5);
 /* dsf Check needed */
A_376=andBBB(c_0,A_375);
 b_5=( A_376);
 A_379=QIORXBI( A_376,QUADio);
 A_380= ABC(toi(A_379)-QUADio,shape(r_2)[0]);
A_382=inds1(r_2,A_380,'X');
 r_3=( A_382);
 x_4=( b_5);
 A_385=rotrBBB(true,frontv_0);
 A_386=notXBB( x_4);
 /* dsf Check needed */
A_387=andBBB(A_386,A_385);
 /* dsf Check needed */
A_388=andBBB(c_0,A_387);
 z_1=( A_388);
 A_391=QIORXBI( A_388,QUADio);
 A_392= ABC(toi(A_391)-QUADio,shape(r_3)[0]);
A_394=inds1(r_3,A_392,'S');
 r_4=( A_394);
 /* dsf Check needed */
A_396=orBBB(x_4,z_1);
 x_5=( A_396);
 A_398=rotrBCC(true,omega_5);
 /* dsf scalar(s) */
A_400=eqCCB('H',A_398);
 A_401=notXBB( x_5);
 /* dsf Check needed */
A_402=andBBB(A_401,A_400);
 /* dsf Check needed */
A_403=andBBB(c_0,A_402);
 b_6=( A_403);
 A_405=rotrICC(-1,omega_5);
 /* dsf scalar(s) */
A_407=eqCCB(A_405,'S');
 A_408=rotrIBB(2,isVowel_0);
 A_409=notXBB( A_408);
 /* dsf Check needed */
A_410=andBBB(isFirst_2,A_409);
 /* dsf Check needed */
A_411=orBBB(A_410,A_407);
 /* dsf Check needed */
A_412=andBBB(b_6,A_411);
 z_2=( A_412);
 A_414=slBBB(b_6,z_2);
 A_415= ABC(toi(A_414)-QUADio,shape(['X','K'])[0]);
A_417=indr(['X','K'],A_415);
 A_419=QIORXBI( b_6,QUADio);
 A_420= ABC(toi(A_419)-QUADio,shape(r_4)[0]);
A_422=inds1(r_4,A_420,A_417);
 r_5=( A_422);
 A_424=rotrIBB(-1,b_6);
 /* dsf Check needed */
A_425=orBBB(drop_3,A_424);
 drop_4=( A_425);
 /* dsf Check needed */
A_427=orBBB(x_5,b_6);
 x_6=( A_427);
 A_429=notXBB( x_6);
 /* dsf Check needed */
A_430=andBBB(c_0,A_429);
 A_432=QIORXBI( A_430,QUADio);
 A_433= ABC(toi(A_432)-QUADio,shape(r_5)[0]);
A_435=inds1(r_5,A_433,'K');
 r_6=( A_435);
 x_7=( [:char]);
 z_3=( [:char]);
 b_7=( [:char]);
 /* dsf scalar(s) */
A_441=eqCCB('D',omega_5);
 x_8=( A_441);
 A_443=rotrBCC(true,omega_5);
 /* dsf scalar(s) */
A_445=eqCCB('G',A_443);
 /* dsf clique */
A_446=andBBB(x_8,A_445);
 b_8=( A_446);
 A_449=QIORXBI( b_8,QUADio);
 A_450= ABC(toi(A_449)-QUADio,shape(r_6)[0]);
A_452=inds1(r_6,A_450,'J');
 r_7=( A_452);
 A_454=rotrIBB(-1,x_8);
 /* dsf Check needed */
A_455=orBBB(drop_4,A_454);
 drop_5=( A_455);
 A_457=notXBB( b_8);
 /* dsf clique */
A_458=andBBB(x_8,A_457);
 A_460=QIORXBI( A_458,QUADio);
 A_461= ABC(toi(A_460)-QUADio,shape(r_7)[0]);
A_463=inds1(r_7,A_461,'T');
 r_8=( A_463);
 b_9=( [:char]);
 x_9=( [:char]);
 /* dsf scalar(s) */
A_468=eqCCB(omega_5,'G');
 z_4=( A_468);
 /* dsf scalar(s) */
A_471=neCCB(omega_5,'D');
 x_10=( A_471);
 A_473=rotrIBB(2,isVowel_0);
 /* dsf scalar(s) */
A_475=neCCB(omega_5,'H');
 A_476=rotrBBB(true,A_475);
 /* dsf Check needed */
A_477=orBBB(A_476,A_473);
 /* dsf Check needed */
A_478=andBBB(z_4,A_477);
 b_10=( A_478);
 A_480=rotrIBB(3,x_10);
 /* dsf scalar(s) */
A_482=neCCB(omega_5,'E');
 A_483=rotrIBB(2,A_482);
 /* dsf clique */
A_484=orBBB(A_483,A_480);
 A_485=rotrBBB(true,isLast_0);
 A_486=notXBB( A_485);
 /* dsf Check needed */
A_487=andBBB(A_486,A_484);
 /* dsf scalar(s) */
A_489=neCCB(omega_5,'N');
 A_490=rotrBBB(true,A_489);
 /* dsf Check needed */
A_491=orBBB(A_490,A_487);
 /* dsf Check needed */
A_492=andBBB(b_10,A_491);
 b_11=( A_492);
 A_494=rotrBBB(true,frontv_0);
 A_495=notXBB( A_494);
 A_496=rotrIBB(-1,x_10);
 /* dsf Check needed */
A_497=orBBB(A_496,A_495);
 /* dsf Check needed */
A_498=andBBB(b_11,A_497);
 b_12=( A_498);
 A_500=rotrIBB(2,z_4);
 A_501=notXBB( A_500);
 A_502=rotrBBB(true,frontv_0);
 /* dsf Check needed */
A_503=andBBB(A_502,A_501);
 A_504=slBBB(b_12,A_503);
 A_505= ABC(toi(A_504)-QUADio,shape(['K','J'])[0]);
A_507=indr(['K','J'],A_505);
 A_509=QIORXBI( b_12,QUADio);
 A_510= ABC(toi(A_509)-QUADio,shape(r_8)[0]);
A_512=inds1(r_8,A_510,A_507);
 r_9=( A_512);
 /* dsf scalar(s) */
A_515=neCCB(omega_5,'H');
 A_516=rotrIBB(-4,A_515);
 A_518=epsCCB(omega_5,['B','D','H']);
 A_519=notXBB( A_518);
 A_520=rotrIBB(-3,A_519);
 /* dsf Check needed */
A_521=andBBB(A_520,A_516);
 /* dsf scalar(s) */
A_523=eqCCB(omega_5,'H');
 A_524=rotrBBB(true,A_523);
 /* dsf Check needed */
A_525=andBBB(A_524,A_521);
 A_526=notXBB( b_12);
 /* dsf Check needed */
A_527=andBBB(A_526,A_525);
 /* dsf Check needed */
A_528=andBBB(z_4,A_527);
 x_11=( A_528);
 A_531=QIORXBI( x_11,QUADio);
 A_532= ABC(toi(A_531)-QUADio,shape(r_9)[0]);
A_534=inds1(r_9,A_532,'F');
 r_10=( A_534);
 A_536=rotrIBB(-1,x_11);
 /* dsf Check needed */
A_537=orBBB(drop_5,A_536);
 drop_6=( A_537);
 /* dsf Check needed */
A_539=orBBB(b_12,x_11);
 A_540=notXBB( A_539);
 /* dsf Check needed */
A_541=andBBB(z_4,A_540);
 /* dsf Check needed */
A_542=orBBB(drop_6,A_541);
 drop_7=( A_542);
 z_5=( [:char]);
 x_12=( [:char]);
 b_13=( [:char]);
 A_547=rotrBBB(true,isVowel_0);
 A_548=notXBB( A_547);
 A_549=rotrIBB(-1,isVowel_0);
 /* dsf clique */
A_550=andBBB(A_549,A_548);
 /* dsf scalar(s) */
A_552=eqCCB(omega_5,'H');
 /* dsf Check needed */
A_553=andBBB(A_552,A_550);
 /* dsf Check needed */
A_554=orBBB(drop_7,A_553);
 drop_8=( A_554);
 A_557=epsbCCB(['C','K'],omega_5);
 A_558=rotrIBB(-1,A_557);
 /* dsf Check needed */
A_559=orBBB(drop_8,A_558);
 drop_9=( A_559);
 A_562=epsbCCB(['P','H'],omega_5);
 b_14=( A_562);
 A_565=QIORXBI( A_562,QUADio);
 A_566= ABC(toi(A_565)-QUADio,shape(r_10)[0]);
A_568=inds1(r_10,A_566,'F');
 r_11=( A_568);
 A_570=rotrIBB(-1,b_14);
 /* dsf Check needed */
A_571=orBBB(drop_9,A_570);
 drop_10=( A_571);
 /* dsf scalar(s) */
A_574=eqCCB(omega_5,'Q');
 A_576=QIORXBI( A_574,QUADio);
 A_577= ABC(toi(A_576)-QUADio,shape(r_11)[0]);
A_579=inds1(r_11,A_577,'K');
 r_12=( A_579);
 A_582=epsbCCB(['S','H'],omega_5);
 b_15=( A_582);
 A_585=QIORXBI( A_582,QUADio);
 A_586= ABC(toi(A_585)-QUADio,shape(r_12)[0]);
A_588=inds1(r_12,A_586,'X');
 r_13=( A_588);
 A_590=rotrIBB(-1,b_15);
 /* dsf Check needed */
A_591=orBBB(drop_10,A_590);
 drop_11=( A_591);
 A_594=epsbCCB(['T','I','A'],omega_5);
 A_596=epsbCCB(['T','I','O'],omega_5);
 /* dsf Check needed */
A_597=orBBB(A_596,A_594);
 A_599=epsbCCB(['S','I','A'],omega_5);
 /* dsf Check needed */
A_600=orBBB(A_599,A_597);
 A_602=epsbCCB(['S','I','O'],omega_5);
 /* dsf Check needed */
A_603=orBBB(A_602,A_600);
 b_16=( A_603);
 A_606=QIORXBI( b_16,QUADio);
 A_607= ABC(toi(A_606)-QUADio,shape(r_13)[0]);
A_609=inds1(r_13,A_607,'X');
 r_14=( A_609);
 A_612=epsbCCB(['T','H'],omega_5);
 b_17=( A_612);
 A_615=QIORXBI( A_612,QUADio);
 A_616= ABC(toi(A_615)-QUADio,shape(r_14)[0]);
A_618=inds1(r_14,A_616,'0');
 r_15=( A_618);
 A_620=rotrIBB(-1,b_17);
 /* dsf Check needed */
A_621=orBBB(drop_11,A_620);
 drop_12=( A_621);
 /* dsf scalar(s) */
A_624=eqCCB(omega_5,'H');
 A_625=rotrIBB(2,A_624);
 /* dsf scalar(s) */
A_627=eqCCB(omega_5,'C');
 A_628=rotrBBB(true,A_627);
 /* dsf clique */
A_629=orBBB(A_628,A_625);
 /* dsf scalar(s) */
A_631=eqCCB(omega_5,'T');
 /* dsf clique */
A_632=andBBB(A_631,A_629);
 /* dsf Check needed */
A_633=orBBB(drop_12,A_632);
 drop_13=( A_633);
 /* dsf scalar(s) */
A_636=eqCCB(omega_5,'V');
 A_638=QIORXBI( A_636,QUADio);
 A_639= ABC(toi(A_638)-QUADio,shape(r_15)[0]);
A_641=inds1(r_15,A_639,'F');
 r_16=( A_641);
 A_643=notXBB( isVowel_0);
 A_644=rotrBBB(true,A_643);
 A_646=epsCCB(omega_5,['W','Y']);
 /* dsf Check needed */
A_647=andBBB(A_646,A_644);
 /* dsf Check needed */
A_648=orBBB(drop_13,A_647);
 drop_14=( A_648);
 /* dsf scalar(s) */
A_651=eqCCB(omega_5,'Z');
 A_653=QIORXBI( A_651,QUADio);
 A_654= ABC(toi(A_653)-QUADio,shape(r_16)[0]);
A_656=inds1(r_16,A_654,'S');
 r_17=( A_656);
 A_659=QIORXBI( drop_14,QUADio);
 A_660= ABC(toi(A_659)-QUADio,shape(r_17)[0]);
A_662=inds1(r_17,A_660,' ');
 r_18=( A_662);
 drop_15=( [:char]);
 A_665=notXBB( isFirst_2);
 /* dsf scalar(s) */
A_667=eqCCB(omega_5,'X');
 /* dsf Check needed */
A_668=andBBB(A_667,A_665);
 b_18=( A_668);
 /* dsf scalar(s) */
A_670=plusBBI(b_18,true);
 A_671=slICC(A_670,r_18);
 r_19=( A_671);
 /* dsf scalar(s) */
A_673=plusBBI(b_18,true);
 A_674=slIBB(A_673,b_18);
 b_19=( A_674);
 A_676=plusslXBIFOLD( b_19);
 A_680=rhoICC(A_676,['K','S']);
 A_682=QIORXBI( b_19,QUADio);
 A_683= ABC(toi(A_682)-QUADio,shape(r_19)[0]);
A_685=inds1(r_19,A_683,A_680);
 r_20=( A_685);
 b_20=( [:char]);
 /* dsf scalar(s) */
A_689=neCCB(r_20,' ');
 A_690=slBCC(A_689,r_20);
 r_21=( A_690);
 A_693=vtomXCC( r_21,QUADio);
 r_22=( A_693);
 }
 return(r_22);
}

inline int benchmetXII(int n ,int QUADio)
{ 
/*
 ?
*/
char_0=( [' ','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']);
A_26=comaIII(n,25);
 A_27=rhoICC(A_26,char_0);
 A_29=metaphoneXCC( A_27,QUADio);
 r_0=( A_29);
 A_31=quadavXXC( );
 A_34=iotaCCIQUADAV(A_31,r_0,QUADio);
 A_35=comaXII( A_34);
 A_36=plusslXIIFOLD( A_35);
 r_1=( A_36);
 return(r_1);
}

int main()
{ 
/*
 ?
*/
n=CommandLineArgvXBI( true);
 QUADio_0=toI(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 QUADio_1=toI(( false));
 QUADpp_1=( 16);
 QUADpw_1=( 80);
 QUADrl_1=( 16807);
 QUADct_1=( 1.0e-13);
 A_56=benchmetXII( n,QUADio_1);
 r_0=( A_56);
 A_60=quadXII( r_0,QUADpp_1,QUADpw_1);
 A_62=sameIIB(r_0,74437011);
 /* dsf scalar(s) */
A_63=barBBI(true,A_62);
r_1=( A_63);
 A_67=quadXII( A_63,QUADpp_1,QUADpw_1);
 return(r_1);
}

