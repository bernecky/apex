module UTThornInt;
export {UTThornInt_testXXI};

// Compiled by APEX Version: FIXME!! 2021-07-09 14:38:20.907
use Array: all;
use ArrayFormat: all;
use Bits: all;
use Clock: {clock,mday,mon,year,to_time};
use CommandLine: all;
use Numerical : all;
use RTClock: all;
use StdIO : all;
use String: {to_string,tochar,sscanf};

// APEX stdlib.sis include file.
// Standard equates and constants for APL compiler
// Also standard coercion functions

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

#define BtoB(x) ((x))
#define ItoI(x) ((x))
#define DtoD(x) ((x))
#define CtoC(x) ((x))

#define BtoI(x) toi((x))
#define BtoD(x) tod((x))
#define ItoB(x) to_bool((x))
#define ItoD(x) tod((x))
#define DtoB(x) to_bool((x))
#define DtoI(x) toi((x))


inline int maxXDI(double y, double QUADct)
{ /* Ceiling */
 return(-DFLOOR(-y, QUADct));
}


inline int modXII(int y)
{ return(abs(toI(y)));
}

inline int[+] modXII(int[+] y)
{ /* Monadic scalar functions on array */
  z = with {
        ( . <= iv <= .)
                : modXII(toI(y[iv]));
        } : genarray(shape(y), 0);
  return(z);
}

inline bool[+] modXBB(bool[+] y)
{ /* Monadic scalar functions on array */
  z = with {
        ( . <= iv <= .)
                : modXBB(toB(y[iv]));
        } : genarray(shape(y), false);
  return(z);
}

inline int barIBI(int x, bool y)
{ return(ItoI(x)-BtoI(y));
}

inline bool ltIBB(int x, bool y)
{ /* A<B on Boot/Int/Char */
  return(ItoI(x)<BtoI(y));
}

inline int mpyIII(int x, int y)
{ return(ItoI(x)*ItoI(y));
}

inline double divIID(int x, int y)
{ dx = ItoD(x);
  dy = ItoD(y);
  z = (dx == dy) ? 1.0  : dx/dy;
  return(z);
}

inline bool neIBB(int x, bool y)
{/* A !=B on non-doubles */
 return(ItoI(x) != BtoI(y));
}

inline int barIII(int x, int y)
{ return(ItoI(x)-ItoI(y));
}

inline bool eqIBB(int x, bool y)
{ /* A=B on non-doubles */
 return(ItoI(x) == BtoI(y));
}

inline int maxBII(bool x, int y)
{ /* x max y */
 return (max(BtoI(x),ItoI(y)));
}

inline bool andBBB(bool x, bool y)
{ return(BtoB(x)&BtoB(y));
}

inline int plusIII(int x, int y)
{ return(ItoI(x)+ItoI(y));
}

inline int barBBI(bool x, bool y)
{ return(BtoI(x)-BtoI(y));
}

inline bool ltBBB(bool x, bool y)
{ return((!x)&y);
}

/* NB.  APEX Extension of ISO APL to allow comparison of characters */
/* relationals */
inline int mpyBII(bool x, int y)
{ return(BtoI(x)*ItoI(y));
}

inline int[+] mpyBII(bool x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : mpyIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] eqCCB(char[+] x, char y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : eqCCB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[+] maxIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : maxIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] ltIBB(int[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : ltIBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] geIIB(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : geIIB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline bool[+] mpyBBB(bool[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : mpyBBB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline int[+] plusIBI(int[+] x, bool[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : plusIBI(xel,yel);
        } : genarray(sy, 0);
  return(z);
}






inline int[+] plusIBI(int[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : plusIBI(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline int[+] plusIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] maxIBI(int x, bool[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : maxIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] ltBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : ltBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[.] rotrXII(int[.] y)
{ /* Vector reverse */
  z = Array::reverse( 0, y);
  return( z);
}

inline char[.] comaXCC(char[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline int[.] comaXII(int[.] y)
{ /* Ravel of vector is NOP */
        return(y);
}


inline int[.] comaXII(int y)
{ /* Ravel of scalar */
  return([y]);
}

inline int[.] comaXII(int[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] comaXCC(char[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline char[.] rhoICC(int x, char y)
{ // [Scalar reshape scalar]
  z = genarray( [toi(x)],y);
  return(z);
}

inline int[.] rhoIII(int x, int y)
{ // [Scalar reshape scalar]
  z = genarray( [toi(x)],y);
  return(z);
}

inline int[*] rhoIII(int[.] x, int[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _aplmod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), 0);
   return( z);
}



inline char[*] rhoICC(int[.] x, char[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _aplmod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), ' ');
   return( z);
}



inline bool[*] rhoIBB(int[.] x, bool[*] y)
{  /* APEX vector x reshape, with potential item reuse */
   z = with {
         ( . <= iv <= .) {
           offset = V2O( toi( x), iv);
           offset = _aplmod_SxS_( offset, prod( shape(y)));
           el = y[ O2V( shape( y), offset)];
          } : el;
       } : genarray( toi(x), false);
   return( z);
}



inline int[.] takeIII(int x, int[.] y)
{ /* Scalar take vector */
  return(take([toi(x)], y));
}

inline int[*] dropIII(int x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[.] iotaXII(int y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[.]  rhoXCI(char[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXII(int[1] y, int QUADio)
{ /* Index generator on 1-element vector */
 /* HELP! Needs length error check */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y[[0]]));
  return( z);
}

inline int[.]  rhoXII(int[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline char[.] thrnXIC(int y, int QUADpp)
{ /* Monadic format on integer scalar  */
  z = format(y);
 return( z);
}

inline char[.] thrnXBC(bool y, int QUADpp)
{ /* Monadic format on Boolean scalar  */
  z = y ? '1' : '0';
  return([z]);
}

inline char[+] thrnXIC(int[+] y, int QUADpp)
{ /* Monadic format on integer non-scalar */
  z = format(y);
  return(z);
}


inline bool[*] quadXBB(bool[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline int[.]  rhoXBI(bool[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[2] comaIII(int x, int y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline char[2] comaCCC(char x, char y)
{/* SxS catenate first (or last) axis */
 return([toC(x)]++[toC(y)]);
}

inline int[.] comaBII(bool x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline int[.] comaIII(int x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline int[2] comaIBI(int x, bool y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline int[.] comaIII(int[.] x, int[.] y)
{ /* VxV catenate first or last axis */
 return(toI(x)++toI(y));
}

inline bool[2] comaBBB(bool x, bool y)
{/* SxS catenate first (or last) axis */
 return([toB(x)]++[toB(y)]);
}

inline bool[.] comaBBB(bool[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toB(x)++[toB(y)]);
}

inline bool[.] comaBBB(bool[.] x, bool[.] y)
{ /* VxV catenate first or last axis */
 return(toB(x)++toB(y));
}

inline bool sameCCB(char[+] x, char[+] y)
{ /* Non-scalar match non-scalar */
   z = (( _dim_A_( x) == _dim_A_( y))          &&
       ( all( _shape_A_( x) == _shape_A_( y))) &&
       ( all( eqCCB(toC( x),  toC( y)))));
  return(z);
}



inline bool sameIIB(int[+] x, int[+] y)
{ /* Non-scalar match non-scalar */
   z = (( _dim_A_( x) == _dim_A_( y))          &&
       ( all( _shape_A_( x) == _shape_A_( y))) &&
       ( all( eqIIB(toI( x),  toI( y)))));
  return(z);
}



inline int[*] indr(int[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline char[*] indr(char[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline bool[*] indr(bool[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline char[+] inds0(char[+] X, int  I0, char Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = CtoC(X);
 Y = Yin;

 
 z[[I0]]=CtoC((Y));

 
 return(z);
}



inline char[+] inds1(char[+] X, int [+] I0, char Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = CtoC(X);
 Y = Yin;

 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=CtoC((Y));

 }

 return(z);
}



inline char[+] inds01(char[+] X, int  I0,int [+] I1, char[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = CtoC(X);
  for(i1=0; i1<shape(I1)[[0]]; i1++){

 z[[I0,I1[[i1]]]]=CtoC((Y[[i1]]));

  }

 return(z);
}



inline int[+] indsxxx0(int[+] X, int  I3, int Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = ItoI(X);
 Y = Yin;

 for(i0=0; i0<shape(X)[[0]]; i0++){
 for(i1=0; i1<shape(X)[[1]]; i1++){
  for(i2=0; i2<shape(X)[[2]]; i2++){

 z[[i0,i1,i2,I3]]=ItoI((Y));

 }
 }
  }

 return(z);
}



inline bool[*] jotdotgeIIB(int [+] x, int [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), false);
 z = with {
        (. <= iv <= .) {
         xitem = toI(x[iv]);
        } : geIIB(xitem, toI(y));
        } : genarray(shape(x), cell);
 return(z);
}

inline int[*] jotdotmpyIII(int [+] x, int [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), 0);
 z = with {
        (. <= iv <= .) {
         xitem = toI(x[iv]);
        } : mpyIII(xitem, toI(y));
        } : genarray(shape(x), cell);
 return(z);
}

inline int[.] slBII(bool[.] x, int[.] y)
{/* Boolean vector compress vector */
  zxrho = sum(toi(x));
  z = genarray([zxrho], 0);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    if ( x[i]) {
      z[[zi]] = y[[i]];
      zi++;
    }
  return(z);
}

inline int[.] slBII(bool x, int y)
{ /* Scalar replicate scalar */
 z = with {
        (. <= iv <= .)
                : y;
        } : genarray([toi(x)]);
 return(z);
}

inline bool[.] slBBB(bool x, bool y)
{ /* Scalar replicate scalar */
 z = with {
        (. <= iv <= .)
                : y;
        } : genarray([toi(x)]);
 return(z);
}

inline int[.] slBII(bool x, int[.] y)
{ /* Scalar replicate vector */
 cell = genarray([toi(x)], 0);
 z = with {
        (. <= iv <= .)
                : genarray([toi(x)], y[iv]);
        } : genarray(shape(y), cell);
 return(comaXII(z));
}


inline int[+] slBII(bool x, int[+] y)
{ /* Boolean scalar compress non-scalar */
  sy = shape(y);
  z = (true == toB(x)) ?  y  : genarray(drop([-1],sy)++[0],0);
  return(z);
}

inline int[.] mpybslXII(int[.] y)
{ /* Scan of vector */
/* This does the scan in the wrong direction, but since
 * we assume associative functions only, it should be ok.
 */
 size = shape(y);
 z = genarray(size,ItoI(1));
 if (0 != size[[0]]) {
        /* real work to do */
        z[[0]] = ItoI(y[[0]]); /* Not sure about the coercion... */
        for ( i=1; i<size[[0]]; i++) {
                z[[i]] = mpyIII(ItoI(z[[i-1]]),ItoI(y[[i]]));
        }
  }
 return(z);
}


inline int[+] plusslXBIFOLD(bool[+] y)
{ /* last axis reduce rank-2 or greater matrix w/folding */
  sy = shape(y);
  zrho = drop([-1], sy);
  z = with {
         (. <= iv <= .)
                : plusslXBIFOLD(y[iv]);
        } : genarray(zrho, 0);
  return(z);
}


inline int mpyslXIIQUICKSTOP(int[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : ItoI(y[iv]);
        } : foldfix( mpyIII, ItoI(1), ItoI(0));
  return(z);
}


inline int[.] maxsl1XIIFOLD(int[.,.] y)
{ /* first-axis reduce rank-2 matrix */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : maxslXIIFOLD(yt[iv]);
        } : genarray(zrho, 0);
  return(z);
}




inline int[.] minsl1XIIFOLD(int[.,.] y)
{ /* first-axis reduce rank-2 matrix */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : minslXIIFOLD(yt[iv]);
        } : genarray(zrho, 0);
  return(z);
}




inline int[.] plusbslXII(int[.] y)
{ /* Scan of vector */
/* This does the scan in the wrong direction, but since
 * we assume associative functions only, it should be ok.
 */
 size = shape(y);
 z = genarray(size,ItoI(0));
 if (0 != size[[0]]) {
        /* real work to do */
        z[[0]] = ItoI(y[[0]]); /* Not sure about the coercion... */
        for ( i=1; i<size[[0]]; i++) {
                z[[i]] = plusIII(ItoI(z[[i-1]]),ItoI(y[[i]]));
        }
  }
 return(z);
}


inline int plusslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline bool andslXBBQUICKSTOP(bool[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : BtoB(y[iv]);
        } : foldfix( andBBB, ItoB(1), ItoB(0));
  return(z);
}


inline bool[.] maxsl1XBBQUICKSTOP(bool[.,.] y)
{ /* first-axis reduce rank-2 matrix with quickstop */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : maxslXBBQUICKSTOP(yt[iv]);
        } : genarray(zrho, false);
  return(z);
}





inline bool[.] minsl1XBBQUICKSTOP(bool[.,.] y)
{ /* first-axis reduce rank-2 matrix with quickstop */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
        (. <= iv <= .)
                : minslXBBQUICKSTOP(yt[iv]);
        } : genarray(zrho, false);
  return(z);
}





inline bool modXBB(bool y)
{ /* Absolute value Boolean (NOP) */
 return(toB(y));
}

inline bool eqCCB(char x, char y)
{ /* A=B on non-doubles */
 return(CtoC(x) == CtoC(y));
}

inline int maxIII(int x, int y)
{ /* x max y */
 return (max(ItoI(x),ItoI(y)));
}

inline bool geIIB(int x, int y)
{ /* A>=B on non-Doubles */
 return(ItoI(x) >= ItoI(y));
}

inline bool mpyBBB(bool x, bool y)
{ return(BtoB(x) & BtoB(y));
}

inline int plusIBI(int x, bool y)
{ return(ItoI(x)+BtoI(y));
}

inline bool[+] geIIB(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : geIIB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] geIIB(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : geIIB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline bool[+] mpyBBB(bool x, bool[+] y)
{ /* SxA scalar function */
  xel = toB(x);
  z = with {
     ( . <= iv <= .) {
              yel = toB(y[iv]);
                    } : mpyBBB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] mpyBBB(bool[+] x, bool y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : mpyBBB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[+] plusIBI(int x, bool[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[+] eqCCB(char[+] x, char[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : eqCCB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline bool[+] eqIIB(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sy = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : eqIIB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline int[+] mpyIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : mpyIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline bool[.] comaXBB(bool[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline int[*] indrfr(int fr, int[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline int[*] indrfr0(int[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline int[*] indrfr(int fr, int[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,0);
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline char[*] indrfr(int fr, char[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline char[*] indrfr0(char[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, ' ');
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline char[*] indrfr(int fr, char[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,' ');
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline bool[*] indrfr(int fr, bool[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, false);
 z = with {
        (. <= iv <= .)
                : indrfr0(X[iv], I);
        } : genarray(frameshape, cell);
 return(z);
}

inline bool[*] indrfr0(bool[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, false);
 z = with {
        (. <= iv <= .)
                : sel( I[iv], X);
        } : genarray(shape(I), cell);
 return(z);
}



inline bool[*] indrfr(int fr, bool[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,false);
 z = with {
        (. <= iv <= .)
                : sel( I, X[iv]);
        } : genarray(frameshape, cell);
 return(z);
}


inline int DFLOOR(double y, double QUADct)
{ /* Fuzzy floor */
  /* Definition taken from SHARP APL Refman May 1991, p.6-23
   * floor:  n <- (signum y) times nofuzzfloor 0.5+abs y)
   *         z <- n-(QUADct times 1 max abs y)<(n-y)
   * If you want a double result,  write: "y - 1| y".
   */
   n = tod(floor(0.5+fabs(y)));
   if (y < 0.0)
        n = -n;
   else if (0.0 == y)
        n = 0.0;
   range = fabs(y);
   if (1.0 > range)
        range = 1.0;
   fuzzlim = QUADct*range;
   ny = n-y;
   if (fuzzlim < ny)
        z = n - 1.0;
   else
        z = n;
   return(toi(z));
}

inline int V2O( int[.] shp, int[.] iv)
{ /* Vector iv to offset into array of shape shp */
  /* See V2O.dws workspace */
  offset = 0;
  wt = 1;
  for( i=shape(shp)[0]-1; i>=0; i--) {
    offset = offset + ( wt * iv[i]);
    wt = wt * shp[i];
  }
  return( offset);
}

inline int[.] O2V( int[.] shp, int offset)
{ /* Offset into array of shape shp to index vector */
  /* See V2O.dws workspace */
  iv = genarray( shape(shp), 1);
  wts = iv;
  for( i=shape(shp)[0]-2; i>=0; i--) {
    wts[i] = wts[i+1] * shp[i+1];
  }

  for( i=shape(shp)[0]-1; i>=0; i--) {
    iv[i] = _aplmod_SxS_( offset/wts[i], shp[i]);
    offset = offset - (iv[i]*wts[i]);
  }
  return( iv);
}

inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

inline int ABC(int I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[scalarI] & indexed assign */
 z = I;
 return(z);
}

inline int[+] ABC(int[+] I, int Xshape)
{ /* (OLD) Array bounds check for indexed ref X[nonscalarI] & indexed assign */
 z = I;
 return(z);
}

inline int[+] TRANSPOSE(int[+] y)
{ /* Generic monadic transpose */
  z = with {
        ( . <= iv <= .)
                : y[reverse( iv)];
        }: genarray( reverse( shape(y)), 0);
  return(z);
}

inline bool[+] TRANSPOSE(bool[+] y)
{ /* Generic monadic transpose */
  z = with {
        ( . <= iv <= .)
                : y[reverse( iv)];
        }: genarray( reverse( shape(y)), false);
  return(z);
}

inline int plusslXBIFOLD(bool[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : BtoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline int maxslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( maxIII, ItoI(minint()));
  return(z);
}


inline int minslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( minIII, ItoI(maxint()));
  return(z);
}


inline bool maxslXBBQUICKSTOP(bool[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : BtoB(y[iv]);
        } : foldfix( maxBBB, ItoB(0), ItoB(1));
  return(z);
}


inline bool minslXBBQUICKSTOP(bool[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : BtoB(y[iv]);
        } : foldfix( minBBB, ItoB(1), ItoB(0));
  return(z);
}


inline bool eqIIB(int x, int y)
{ /* A=B on non-doubles */
 return(ItoI(x) == ItoI(y));
}

inline int minIII(int x, int y)
{ /* x min y */
 return (min(ItoI(x),ItoI(y)));
}

inline bool maxBBB(bool x, bool y)
{ return (x&y);
}

inline bool minBBB(bool x, bool y)
{ return (x&y);
}

inline bool[+] eqCCB(char x, char[+] y)
{ /* SxA scalar function */
  xel = toC(x);
  z = with {
     ( . <= iv <= .) {
              yel = toC(y[iv]);
                    } : eqCCB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] eqIIB(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : eqIIB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] eqIIB(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : eqIIB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline char[.] DthornIntIIC(int[.] wp, int y ,int QUADio)
{ 
/*
 ?
*/
A_72= ABC(toi(false)-QUADio,shape(wp)[0]);
A_74=wp[[A_72]];
 w_0=( A_74);
 A_76= ABC(toi(true)-QUADio,shape(wp)[0]);
A_78=wp[[A_76]];
 p_0=( A_78);
 QUADct_0=toD(( false));
 A_81=rhoICC(w_0,' ');
 r_0=( A_81);
 // dsf scalar(s)
A_83=barIBI(w_0,true);
 A_84= ABC(toi(A_83)-QUADio,shape(r_0)[0]);
A_86=inds0(r_0,A_84,'0');
 r_1=( A_86);
 // dsf scalar(s)
A_89=ltIBB(y,false);
 sig_0=( A_89);
 A_91= ABC(toi(sig_0)-QUADio,shape([-1, 1])[0]);
A_93=[-1, 1][[A_91]];
 // dsf scalar(s)
A_94=mpyIII(y,A_93);
 cury_0=( A_94);
 ld_0=( false);
 digits_0=( ['0','1','2','3','4','5','6','7','8','9']);
 A_99=iotaXII( w_0,QUADio);
 A_100=rotrXII( A_99);
 A_CTR101_= 0;
A_CTR101z_ = (shape(A_100)[[0]])-1;
r_3=toC(r_1);
ld_2=toI(ld_0);
cury_2=toI(cury_0);
digits_2=toC(digits_0);
for(; A_CTR101_ <= A_CTR101z_; A_CTR101_++){
i_0 = A_100[[A_CTR101_]];
 // dsf scalar(s)
A_106=divIID(cury_2,10);
 A_108=maxXDI( A_106,QUADct_0);
 nexty_0=( A_108);
 // dsf scalar(s)
A_111=neIBB(cury_2,false);
 // dsf scalar(s)
A_113=barIBI(i_0,true);
 A_114=comaIII(ld_2,A_113);
 A_112= ABC(toi(A_111)-QUADio,shape(A_114)[0]);
A_116=A_114[[A_112]];
 ld_2=( A_116);
 // dsf scalar(s)
A_118=mpyIII(nexty_0,10);
 // dsf Scalar & clique
A_119=barIII(cury_2,A_118);
 A_120=modXII( A_119);
 dig_0=( A_120);
 A_122= ABC(toi(dig_0)-QUADio,shape(digits_2)[0]);
A_124=digits_2[[A_122]];
 A_125= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_127=inds0(r_3,A_125,A_124);
 r_3=( A_127);
 cury_2=( nexty_0);
 // dsf scalar(s)
A_131=eqIBB(nexty_0,false);
 A_133= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_135=digits_2[[A_133]];
 A_136=comaCCC(A_135,' ');
 A_132= ABC(toi(A_131)-QUADio,shape(A_136)[0]);
A_138=A_136[[A_132]];
 A_139= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_141=inds0(digits_2,A_139,A_138);
 digits_2=( A_141);
 }
 // dsf scalar(s)
A_144=maxBII(false,ld_2);
 ld_3=( A_144);
 A_147= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_149=r_3[[A_147]];
 A_150=comaCCC(A_149,'-');
 A_146= ABC(toi(sig_0)-QUADio,shape(A_150)[0]);
A_152=A_150[[A_146]];
 A_153= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_155=inds0(r_3,A_153,A_152);
 r_4=( A_155);
 A_157=rhoXCI( r_4);
 // dsf scalar(s)
A_159=neIBB(cury_2,false);
 // dsf scalar(s)
A_160=mpyBII(A_159,A_157);
 A_162=iotaXII( A_160,QUADio);
 A_163= ABC(toi(A_162)-QUADio,shape(r_4)[0]);
A_165=inds1(r_4,A_163,'*');
 r_5=( A_165);
 return(r_5);
}

inline bool matchnegCCB(char[.] x, char[.] y,int QUADio)
{ 
/*
 ?
*/
A_27=comaXCC( x);
 rx_0=( A_27);
 A_29=rhoXCI( rx_0);
 A_31=iotaXII( A_29,QUADio);
 // dsf scalar(s)
A_33=eqCCB(rx_0,'\x2d');
 A_34=slBII(A_33,A_31);
 A_35= ABC(toi(A_34)-QUADio,shape(rx_0)[0]);
A_37=inds1(rx_0,A_35,'-');
rx_1=( A_37);
 A_39=comaXCC( y);
 ry_0=( A_39);
 A_41=rhoXCI( ry_0);
 A_43=iotaXII( A_41,QUADio);
 // dsf scalar(s)
A_45=eqCCB(ry_0,'\x2d');
 A_46=slBII(A_45,A_43);
 A_47= ABC(toi(A_46)-QUADio,shape(ry_0)[0]);
A_49=inds1(ry_0,A_47,'-');
ry_1=( A_49);
 A_52=sameCCB(rx_1,ry_1);
 A_53=rhoXCI( y);
 A_54=rhoXCI( x);
 A_56=sameIIB(A_54,A_53);
 // dsf scalar(s)
A_57=andBBB(A_56,A_52);
 r_0=( A_57);
 return(r_0);
}

inline int[.] PmtlXII(int[.] y )
{ 
/*
 ?
*/
A_21=rhoIII(9,10);
 A_22=comaBII(true,A_21);
 A_23=mpybslXII( A_22);
 Pten_0=( A_23);
 A_28=jotdotgeIIB(y,Pten_0);
 A_36=plusslXBIFOLD( A_28);
 r_0=( A_36);
 return(r_0);
}

inline char[.] thintIIC(int PP, int y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=slBII(true,y);
 y_0=( A_65);
 A_67=rhoXII( y_0);
 A_68=takeIII(-1,A_67);
 A_69=rhoXII( y_0);
 A_70=dropIII(-1,A_69);
 A_71=mpyslXIIQUICKSTOP( A_70);
 A_75=comaIII(A_71,A_68);
 A_76=rhoIII(A_75,y_0);
 m_0=( A_76);
 A_78=modXII( m_0);
 A_79=maxsl1XIIFOLD( A_78);
 // dsf scalar(s)
A_83=maxIII(2,A_79);
 A_84=PmtlXII( A_83);
 widths_0=( A_84);
 A_86=minsl1XIIFOLD( m_0);
 maxneg_0=( A_86);
 // dsf scalar(s)
A_92=ltIBB(maxneg_0,false);
 neg_0=( A_92);
 A_94=modXII( maxneg_0);
 // dsf scalar(s)
A_95=maxIII(2,A_94);
 A_96=PmtlXII( A_95);
 maxneg_1=( A_96);
 // dsf clique
A_99=geIIB(maxneg_1,widths_0);
 // dsf Check needed
A_100=mpyBBB(neg_0,A_99);
 // dsf Check needed
A_101=plusIBI(widths_0,A_100);
 widths_1=( A_101);
 A_103=rhoXII( y_0);
 A_104=rhoIII(A_103,widths_1);
 A_105=comaXII( A_104);
 w_0=( A_105);
 // dsf scalar(s)
A_107=plusIBI(widths_1,true);
 A_108=comaBII(false,A_107);
 A_109=plusbslXII( A_108);
 psw_0=( A_109);
 // dsf scalar(s)
A_114=plusIBI(widths_1,true);
 A_115=plusslXIIFOLD( A_114);
 // dsf scalar(s)
A_119=plusIII(-1,A_115);
 A_121=rhoXII( m_0);
 A_120= ABC(toi(false)-QUADio,shape(A_121)[0]);
A_123=A_121[[A_120]];
 A_124=comaIII(A_123,A_119);
 shpz_0=( A_124);
 A_126=rhoICC(shpz_0,' ');
 r_0=( A_126);
 A_129=rhoXII( m_0);
 A_128= ABC(toi(false)-QUADio,shape(A_129)[0]);
A_131=A_129[[A_128]];
 A_133=iotaXII( A_131,QUADio);
 A_CTR134_= 0;
A_CTR134z_ = (shape(A_133)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR134_ <= A_CTR134z_; A_CTR134_++){
i_0 = A_133[[A_CTR134_]];
 A_137=rhoXII( m_0);
 A_136= ABC(toi(true)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_136]];
 A_141=iotaXII( A_139,QUADio);
 A_CTR142_= 0;
A_CTR142z_ = (shape(A_141)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR142_ <= A_CTR142z_; A_CTR142_++){
j_0 = A_141[[A_CTR142_]];
 A_145= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_144= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_147=m_0[[A_145,A_144]];
 A_148= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_150=w_0[[A_148]];
 A_151=comaIBI(A_150,false);
 A_153=DthornIntIIC(A_151,A_147,QUADio);
 A_154= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_156=w_0[[A_154]];
 A_158=iotaXII( A_156,QUADio);
 A_159= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_161=psw_0[[A_159]];
 // dsf scalar(s)
A_162=plusIII(A_161,A_158);
 A_164= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_163= ABC(toi(A_162)-QUADio,shape(r_3)[1]);
A_166=inds01(r_3,A_164,A_163,A_153);
 r_3=( A_166);
 }
 }
 A_170=rhoXCI( r_3);
 A_171=takeIII(-1,A_170);
 A_172=rhoXII( y_0);
 A_173=dropIII(-1,A_172);
 A_174=comaIII(A_173,A_171);
 A_175=rhoICC(A_174,r_3);
 r_4=( A_175);
 return(r_4);
}

inline bool[.] testthornXIB(int PP,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=thrnXIC( 2,QUADpp_0);
 A_67=thintIIC(QUADpp_0,2,QUADio);
 A_69=matchnegCCB(A_67,A_65,QUADio);
 r_0=( A_69);
 A_72=thrnXIC( -2,QUADpp_0);
 A_74=thintIIC(QUADpp_0,-2,QUADio);
 A_76=matchnegCCB(A_74,A_72,QUADio);
 A_77=comaBBB(r_0,A_76);
 r_1=( A_77);
 A_80=thrnXBC( false,QUADpp_0);
 A_82=thintCLONE6IBC(QUADpp_0,false,QUADio);
 A_84=matchnegCCB(A_82,A_80,QUADio);
 A_85=comaBBB(r_1,A_84);
 r_2=( A_85);
 A_87=comaXII( -13);
 A_89=thrnXIC( A_87,QUADpp_0);
 A_90=comaXII( -13);
 A_92=thintCLONE7IIC(QUADpp_0,A_90,QUADio);
 A_94=matchnegCCB(A_92,A_89,QUADio);
 A_95=comaBBB(r_2,A_94);
 r_3=( A_95);
 A_98=iotaXII( 4,QUADio);
 A_99=jotdotmpyIII([10, 199],A_98);
 A_106=rhoIII([2, 4],A_99);
 m_0=( A_106);
 A_109=thrnXIC( A_106,QUADpp_0);
 A_111=thintCLONE8IIC(QUADpp_0,m_0,QUADio);
 A_113=matchnegCLONE9CCB(A_111,A_109,QUADio);
 A_114=comaBBB(r_3,A_113);
 r_4=( A_114);
 A_117=thrnXIC( -123,QUADpp_0);
 A_119=thintIIC(QUADpp_0,-123,QUADio);
 A_121=matchnegCCB(A_119,A_117,QUADio);
 A_122=comaBBB(r_4,A_121);
 r_5=( A_122);
 twop31m1_0=( 2147483647);
 A_126=thrnXIC( twop31m1_0,QUADpp_0);
 A_128=thintIIC(QUADpp_0,twop31m1_0,QUADio);
 A_130=matchnegCCB(A_128,A_126,QUADio);
 A_131=comaBBB(r_5,A_130);
 r_6=( A_131);
 A_134=iotaXII( 10,QUADio);
 // dsf scalar(s)
A_135=plusIII(-2,A_134);
 A_137=thrnXIC( A_135,QUADpp_0);
 A_139=iotaXII( 10,QUADio);
 // dsf scalar(s)
A_140=plusIII(-2,A_139);
 A_142=thintCLONE10IIC(QUADpp_0,A_140,QUADio);
 A_144=matchnegCCB(A_142,A_137,QUADio);
 A_145=comaBBB(r_6,A_144);
 r_7=( A_145);
 A_148=iotaXII( 999,QUADio);
 // dsf scalar(s)
A_149=plusIII(-20,A_148);
 A_150=rhoIII([2, 3, 4, 5],A_149);
 m_1=( A_150);
 A_153=thrnXIC( m_1,QUADpp_0);
 A_155=thintCLONE11IIC(QUADpp_0,m_1,QUADio);
 A_157=matchnegCLONE12CCB(A_155,A_153,QUADio);
 A_158=comaBBB(r_7,A_157);
 r_8=( A_158);
 A_160= ABC(toi(false)-QUADio,shape(m_1)[3]);
A_165=indsxxx0(m_1,A_160,1000000000);
m_2=( A_165);
 A_168=thrnXIC( m_2,QUADpp_0);
 A_170=thintCLONE13IIC(QUADpp_0,m_2,QUADio);
 A_172=matchnegCLONE14CCB(A_170,A_168,QUADio);
 A_173=comaBBB(r_8,A_172);
 r_9=( A_173);
 return(r_9);
}

inline int UTThornInt_testXXI()
{ 
/*
 ?
*/
QUADio_0=toI(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 QUADio_1=toI(( false));
 QUADrl_1=( 16807);
 QUADpp_1=( 16);
 QUADpw_1=( 80);
 A_49=testthornXIB( QUADpp_1,QUADio_1);
 r_0=( A_49);
 A_53=quadXBB( A_49,QUADpp_1,QUADpw_1);
 A_55=testthornXIB( 5,QUADio_1);
 A_56=comaBBB(r_0,A_55);
 r_1=( A_56);
 A_60=quadXBB( A_56,QUADpp_1,QUADpw_1);
 A_61=andslXBBQUICKSTOP( r_1);
 // dsf scalar(s)
A_65=barBBI(true,A_61);
r_2=( A_65);
 A_69=quadXII( r_2,QUADpp_1,QUADpw_1);
 return(r_2);
}

inline char[.] thintCLONE6IBC(int PP, bool y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=slBBB(true,y);
 y_0=( A_65);
 A_67=rhoXBI( y_0);
 A_68=takeIII(-1,A_67);
 A_69=rhoXBI( y_0);
 A_70=dropIII(-1,A_69);
 A_71=mpyslXIIQUICKSTOP( A_70);
 A_75=comaIII(A_71,A_68);
 A_76=rhoIBB(A_75,y_0);
 m_0=( A_76);
 A_78=modXBB( m_0);
 A_79=maxsl1XBBQUICKSTOP( A_78);
 // dsf scalar(s)
A_83=maxIBI(2,A_79);
 A_84=PmtlXII( A_83);
 widths_0=( A_84);
 A_86=minsl1XBBQUICKSTOP( m_0);
 maxneg_0=( A_86);
 // dsf scalar(s)
A_92=ltBBB(maxneg_0,false);
 neg_0=( A_92);
 A_94=modXBB( maxneg_0);
 // dsf scalar(s)
A_95=maxIBI(2,A_94);
 A_96=PmtlXII( A_95);
 maxneg_1=( A_96);
 // dsf clique
A_99=geIIB(maxneg_1,widths_0);
 // dsf Check needed
A_100=mpyBBB(neg_0,A_99);
 // dsf Check needed
A_101=plusIBI(widths_0,A_100);
 widths_1=( A_101);
 A_103=rhoXBI( y_0);
 A_104=rhoIII(A_103,widths_1);
 A_105=comaXII( A_104);
 w_0=( A_105);
 // dsf scalar(s)
A_107=plusIBI(widths_1,true);
 A_108=comaBII(false,A_107);
 A_109=plusbslXII( A_108);
 psw_0=( A_109);
 // dsf scalar(s)
A_114=plusIBI(widths_1,true);
 A_115=plusslXIIFOLD( A_114);
 // dsf scalar(s)
A_119=plusIII(-1,A_115);
 A_121=rhoXBI( m_0);
 A_120= ABC(toi(false)-QUADio,shape(A_121)[0]);
A_123=A_121[[A_120]];
 A_124=comaIII(A_123,A_119);
 shpz_0=( A_124);
 A_126=rhoICC(shpz_0,' ');
 r_0=( A_126);
 A_129=rhoXBI( m_0);
 A_128= ABC(toi(false)-QUADio,shape(A_129)[0]);
A_131=A_129[[A_128]];
 A_133=iotaXII( A_131,QUADio);
 A_CTR134_= 0;
A_CTR134z_ = (shape(A_133)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR134_ <= A_CTR134z_; A_CTR134_++){
i_0 = A_133[[A_CTR134_]];
 A_137=rhoXBI( m_0);
 A_136= ABC(toi(true)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_136]];
 A_141=iotaXII( A_139,QUADio);
 A_CTR142_= 0;
A_CTR142z_ = (shape(A_141)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR142_ <= A_CTR142z_; A_CTR142_++){
j_0 = A_141[[A_CTR142_]];
 A_145= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_144= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_147=m_0[[A_145,A_144]];
 A_148= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_150=w_0[[A_148]];
 A_151=comaIBI(A_150,false);
 A_153=DthornIntCLONE15IBC(A_151,A_147,QUADio);
 A_154= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_156=w_0[[A_154]];
 A_158=iotaXII( A_156,QUADio);
 A_159= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_161=psw_0[[A_159]];
 // dsf scalar(s)
A_162=plusIII(A_161,A_158);
 A_164= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_163= ABC(toi(A_162)-QUADio,shape(r_3)[1]);
A_166=inds01(r_3,A_164,A_163,A_153);
 r_3=( A_166);
 }
 }
 A_170=rhoXCI( r_3);
 A_171=takeIII(-1,A_170);
 A_172=rhoXBI( y_0);
 A_173=dropIII(-1,A_172);
 A_174=comaIII(A_173,A_171);
 A_175=rhoICC(A_174,r_3);
 r_4=( A_175);
 return(r_4);
}

inline char[.] thintCLONE7IIC(int PP, int[.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=slBII(true,y);
 y_0=( A_65);
 A_67=rhoXII( y_0);
 A_68=takeIII(-1,A_67);
 A_69=rhoXII( y_0);
 A_70=dropIII(-1,A_69);
 A_71=mpyslXIIQUICKSTOP( A_70);
 A_75=comaIII(A_71,A_68);
 A_76=rhoIII(A_75,y_0);
 m_0=( A_76);
 A_78=modXII( m_0);
 A_79=maxsl1XIIFOLD( A_78);
 // dsf scalar(s)
A_83=maxIII(2,A_79);
 A_84=PmtlXII( A_83);
 widths_0=( A_84);
 A_86=minsl1XIIFOLD( m_0);
 maxneg_0=( A_86);
 // dsf scalar(s)
A_92=ltIBB(maxneg_0,false);
 neg_0=( A_92);
 A_94=modXII( maxneg_0);
 // dsf scalar(s)
A_95=maxIII(2,A_94);
 A_96=PmtlXII( A_95);
 maxneg_1=( A_96);
 // dsf clique
A_99=geIIB(maxneg_1,widths_0);
 // dsf Check needed
A_100=mpyBBB(neg_0,A_99);
 // dsf Check needed
A_101=plusIBI(widths_0,A_100);
 widths_1=( A_101);
 A_103=rhoXII( y_0);
 A_104=rhoIII(A_103,widths_1);
 A_105=comaXII( A_104);
 w_0=( A_105);
 // dsf scalar(s)
A_107=plusIBI(widths_1,true);
 A_108=comaBII(false,A_107);
 A_109=plusbslXII( A_108);
 psw_0=( A_109);
 // dsf scalar(s)
A_114=plusIBI(widths_1,true);
 A_115=plusslXIIFOLD( A_114);
 // dsf scalar(s)
A_119=plusIII(-1,A_115);
 A_121=rhoXII( m_0);
 A_120= ABC(toi(false)-QUADio,shape(A_121)[0]);
A_123=A_121[[A_120]];
 A_124=comaIII(A_123,A_119);
 shpz_0=( A_124);
 A_126=rhoICC(shpz_0,' ');
 r_0=( A_126);
 A_129=rhoXII( m_0);
 A_128= ABC(toi(false)-QUADio,shape(A_129)[0]);
A_131=A_129[[A_128]];
 A_133=iotaXII( A_131,QUADio);
 A_CTR134_= 0;
A_CTR134z_ = (shape(A_133)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR134_ <= A_CTR134z_; A_CTR134_++){
i_0 = A_133[[A_CTR134_]];
 A_137=rhoXII( m_0);
 A_136= ABC(toi(true)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_136]];
 A_141=iotaXII( A_139,QUADio);
 A_CTR142_= 0;
A_CTR142z_ = (shape(A_141)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR142_ <= A_CTR142z_; A_CTR142_++){
j_0 = A_141[[A_CTR142_]];
 A_145= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_144= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_147=m_0[[A_145,A_144]];
 A_148= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_150=w_0[[A_148]];
 A_151=comaIBI(A_150,false);
 A_153=DthornIntIIC(A_151,A_147,QUADio);
 A_154= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_156=w_0[[A_154]];
 A_158=iotaXII( A_156,QUADio);
 A_159= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_161=psw_0[[A_159]];
 // dsf scalar(s)
A_162=plusIII(A_161,A_158);
 A_164= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_163= ABC(toi(A_162)-QUADio,shape(r_3)[1]);
A_166=inds01(r_3,A_164,A_163,A_153);
 r_3=( A_166);
 }
 }
 A_170=rhoXCI( r_3);
 A_171=takeIII(-1,A_170);
 A_172=rhoXII( y_0);
 A_173=dropIII(-1,A_172);
 A_174=comaIII(A_173,A_171);
 A_175=rhoICC(A_174,r_3);
 r_4=( A_175);
 return(r_4);
}

inline char[.,.] thintCLONE8IIC(int PP, int[.,.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=slBII(true,y);
 y_0=( A_65);
 A_67=rhoXII( y_0);
 A_68=takeIII(-1,A_67);
 A_69=rhoXII( y_0);
 A_70=dropIII(-1,A_69);
 A_71=mpyslXIIQUICKSTOP( A_70);
 A_75=comaIII(A_71,A_68);
 A_76=rhoIII(A_75,y_0);
 m_0=( A_76);
 A_78=modXII( m_0);
 A_79=maxsl1XIIFOLD( A_78);
 // dsf scalar(s)
A_83=maxIII(2,A_79);
 A_84=PmtlXII( A_83);
 widths_0=( A_84);
 A_86=minsl1XIIFOLD( m_0);
 maxneg_0=( A_86);
 // dsf scalar(s)
A_92=ltIBB(maxneg_0,false);
 neg_0=( A_92);
 A_94=modXII( maxneg_0);
 // dsf scalar(s)
A_95=maxIII(2,A_94);
 A_96=PmtlXII( A_95);
 maxneg_1=( A_96);
 // dsf clique
A_99=geIIB(maxneg_1,widths_0);
 // dsf Check needed
A_100=mpyBBB(neg_0,A_99);
 // dsf Check needed
A_101=plusIBI(widths_0,A_100);
 widths_1=( A_101);
 A_103=rhoXII( y_0);
 A_104=rhoIII(A_103,widths_1);
 A_105=comaXII( A_104);
 w_0=( A_105);
 // dsf scalar(s)
A_107=plusIBI(widths_1,true);
 A_108=comaBII(false,A_107);
 A_109=plusbslXII( A_108);
 psw_0=( A_109);
 // dsf scalar(s)
A_114=plusIBI(widths_1,true);
 A_115=plusslXIIFOLD( A_114);
 // dsf scalar(s)
A_119=plusIII(-1,A_115);
 A_121=rhoXII( m_0);
 A_120= ABC(toi(false)-QUADio,shape(A_121)[0]);
A_123=A_121[[A_120]];
 A_124=comaIII(A_123,A_119);
 shpz_0=( A_124);
 A_126=rhoICC(shpz_0,' ');
 r_0=( A_126);
 A_129=rhoXII( m_0);
 A_128= ABC(toi(false)-QUADio,shape(A_129)[0]);
A_131=A_129[[A_128]];
 A_133=iotaXII( A_131,QUADio);
 A_CTR134_= 0;
A_CTR134z_ = (shape(A_133)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR134_ <= A_CTR134z_; A_CTR134_++){
i_0 = A_133[[A_CTR134_]];
 A_137=rhoXII( m_0);
 A_136= ABC(toi(true)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_136]];
 A_141=iotaXII( A_139,QUADio);
 A_CTR142_= 0;
A_CTR142z_ = (shape(A_141)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR142_ <= A_CTR142z_; A_CTR142_++){
j_0 = A_141[[A_CTR142_]];
 A_145= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_144= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_147=m_0[[A_145,A_144]];
 A_148= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_150=w_0[[A_148]];
 A_151=comaIBI(A_150,false);
 A_153=DthornIntIIC(A_151,A_147,QUADio);
 A_154= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_156=w_0[[A_154]];
 A_158=iotaXII( A_156,QUADio);
 A_159= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_161=psw_0[[A_159]];
 // dsf scalar(s)
A_162=plusIII(A_161,A_158);
 A_164= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_163= ABC(toi(A_162)-QUADio,shape(r_3)[1]);
A_166=inds01(r_3,A_164,A_163,A_153);
 r_3=( A_166);
 }
 }
 A_170=rhoXCI( r_3);
 A_171=takeIII(-1,A_170);
 A_172=rhoXII( y_0);
 A_173=dropIII(-1,A_172);
 A_174=comaIII(A_173,A_171);
 A_175=rhoICC(A_174,r_3);
 r_4=( A_175);
 return(r_4);
}

inline bool matchnegCLONE9CCB(char[.,.] x, char[.,.] y,int QUADio)
{ 
/*
 ?
*/
A_27=comaXCC( x);
 rx_0=( A_27);
 A_29=rhoXCI( rx_0);
 A_31=iotaXII( A_29,QUADio);
 // dsf scalar(s)
A_33=eqCCB(rx_0,'\x2d');
 A_34=slBII(A_33,A_31);
 A_35= ABC(toi(A_34)-QUADio,shape(rx_0)[0]);
A_37=inds1(rx_0,A_35,'-');
rx_1=( A_37);
 A_39=comaXCC( y);
 ry_0=( A_39);
 A_41=rhoXCI( ry_0);
 A_43=iotaXII( A_41,QUADio);
 // dsf scalar(s)
A_45=eqCCB(ry_0,'\x2d');
 A_46=slBII(A_45,A_43);
 A_47= ABC(toi(A_46)-QUADio,shape(ry_0)[0]);
A_49=inds1(ry_0,A_47,'-');
ry_1=( A_49);
 A_52=sameCCB(rx_1,ry_1);
 A_53=rhoXCI( y);
 A_54=rhoXCI( x);
 A_56=sameIIB(A_54,A_53);
 // dsf scalar(s)
A_57=andBBB(A_56,A_52);
 r_0=( A_57);
 return(r_0);
}

inline char[.] thintCLONE10IIC(int PP, int[.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=slBII(true,y);
 y_0=( A_65);
 A_67=rhoXII( y_0);
 A_68=takeIII(-1,A_67);
 A_69=rhoXII( y_0);
 A_70=dropIII(-1,A_69);
 A_71=mpyslXIIQUICKSTOP( A_70);
 A_75=comaIII(A_71,A_68);
 A_76=rhoIII(A_75,y_0);
 m_0=( A_76);
 A_78=modXII( m_0);
 A_79=maxsl1XIIFOLD( A_78);
 // dsf scalar(s)
A_83=maxIII(2,A_79);
 A_84=PmtlXII( A_83);
 widths_0=( A_84);
 A_86=minsl1XIIFOLD( m_0);
 maxneg_0=( A_86);
 // dsf scalar(s)
A_92=ltIBB(maxneg_0,false);
 neg_0=( A_92);
 A_94=modXII( maxneg_0);
 // dsf scalar(s)
A_95=maxIII(2,A_94);
 A_96=PmtlXII( A_95);
 maxneg_1=( A_96);
 // dsf clique
A_99=geIIB(maxneg_1,widths_0);
 // dsf Check needed
A_100=mpyBBB(neg_0,A_99);
 // dsf Check needed
A_101=plusIBI(widths_0,A_100);
 widths_1=( A_101);
 A_103=rhoXII( y_0);
 A_104=rhoIII(A_103,widths_1);
 A_105=comaXII( A_104);
 w_0=( A_105);
 // dsf scalar(s)
A_107=plusIBI(widths_1,true);
 A_108=comaBII(false,A_107);
 A_109=plusbslXII( A_108);
 psw_0=( A_109);
 // dsf scalar(s)
A_114=plusIBI(widths_1,true);
 A_115=plusslXIIFOLD( A_114);
 // dsf scalar(s)
A_119=plusIII(-1,A_115);
 A_121=rhoXII( m_0);
 A_120= ABC(toi(false)-QUADio,shape(A_121)[0]);
A_123=A_121[[A_120]];
 A_124=comaIII(A_123,A_119);
 shpz_0=( A_124);
 A_126=rhoICC(shpz_0,' ');
 r_0=( A_126);
 A_129=rhoXII( m_0);
 A_128= ABC(toi(false)-QUADio,shape(A_129)[0]);
A_131=A_129[[A_128]];
 A_133=iotaXII( A_131,QUADio);
 A_CTR134_= 0;
A_CTR134z_ = (shape(A_133)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR134_ <= A_CTR134z_; A_CTR134_++){
i_0 = A_133[[A_CTR134_]];
 A_137=rhoXII( m_0);
 A_136= ABC(toi(true)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_136]];
 A_141=iotaXII( A_139,QUADio);
 A_CTR142_= 0;
A_CTR142z_ = (shape(A_141)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR142_ <= A_CTR142z_; A_CTR142_++){
j_0 = A_141[[A_CTR142_]];
 A_145= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_144= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_147=m_0[[A_145,A_144]];
 A_148= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_150=w_0[[A_148]];
 A_151=comaIBI(A_150,false);
 A_153=DthornIntIIC(A_151,A_147,QUADio);
 A_154= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_156=w_0[[A_154]];
 A_158=iotaXII( A_156,QUADio);
 A_159= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_161=psw_0[[A_159]];
 // dsf scalar(s)
A_162=plusIII(A_161,A_158);
 A_164= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_163= ABC(toi(A_162)-QUADio,shape(r_3)[1]);
A_166=inds01(r_3,A_164,A_163,A_153);
 r_3=( A_166);
 }
 }
 A_170=rhoXCI( r_3);
 A_171=takeIII(-1,A_170);
 A_172=rhoXII( y_0);
 A_173=dropIII(-1,A_172);
 A_174=comaIII(A_173,A_171);
 A_175=rhoICC(A_174,r_3);
 r_4=( A_175);
 return(r_4);
}

inline char[.,.,.,.] thintCLONE11IIC(int PP, int[.,.,.,.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=slBII(true,y);
 y_0=( A_65);
 A_67=rhoXII( y_0);
 A_68=takeIII(-1,A_67);
 A_69=rhoXII( y_0);
 A_70=dropIII(-1,A_69);
 A_71=mpyslXIIQUICKSTOP( A_70);
 A_75=comaIII(A_71,A_68);
 A_76=rhoIII(A_75,y_0);
 m_0=( A_76);
 A_78=modXII( m_0);
 A_79=maxsl1XIIFOLD( A_78);
 // dsf scalar(s)
A_83=maxIII(2,A_79);
 A_84=PmtlXII( A_83);
 widths_0=( A_84);
 A_86=minsl1XIIFOLD( m_0);
 maxneg_0=( A_86);
 // dsf scalar(s)
A_92=ltIBB(maxneg_0,false);
 neg_0=( A_92);
 A_94=modXII( maxneg_0);
 // dsf scalar(s)
A_95=maxIII(2,A_94);
 A_96=PmtlXII( A_95);
 maxneg_1=( A_96);
 // dsf clique
A_99=geIIB(maxneg_1,widths_0);
 // dsf Check needed
A_100=mpyBBB(neg_0,A_99);
 // dsf Check needed
A_101=plusIBI(widths_0,A_100);
 widths_1=( A_101);
 A_103=rhoXII( y_0);
 A_104=rhoIII(A_103,widths_1);
 A_105=comaXII( A_104);
 w_0=( A_105);
 // dsf scalar(s)
A_107=plusIBI(widths_1,true);
 A_108=comaBII(false,A_107);
 A_109=plusbslXII( A_108);
 psw_0=( A_109);
 // dsf scalar(s)
A_114=plusIBI(widths_1,true);
 A_115=plusslXIIFOLD( A_114);
 // dsf scalar(s)
A_119=plusIII(-1,A_115);
 A_121=rhoXII( m_0);
 A_120= ABC(toi(false)-QUADio,shape(A_121)[0]);
A_123=A_121[[A_120]];
 A_124=comaIII(A_123,A_119);
 shpz_0=( A_124);
 A_126=rhoICC(shpz_0,' ');
 r_0=( A_126);
 A_129=rhoXII( m_0);
 A_128= ABC(toi(false)-QUADio,shape(A_129)[0]);
A_131=A_129[[A_128]];
 A_133=iotaXII( A_131,QUADio);
 A_CTR134_= 0;
A_CTR134z_ = (shape(A_133)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR134_ <= A_CTR134z_; A_CTR134_++){
i_0 = A_133[[A_CTR134_]];
 A_137=rhoXII( m_0);
 A_136= ABC(toi(true)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_136]];
 A_141=iotaXII( A_139,QUADio);
 A_CTR142_= 0;
A_CTR142z_ = (shape(A_141)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR142_ <= A_CTR142z_; A_CTR142_++){
j_0 = A_141[[A_CTR142_]];
 A_145= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_144= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_147=m_0[[A_145,A_144]];
 A_148= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_150=w_0[[A_148]];
 A_151=comaIBI(A_150,false);
 A_153=DthornIntIIC(A_151,A_147,QUADio);
 A_154= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_156=w_0[[A_154]];
 A_158=iotaXII( A_156,QUADio);
 A_159= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_161=psw_0[[A_159]];
 // dsf scalar(s)
A_162=plusIII(A_161,A_158);
 A_164= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_163= ABC(toi(A_162)-QUADio,shape(r_3)[1]);
A_166=inds01(r_3,A_164,A_163,A_153);
 r_3=( A_166);
 }
 }
 A_170=rhoXCI( r_3);
 A_171=takeIII(-1,A_170);
 A_172=rhoXII( y_0);
 A_173=dropIII(-1,A_172);
 A_174=comaIII(A_173,A_171);
 A_175=rhoICC(A_174,r_3);
 r_4=( A_175);
 return(r_4);
}

inline bool matchnegCLONE12CCB(char[.,.,.,.] x, char[.,.,.,.] y,int QUADio)
{ 
/*
 ?
*/
A_27=comaXCC( x);
 rx_0=( A_27);
 A_29=rhoXCI( rx_0);
 A_31=iotaXII( A_29,QUADio);
 // dsf scalar(s)
A_33=eqCCB(rx_0,'\x2d');
 A_34=slBII(A_33,A_31);
 A_35= ABC(toi(A_34)-QUADio,shape(rx_0)[0]);
A_37=inds1(rx_0,A_35,'-');
rx_1=( A_37);
 A_39=comaXCC( y);
 ry_0=( A_39);
 A_41=rhoXCI( ry_0);
 A_43=iotaXII( A_41,QUADio);
 // dsf scalar(s)
A_45=eqCCB(ry_0,'\x2d');
 A_46=slBII(A_45,A_43);
 A_47= ABC(toi(A_46)-QUADio,shape(ry_0)[0]);
A_49=inds1(ry_0,A_47,'-');
ry_1=( A_49);
 A_52=sameCCB(rx_1,ry_1);
 A_53=rhoXCI( y);
 A_54=rhoXCI( x);
 A_56=sameIIB(A_54,A_53);
 // dsf scalar(s)
A_57=andBBB(A_56,A_52);
 r_0=( A_57);
 return(r_0);
}

inline char[.,.,.,.] thintCLONE13IIC(int PP, int[.,.,.,.] y ,int QUADio)
{ 
/*
 ?
*/
QUADpp_0=( PP);
 A_65=slBII(true,y);
 y_0=( A_65);
 A_67=rhoXII( y_0);
 A_68=takeIII(-1,A_67);
 A_69=rhoXII( y_0);
 A_70=dropIII(-1,A_69);
 A_71=mpyslXIIQUICKSTOP( A_70);
 A_75=comaIII(A_71,A_68);
 A_76=rhoIII(A_75,y_0);
 m_0=( A_76);
 A_78=modXII( m_0);
 A_79=maxsl1XIIFOLD( A_78);
 // dsf scalar(s)
A_83=maxIII(2,A_79);
 A_84=PmtlXII( A_83);
 widths_0=( A_84);
 A_86=minsl1XIIFOLD( m_0);
 maxneg_0=( A_86);
 // dsf scalar(s)
A_92=ltIBB(maxneg_0,false);
 neg_0=( A_92);
 A_94=modXII( maxneg_0);
 // dsf scalar(s)
A_95=maxIII(2,A_94);
 A_96=PmtlXII( A_95);
 maxneg_1=( A_96);
 // dsf clique
A_99=geIIB(maxneg_1,widths_0);
 // dsf Check needed
A_100=mpyBBB(neg_0,A_99);
 // dsf Check needed
A_101=plusIBI(widths_0,A_100);
 widths_1=( A_101);
 A_103=rhoXII( y_0);
 A_104=rhoIII(A_103,widths_1);
 A_105=comaXII( A_104);
 w_0=( A_105);
 // dsf scalar(s)
A_107=plusIBI(widths_1,true);
 A_108=comaBII(false,A_107);
 A_109=plusbslXII( A_108);
 psw_0=( A_109);
 // dsf scalar(s)
A_114=plusIBI(widths_1,true);
 A_115=plusslXIIFOLD( A_114);
 // dsf scalar(s)
A_119=plusIII(-1,A_115);
 A_121=rhoXII( m_0);
 A_120= ABC(toi(false)-QUADio,shape(A_121)[0]);
A_123=A_121[[A_120]];
 A_124=comaIII(A_123,A_119);
 shpz_0=( A_124);
 A_126=rhoICC(shpz_0,' ');
 r_0=( A_126);
 A_129=rhoXII( m_0);
 A_128= ABC(toi(false)-QUADio,shape(A_129)[0]);
A_131=A_129[[A_128]];
 A_133=iotaXII( A_131,QUADio);
 A_CTR134_= 0;
A_CTR134z_ = (shape(A_133)[[0]])-1;
r_3=toC(r_0);
for(; A_CTR134_ <= A_CTR134z_; A_CTR134_++){
i_0 = A_133[[A_CTR134_]];
 A_137=rhoXII( m_0);
 A_136= ABC(toi(true)-QUADio,shape(A_137)[0]);
A_139=A_137[[A_136]];
 A_141=iotaXII( A_139,QUADio);
 A_CTR142_= 0;
A_CTR142z_ = (shape(A_141)[[0]])-1;
r_3=toC(r_3);
for(; A_CTR142_ <= A_CTR142z_; A_CTR142_++){
j_0 = A_141[[A_CTR142_]];
 A_145= ABC(toi(i_0)-QUADio,shape(m_0)[0]);
A_144= ABC(toi(j_0)-QUADio,shape(m_0)[1]);
A_147=m_0[[A_145,A_144]];
 A_148= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_150=w_0[[A_148]];
 A_151=comaIBI(A_150,false);
 A_153=DthornIntIIC(A_151,A_147,QUADio);
 A_154= ABC(toi(j_0)-QUADio,shape(w_0)[0]);
A_156=w_0[[A_154]];
 A_158=iotaXII( A_156,QUADio);
 A_159= ABC(toi(j_0)-QUADio,shape(psw_0)[0]);
A_161=psw_0[[A_159]];
 // dsf scalar(s)
A_162=plusIII(A_161,A_158);
 A_164= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_163= ABC(toi(A_162)-QUADio,shape(r_3)[1]);
A_166=inds01(r_3,A_164,A_163,A_153);
 r_3=( A_166);
 }
 }
 A_170=rhoXCI( r_3);
 A_171=takeIII(-1,A_170);
 A_172=rhoXII( y_0);
 A_173=dropIII(-1,A_172);
 A_174=comaIII(A_173,A_171);
 A_175=rhoICC(A_174,r_3);
 r_4=( A_175);
 return(r_4);
}

inline bool matchnegCLONE14CCB(char[.,.,.,.] x, char[.,.,.,.] y,int QUADio)
{ 
/*
 ?
*/
A_27=comaXCC( x);
 rx_0=( A_27);
 A_29=rhoXCI( rx_0);
 A_31=iotaXII( A_29,QUADio);
 // dsf scalar(s)
A_33=eqCCB(rx_0,'\x2d');
 A_34=slBII(A_33,A_31);
 A_35= ABC(toi(A_34)-QUADio,shape(rx_0)[0]);
A_37=inds1(rx_0,A_35,'-');
rx_1=( A_37);
 A_39=comaXCC( y);
 ry_0=( A_39);
 A_41=rhoXCI( ry_0);
 A_43=iotaXII( A_41,QUADio);
 // dsf scalar(s)
A_45=eqCCB(ry_0,'\x2d');
 A_46=slBII(A_45,A_43);
 A_47= ABC(toi(A_46)-QUADio,shape(ry_0)[0]);
A_49=inds1(ry_0,A_47,'-');
ry_1=( A_49);
 A_52=sameCCB(rx_1,ry_1);
 A_53=rhoXCI( y);
 A_54=rhoXCI( x);
 A_56=sameIIB(A_54,A_53);
 // dsf scalar(s)
A_57=andBBB(A_56,A_52);
 r_0=( A_57);
 return(r_0);
}

inline char[.] DthornIntCLONE15IBC(int[.] wp, bool y ,int QUADio)
{ 
/*
 ?
*/
A_72= ABC(toi(false)-QUADio,shape(wp)[0]);
A_74=wp[[A_72]];
 w_0=( A_74);
 A_76= ABC(toi(true)-QUADio,shape(wp)[0]);
A_78=wp[[A_76]];
 p_0=( A_78);
 QUADct_0=toD(( false));
 A_81=rhoICC(w_0,' ');
 r_0=( A_81);
 // dsf scalar(s)
A_83=barIBI(w_0,true);
 A_84= ABC(toi(A_83)-QUADio,shape(r_0)[0]);
A_86=inds0(r_0,A_84,'0');
 r_1=( A_86);
 // dsf scalar(s)
A_89=ltBBB(y,false);
 sig_0=( A_89);
 A_91= ABC(toi(sig_0)-QUADio,shape([-1, 1])[0]);
A_93=[-1, 1][[A_91]];
 // dsf scalar(s)
A_94=mpyBII(y,A_93);
 cury_0=( A_94);
 ld_0=( false);
 digits_0=( ['0','1','2','3','4','5','6','7','8','9']);
 A_99=iotaXII( w_0,QUADio);
 A_100=rotrXII( A_99);
 A_CTR101_= 0;
A_CTR101z_ = (shape(A_100)[[0]])-1;
r_3=toC(r_1);
ld_2=toI(ld_0);
cury_2=toI(cury_0);
digits_2=toC(digits_0);
for(; A_CTR101_ <= A_CTR101z_; A_CTR101_++){
i_0 = A_100[[A_CTR101_]];
 // dsf scalar(s)
A_106=divIID(cury_2,10);
 A_108=maxXDI( A_106,QUADct_0);
 nexty_0=( A_108);
 // dsf scalar(s)
A_111=neIBB(cury_2,false);
 // dsf scalar(s)
A_113=barIBI(i_0,true);
 A_114=comaIII(ld_2,A_113);
 A_112= ABC(toi(A_111)-QUADio,shape(A_114)[0]);
A_116=A_114[[A_112]];
 ld_2=( A_116);
 // dsf scalar(s)
A_118=mpyIII(nexty_0,10);
 // dsf Scalar & clique
A_119=barIII(cury_2,A_118);
 A_120=modXII( A_119);
 dig_0=( A_120);
 A_122= ABC(toi(dig_0)-QUADio,shape(digits_2)[0]);
A_124=digits_2[[A_122]];
 A_125= ABC(toi(i_0)-QUADio,shape(r_3)[0]);
A_127=inds0(r_3,A_125,A_124);
 r_3=( A_127);
 cury_2=( nexty_0);
 // dsf scalar(s)
A_131=eqIBB(nexty_0,false);
 A_133= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_135=digits_2[[A_133]];
 A_136=comaCCC(A_135,' ');
 A_132= ABC(toi(A_131)-QUADio,shape(A_136)[0]);
A_138=A_136[[A_132]];
 A_139= ABC(toi(false)-QUADio,shape(digits_2)[0]);
A_141=inds0(digits_2,A_139,A_138);
 digits_2=( A_141);
 }
 // dsf scalar(s)
A_144=maxBII(false,ld_2);
 ld_3=( A_144);
 A_147= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_149=r_3[[A_147]];
 A_150=comaCCC(A_149,'-');
 A_146= ABC(toi(sig_0)-QUADio,shape(A_150)[0]);
A_152=A_150[[A_146]];
 A_153= ABC(toi(ld_3)-QUADio,shape(r_3)[0]);
A_155=inds0(r_3,A_153,A_152);
 r_4=( A_155);
 A_157=rhoXCI( r_4);
 // dsf scalar(s)
A_159=neIBB(cury_2,false);
 // dsf scalar(s)
A_160=mpyBII(A_159,A_157);
 A_162=iotaXII( A_160,QUADio);
 A_163= ABC(toi(A_162)-QUADio,shape(r_4)[0]);
A_165=inds1(r_4,A_163,'*');
 r_5=( A_165);
 return(r_5);
}

