use Array: all;
use Numerical : all;
use StdIO : all;
use CommandLine: all;
use String: {tochar,sscanf};
use Bits: all;

/* Compiled by APEX Version: /home/apex/apex2003/wss/sac3002.dws2009-04-11 16:49:46.046 */
/*
% This is the APEX stdlib.sis include file.
% Standard equates and constants for APL compiler
% Also standard coercion functions
*/

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

inline double divXDD(double y)
{ return(1.0/tod(y));
}

inline double[+] modXDD(double[+] y)
{ /* Monadic scalar functions on array */
  z = with {
   ( . <= iv <= .)
                : modXDD(toD(y[iv]));
         } : genarray(shape(y), 0.0d);
  return(z);
}

inline double[+] divXDD(double[+] y)
{ /* Monadic scalar functions on array */
  z = with {
   ( . <= iv <= .)
                : divXDD(toD(y[iv]));
         } : genarray(shape(y), 0.0d);
  return(z);
}

inline int[+] barXII(int[+] y)
{ /* Monadic scalar functions on array */
  z = with {
   ( . <= iv <= .)
                : barXII(toI(y[iv]));
         } : genarray(shape(y), 0);
  return(z);
}

inline double divBBD(bool x, bool y)
{ dx = tod(x);
  dy = tod(y);
 if (dx == dy) 
     z = 1.0d;
  else 
    z = dx/dy;
  return(z);
}

inline bool eqDBB(double x, bool y, double QUADct)
{ /* A=B on doubles */
 return((toD(x) == toD(y)) || APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline double starIID(int x, int y)
{ return(pow(tod(x),tod(y)));
}

inline double mpyDDD(double x, double y)
{ return(toD(x)*toD(y));
}

inline bool leDDB(double x, double y, double QUADct)
{ /* Fuzzy <= */
 return((toD(x)<toD(y)) | APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline int plusIII(int x, int y)
{ return(toI(x)+toI(y));
}

inline double starDDD(double x, double y)
{ return(pow(tod(x),tod(y)));
}

inline bool leBDB(bool x, double y, double QUADct)
{ /* Fuzzy <= */
 return((toD(x)<toD(y)) | APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline int mpyIBI(int x, bool y)
{ return(toI(x)*toI(y));
}

inline int barBII(bool x, int y)
{ return(toI(x)-toI(y));
}

inline double mpyIDD(int x, double y)
{ return(toD(x)*toD(y));
}

inline double barDDD(double x, double y)
{ return(toD(x)-toD(y));
}

inline int plusIBI(int x, bool y)
{ return(toI(x)+toI(y));
}

inline bool eqDIB(double x, int y, double QUADct)
{ /* A=B on doubles */
 return((toD(x) == toD(y)) || APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline int plusBBI(bool x, bool y)
{ return(toI(x)+toI(y));
}

inline double[+] divDDD(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("divDDD(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : divDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline double[+] mpyDDD(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("mpyDDD(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : mpyDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline int[+] plusIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline double[+] starDID(double[+] x, int y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : starDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline int[+] plusIBI(int x, bool[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline double[+] mpyDDD(double x, double[+] y)
{ /* SxA scalar function */
  xel = toD(x);
  z = with {
     ( . <= iv <= .) {
              yel = toD(y[iv]);
                    } : mpyDDD(xel,yel);
  } : genarray(shape(y), 0.0d);
  return(z);
}


inline double[+] barDDD(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("barDDD(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : barDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline double[+] divDDD(double[+] x, double y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : divDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline int[.] rotrXII(int[.] y)
{ /* Vector reverse */
 n = shape(y);
 cell = 0;
 z = with {
         ( . <= iv <= .)
                : y[(n-1)-iv];
         } : genarray(n, cell);
 return(z);
}

inline double[.,.] tranXDD(double[.,.] y)
{ /* Transpose on rank-2 */
   z = { [i,j] -> y[j,i] };
       return(z);
}

inline double[.] comaXDD(double[+] y)
{ /* Ravel of anything with rank>1 */
     z = reshape([prod(shape(y))],y);
       return(z);
}

inline int[*] rhoCII(char[.] x, int[*] y)
{ /* Character-vector reshape anything. */
  /* Left argument must be empty vector! */
 if ( 0 != shape(x)[[0]]) {
   show(tochar("reshape domain error in rhoCII"));
 }
 z = reshape([prod(shape(y))], y);
 return(z[[0]]);
}

inline double[*] rhoIDD(int[.] x, double[+] y)
{ /* APEX vector x reshape, with item reuse */
  ix = toi(x);
  ry = comaXDD(y);
  zxrho = prod(ix); /* THIS NEEDS XRHO FOR CODE SAFETY!! */
  yxrho = shape(ry)[[0]];
  if( zxrho <= yxrho) { /* No element resuse case */
        z = take([zxrho],ry);
 } else {
        ncopies = zxrho/yxrho; /* # complete copies of y. */
        /* FIXME: y empty case !*/
        z = with {
          (. <= [i] <= .)
                        : y;
           } : genarray( [ncopies], y);
        /* Now append the leftover bits */
        z = comaXDD(z) ++ take([zxrho-(ncopies*yxrho)],ry);
 }
 return(reshape(ix,z));
}



inline int iotaDDI(double[.] x, double y,double QUADct,int QUADio)
{ /* Fuzzy Vector iota Scalar */
 sx = shape(x)[[0]];
 z = sx;
 for(i=0; i<sx; i++) {
   if (eqDDB(toD(x[[i]]),toD(y),QUADct)){
             z = i;
                 i = sx;
        }
 }
 return(z+QUADio);
}


inline bool[*] rhoIBB(int[.] x, bool y)
{ /* Vector reshape scalar to matrix) */
         zxrho = prod(toi(x)); /* Result element count */
       z = genarray([zxrho], y); /* allocate result */
        z = reshape(toi(x),z);
         return(z);
}

inline bool[*] rhoIBB(int[.] x, bool[+] y)
{ /* APEX vector x reshape, with item reuse */
  ix = toi(x);
  ry = comaXBB(y);
  zxrho = prod(ix); /* THIS NEEDS XRHO FOR CODE SAFETY!! */
  yxrho = shape(ry)[[0]];
  if( zxrho <= yxrho) { /* No element resuse case */
        z = take([zxrho],ry);
 } else {
        ncopies = zxrho/yxrho; /* # complete copies of y. */
        /* FIXME: y empty case !*/
        z = with {
          (. <= [i] <= .)
                        : y;
           } : genarray( [ncopies], y);
        /* Now append the leftover bits */
        z = comaXBB(z) ++ take([zxrho-(ncopies*yxrho)],ry);
 }
 return(reshape(ix,z));
}



inline int[.] rhoIII(int x, int y)
{ /* Scalar reshape scalar to vector) */
      z = genarray([toi(x)], y);
     return(z);
}

inline int[*] dropBII(bool x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[.] takeBII(bool x, int[.] y)
{ /* Scalar take vector */ 
  return(take([toi(x)], y));
}

inline int[.] takeIII(int x, int[.] y)
{ /* Scalar take vector */ 
  return(take([toi(x)], y));
}

inline double[.,.] takeIDD(int[.] x, double[.,.] y)
{ /* vector take matrix */
  return(take(toi(x),y));
}

inline double[*] dropIDD(int[.] x, double[*] y)
{ /* Vector drop non-scalar */
  /* FIXME: Assert  dim(y)  == shape(x)[0]; */
  /* e.g, (,5)drop iota 5  */
  return(drop(toi(x), y));
}

inline double[*] dropIDD(int x, double[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[*] dropIII(int x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}


inline double[.] takeIDD(int x, double y)
{ /* Scalar take scalar */
  return(take([toi(x)],[y]));
}

inline int[2]  rhoXBI(bool[.,.] y)
{ /* Shape of matrix (rank-2) */
 return(shape(y));
}

inline int[2]  rhoXDI(double[.,.] y)
{ /* Shape of matrix (rank-2) */
 return(shape(y));
}

inline int[.] iotaXII(int y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[.] iotaXII(int[1] y, int QUADio)
{ /* Index generator on 1-element vector */
 /* HELP! Needs length error check */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y[[0]]));
  return( z);
}

inline double[*] quadXDD(double[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
  show(y);
       return(y);
}
inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
  show(y);
       return(y);
}
inline int[.] comaIII(int[.] x, int[.] y)
{ /* VxV catenate first or last axis */
 return(toI(x)++toI(y));
}

inline int[2] comaIII(int x, int y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline int[.] comaBII(bool x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline double[.] comaDDD(double x, double[.] y)
{/* SxV catenate first (or last) axis */
 return([toD(x)]++toD(y));
}

inline int[.] comaIII(int x, int[.] y)
{/* SxV catenate first (or last) axis */
 return([toI(x)]++toI(y));
}

inline int[.] comaIBI(int[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toI(x)++[toI(y)]);
}

inline int[*] indr(int[+] X, int[+] I)
{ /* X[nonscalarI;;;] */
 defcell = genarray(drop([1],shape(X)),0);
 z = with {
  (. <= iv <= .)
                 : X[[I[iv]]];
  } : genarray(shape(I), defcell);
 return(z);
}





inline double[*] indr(double[+] X)
{ /* X[;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[;;j;]
   */
 return(X);
}



inline double[*] indr(double[+] X, int[+] I)
{ /* X[nonscalarI;;;] */
 defcell = genarray(drop([1],shape(X)),0.0d);
 z = with {
  (. <= iv <= .)
                 : X[[I[iv]]];
  } : genarray(shape(I), defcell);
 return(z);
}





inline double[*] indr(double[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline double[+] indsx1(double[+] X, int [+] I1, bool[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 for(i0=0; i0<shape(X)[[0]]; i0++){
 for(i1=0; i1<shape(I1)[[0]]; i1++){

 z[[i0,I1[[i1]]]]=tod(Y[[i0,i1]]);

 }
 }

 return(z);
}



inline int[+] inds1(int[+] X, int [+] I0, int[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = toi(X);
 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=toi(Y[[i0]]);

 }

 return(z);
}



inline double[+] indsx1(double[+] X, int [+] I1, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 for(i0=0; i0<shape(X)[[0]]; i0++){
 for(i1=0; i1<shape(I1)[[0]]; i1++){

 z[[i0,I1[[i1]]]]=tod(Y[[i0,i1]]);

 }
 }

 return(z);
}



inline double[+] inds1x(double[+] X, int [+] I0, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=tod(Y[[i0]]);

 }

 return(z);
}



inline double[+] inds11(double[+] X, int [+] I0,int [+] I1, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 for(i0=0; i0<shape(I0)[[0]]; i0++){
 for(i1=0; i1<shape(I1)[[0]]; i1++){

 z[[I0[[i0]],I1[[i1]]]]=tod(Y[[i0,i1]]);

 }
 }

 return(z);
}



inline double[+] inds00(double[+] X, int  I0,int  I1, double Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = tod(X);
 Y = Yin;

 
 z[[I0,I1]]=tod(Y);

 
 return(z);
}



inline double[+] inds0x(double[+] X, int  I0, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 
 z[[I0]]=tod(Y);

 
 return(z);
}



inline int CommandLineArgvXBI(bool y)
{ /* Get Command-line argument element #y as integer scalar */
  int z;
  junk, z = sscanf(argv(toi(y)), "%d");
  return( z);
}

inline double[*] jotdotmpyDDD(double [+] x, double [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), 0.0d);
 z = with {
  (. <= iv <= .) {
        xitem = toD(x[iv]);
         } : mpyDDD(xitem, toD(y));
  } : genarray(shape(x), cell);
 return(z);
}

inline bool[*] jotdoteqIIB(int [+] x, int [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), false);
 z = with {
  (. <= iv <= .) {
        xitem = toI(x[iv]);
         } : eqIIB(xitem, toI(y));
  } : genarray(shape(x), cell);
 return(z);
}

inline double[*] plusdotmpyDDDTRANSPOSE(double[.] x, double[*] y)
{ /* TRANSPOSE case of inner product z = vector_f.g y */
 yt = toD(TRANSPOSE(y));
 xct = toD(x);
 /* if (1 != shape(xct)[[0]]) FIXME; length error check */

 shp = drop([-1],shape(xct)) ++ drop([1], shape(y));
 z = with {
        (. <= iv <= .) {
               vx = xct[take([dim(x)-1], iv)];
                vy = yt[ reverse(take([1-dim(y)], iv))];
       } : plusslXDDFOLD(mpyDDDsl(vx,vy));
       } :genarray(shp, 0.0d);
 return(z);
}




inline double[+] maxslXDDFOLD(double[+] y)
{ /* last axis reduce rank-2 or greater matrix w/folding */
  sy = shape(y);
  zrho = drop([-1], sy);
  z = with {
        (. <= iv <= .)
               : maxslXDDFOLD(y[iv]);
   } : genarray(zrho, 0.0d);
  return(z);
}


inline double[.] maxsl1XDDFOLD(double[.,.] y)
{ /* first-axis reduce rank-2 matrix */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
  (. <= iv <= .)
                 : maxslXDDFOLD(yt[iv]);
    } : genarray(zrho, 0.0d);
  return(z);
}




inline double maxslXDDFOLD(double[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
     (0*shape(y) <= iv < shape(y))
                 : toD(y[lim-iv]);
       } :  fold( maxDDD, toD(mindouble()));
  return(z);
}


inline double plusslXDDFOLD(double[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
     (0*shape(y) <= iv < shape(y))
                 : toD(y[lim-iv]);
       } :  fold( plusDDD, toD(0));
  return(z);
}


inline double modXDD(double y)
{ return(abs(toD(y)));
}

inline int barXII(int y)
{ return(-y);
}

inline double divDDD(double x, double y)
{ dx = tod(x);
  dy = tod(y);
 if (dx == dy) 
     z = 1.0d;
  else 
    z = dx/dy;
  return(z);
}

inline bool eqDDB(double x, double y, double QUADct)
{ /* A=B on doubles */
 return((toD(x) == toD(y)) || APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline double maxDDD(double x, double y)
{ /* x max y */ 
 return (max(toD(x),toD(y)));
}

inline double plusDDD(double x, double y)
{ return(toD(x)+toD(y));
}

inline double[+] divDDD(double x, double[+] y)
{ /* SxA scalar function */
  xel = toD(x);
  z = with {
     ( . <= iv <= .) {
              yel = toD(y[iv]);
                    } : divDDD(xel,yel);
  } : genarray(shape(y), 0.0d);
  return(z);
}


inline double[+] mpyDDD(double[+] x, double y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : mpyDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline double[+] barDDD(double x, double[+] y)
{ /* SxA scalar function */
  xel = toD(x);
  z = with {
     ( . <= iv <= .) {
              yel = toD(y[iv]);
                    } : barDDD(xel,yel);
  } : genarray(shape(y), 0.0d);
  return(z);
}


inline double[+] barDDD(double[+] x, double y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : barDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline bool[+] eqIIB(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : eqIIB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline double[+] mpyDDDsl(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("mpyDDDsl(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : mpyDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline bool[.] comaXBB(bool[+] y)
{ /* Ravel of anything with rank>1 */
     z = reshape([prod(shape(y))],y);
       return(z);
}

inline int[*] indrfr(int fr, int[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
    (. <= iv <= .)
                 : indrfr0(X[iv], I);
   } : genarray(frameshape, cell);
 return(z);
}

inline int[*] indrfr0(int[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
   (. <= iv <= .)
                 : sel( I[iv], X);
      } : genarray(shape(I), cell);
 return(z);
}



inline int[*] indrfr(int fr, int[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,0);
 z = with {
       (. <= iv <= .)
                 : sel( I, X[iv]);
      } : genarray(frameshape, cell);
 return(z);
}


inline double[*] indrfr(int fr, double[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, 0.0d);
 z = with {
    (. <= iv <= .)
                 : indrfr0(X[iv], I);
   } : genarray(frameshape, cell);
 return(z);
}

inline double[*] indrfr0(double[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, 0.0d);
 z = with {
   (. <= iv <= .)
                 : sel( I[iv], X);
      } : genarray(shape(I), cell);
 return(z);
}



inline double[*] indrfr(int fr, double[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,0.0d);
 z = with {
       (. <= iv <= .)
                 : sel( I, X[iv]);
      } : genarray(frameshape, cell);
 return(z);
}


inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

inline int[.] DSFLenErrorCheck(int[.] sx, int[.] sy, char[.] whodunit)
{ /* Dyadic scalar fn length error check */
     z = sx;
#ifdef GENME
/* SAC bug #306 - side effect kills fold!  */
    if (any(sx != sy)) { /* Check that shapes match */
   show(tochar("APEX dyadic scalar function length error in function"));
  show(whodunit);
        show(sx); show(sy);
    }
#endif
     return(z);
}

inline int[+] ABC(int[+] I, int Xshape)
{ /* Array bounds checker for indexed ref  X[nonscalarI] and indexed assign */
 z = I;
#ifdef BOUNDSCHECKING
 bad = with {
     ((0*shape(z)) <= iv < shape(z))
                : (z[iv] < 0) || (z[iv] >= Xshape);
    }: fold(|, false);
 if (bad)
  print(tochar("APEX index error!"));
#endif
 return(z);
}

inline int ABC(int I, int Xshape)
{ /* Array bounds checker for indexed ref X[scalarI] and indexed assign */
 z = I;
#ifdef BOUNDSCHECKING
 /* This needs more thought... */
  if ( (I < 0) || (I >= Xshape)) {
         print(tochar("APEX index error!"));
  }
#endif
 return(z);
}

inline double[+] TRANSPOSE(double[+] y)
{ /* Generic monadic transpose */
  z = with {
        ( . <= iv <= .)
                 : y[reverse( iv)];
    }: genarray( reverse( shape(y)), 0.0d);
  return(z);
}

inline bool eqIIB(int x, int y)
{ /* A=B on non-doubles */
 return(toI(x) == toI(y));
}

inline bool SingularXBB(bool y ,double QUADct)
{ 
/*
 ?
*/
/* dsf scalar(s) */
A_25=divBBD(true,y);
 j_0=( A_25);
 /* dsf scalar(s) */
A_28=eqDBB(j_0,true,QUADct);
z_0=( A_28);
 return(z_0);
}

inline double[.,.] lsBDD(bool[.,.] b, double[.,.] a,double QUADct,int QUADio)
{ 
/*
 ?
*/
A_115=rhoXBI( b);
 A_116=dropBII(true,A_115);
 p_0=( A_116);
 A_118=rhoXDI( a);
 A_119=takeBII(true,A_118);
 m_0=( A_119);
 A_121=rhoXDI( a);
 A_122=takeIII(-1,A_121);
 A_123=rhoCII([:char],A_122);
 n_0=( A_123);
 A_126=iotaXII( n_0,QUADio);
 pp_0=( A_126);
 A_128=modXDD( a);
 A_129=maxslXDDFOLD( A_128);
 mv_0=( A_129);
 A_134=rhoXDI( a);
 A_135=rotrXII( A_134);
 A_136=rhoIDD(A_135,A_129);
 A_137=tranXDD( A_136);
 /* dsf Check needed */
A_138=divDDD(a,A_137);
 A_139=modXDD( A_138);
 A_140=maxsl1XDDFOLD( A_139);
 A_144=divXDD( A_140);
 factor_0=( A_144);
 A_146=rhoXDI( a);
 A_147=rhoIDD(A_146,factor_0);
 /* dsf Check needed */
A_148=mpyDDD(a,A_147);
 a_0=( A_148);
 /* dsf scalar(s) */
A_150=plusIII(n_0,p_0);
 np_0=( A_150);
 A_152=comaIII(m_0,A_150);
 A_153=takeIDD(A_152,a_0);
 a_1=( A_153);
 A_156=iotaXII( p_0,QUADio);
 /* dsf scalar(s) */
A_157=plusIII(n_0,A_156);
 A_158= ABC(toi(A_157)-QUADio,shape(a_1)[1]);
A_161=indsx1(a_1,A_158,b);
 a_2=( A_161);
 A_163=maxslXDDFOLD( mv_0);
 /* dsf scalar(s) */
A_167=starIID(16,-13);
 /* dsf scalar(s) */
A_168=mpyDDD(A_167,A_163);
 eps_0=( A_168);
 A_171=iotaXII( n_0,QUADio);
 A_CTR172_= 0;
A_CTR172z_ = (shape(A_171)[[0]])-1;
a_7=tod(a_2);
pp_2=toi(pp_0);
i_0=toi(0);
for(; A_CTR172_ <= A_CTR172z_; A_CTR172_++){
i_0 = A_171[[A_CTR172_]];
 A_178=comaIII(i_0,i_0);
 A_179=dropIDD(A_178,a_7);
 A_180=barXII( p_0);
 A_181=comaBII(false,A_180);
 A_182=dropIDD(A_181,A_179);
 A_183=modXDD( A_182);
 A_184=maxsl1XDDFOLD( A_183);
 mv_2=( A_184);
 A_189=maxslXDDFOLD( mv_2);
 /* dsf scalar(s) */
A_194=leDDB(eps_0,A_189,QUADct);
 A_196=SingularXBB( A_194,QUADct);
 sink_0=( A_196);
 A_198=maxslXDDFOLD( mv_2);
 A_204=iotaDDI(mv_2,A_198,QUADct,QUADio);
 /* dsf scalar(s) */
A_205=plusIII(i_0,A_204);
 pi_1=( A_205);
 A_207=comaIII(pi_1,i_0);
 A_208= ABC(toi(A_207)-QUADio,shape(pp_2)[0]);
A_210=indr(pp_2,A_208);
 A_211=comaIII(i_0,pi_1);
 A_212= ABC(toi(A_211)-QUADio,shape(pp_2)[0]);
A_214=inds1(pp_2,A_212,A_210);
 pp_2=( A_214);
 A_216=comaIII(pi_1,i_0);
 A_217= ABC(toi(A_216)-QUADio,shape(a_7)[1]);
A_220=indrfr(1,a_7,A_217);
 A_221=comaIII(i_0,pi_1);
 A_222= ABC(toi(A_221)-QUADio,shape(a_7)[1]);
A_225=indsx1(a_7,A_222,A_220);
 a_4=( A_225);
 A_227= ABC(toi(i_0)-QUADio,shape(a_4)[1]);
A_230=indrfr(1,a_4,A_227);
 A_231=dropIDD(i_0,A_230);
 A_232=modXDD( A_231);
 A_233=maxslXDDFOLD( A_232);
 A_237= ABC(toi(i_0)-QUADio,shape(a_4)[1]);
A_240=indrfr(1,a_4,A_237);
 A_241=dropIDD(i_0,A_240);
 A_242=modXDD( A_241);
 A_245=iotaDDI(A_242,A_233,QUADct,QUADio);
 /* dsf scalar(s) */
A_246=plusIII(i_0,A_245);
 pi_2=( A_246);
 A_248=comaIII(pi_2,i_0);
 A_250= ABC(toi(A_248)-QUADio,shape(a_4)[0]);
A_252=indr(a_4,A_250);
 A_253=comaIII(i_0,pi_2);
 A_255= ABC(toi(A_253)-QUADio,shape(a_4)[0]);
A_257=inds1x(a_4,A_255,A_252);
 a_5=( A_257);
 A_259= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_262=indrfr(1,a_5,A_259);
 A_263=dropIDD(i_0,A_262);
 /* dsf scalar(s) */
A_264=starDID(A_263,2);
 A_265=plusslXDDFOLD( A_264);
 sigma_0=( A_265);
 A_271= ABC(toi(i_0)-QUADio,shape(a_5)[0]);
A_270= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_273=a_5[[A_271,A_270]];
 aii_0=( A_273);
 /* dsf scalar(s) */
A_275=starDDD(sigma_0,0.5);
 /* dsf scalar(s) */
A_277=leBDB(false,aii_0,QUADct);
 /* dsf scalar(s) */
A_278=mpyIBI(2,A_277);
 /* dsf scalar(s) */
A_279=barBII(true,A_278);
 /* dsf scalar(s) */
A_280=mpyIDD(A_279,A_275);
 alfa_0=( A_280);
 A_283= ABC(toi(i_0)-QUADio,shape(a_5)[0]);
A_282= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_285=a_5[[A_283,A_282]];
 /* dsf scalar(s) */
A_286=barDDD(A_285,alfa_0);
 u_0=( A_286);
 /* dsf scalar(s) */
A_288=plusIBI(i_0,[false,true]);
 A_289=dropIDD(A_288,a_5);
 A_290= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_293=indrfr(1,a_5,A_290);
 /* dsf scalar(s) */
A_294=plusIBI(i_0,true);
 A_295=dropIDD(A_294,A_293);
 A_296=comaDDD(u_0,A_295);
 A_297=plusdotmpyDDDTRANSPOSE(A_296,A_289);
 ta_0=( A_297);
 /* dsf scalar(s) */
A_305=mpyDDD(aii_0,alfa_0);
 /* dsf scalar(s) */
A_306=barDDD(sigma_0,A_305);
 A_307=divXDD( A_306);
 tb_0=( A_307);
 /* dsf scalar(s) */
A_309=mpyDDD(tb_0,ta_0);
 A_310= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_313=indrfr(1,a_5,A_310);
 /* dsf scalar(s) */
A_314=plusIBI(i_0,true);
 A_315=dropIDD(A_314,A_313);
 A_316=comaDDD(u_0,A_315);
 A_317=jotdotmpyDDD(A_316,A_309);
 tc_0=( A_317);
 /* dsf scalar(s) */
A_325=plusIBI(i_0,[false,true]);
 A_326=dropIDD(A_325,a_5);
 /* dsf Check needed */
A_327=barDDD(A_326,tc_0);
 td_0=( A_327);
 A_330=iotaXII( np_0,QUADio);
 /* dsf scalar(s) */
A_331=plusIBI(i_0,true);
 A_332=dropIII(A_331,A_330);
 A_334=iotaXII( m_0,QUADio);
 A_335=dropIII(i_0,A_334);
 A_337= ABC(toi(A_335)-QUADio,shape(a_5)[0]);
A_336= ABC(toi(A_332)-QUADio,shape(a_5)[1]);
A_339=inds11(a_5,A_337,A_336,td_0);
 a_6=( A_339);
 A_342= ABC(toi(i_0)-QUADio,shape(a_6)[0]);
A_341= ABC(toi(i_0)-QUADio,shape(a_6)[1]);
A_344=inds00(a_6,A_342,A_341,alfa_0);
 a_7=( A_344);
 }
 A_347=comaIII(n_0,p_0);
 A_348=rhoIBB(A_347,false);
 z_0=( A_348);
 A_351=iotaXII( n_0,QUADio);
 A_352=rotrXII( A_351);
 A_CTR353_= 0;
A_CTR353z_ = (shape(A_352)[[0]])-1;
i_1=toi(i_0);
z_2=tod(z_0);
for(; A_CTR353_ <= A_CTR353z_; A_CTR353_++){
i_1 = A_352[[A_CTR353_]];
 A_357=iotaXII( n_0,QUADio);
 A_359= ABC(toi(i_1)-QUADio,shape(a_7)[0]);
A_358= ABC(toi(A_357)-QUADio,shape(a_7)[1]);
A_361=indr(indrfr(1,a_7,A_358),A_359);
 A_362=plusdotmpyDDDTRANSPOSE(A_361,z_2);
 A_370= ABC(toi(i_1)-QUADio,shape(a_7)[0]);
A_372=a_7[[A_370]];
 A_373=dropIDD(n_0,A_372);
 /* dsf Check needed */
A_374=barDDD(A_373,A_362);
 t1_0=( A_374);
 A_377= ABC(toi(i_1)-QUADio,shape(a_7)[0]);
A_376= ABC(toi(i_1)-QUADio,shape(a_7)[1]);
A_379=a_7[[A_377,A_376]];
 /* dsf scalar(s) */
A_380=divDDD(t1_0,A_379);
 A_382= ABC(toi(i_1)-QUADio,shape(z_2)[0]);
A_384=inds0x(z_2,A_382,A_380);
 z_2=( A_384);
 }
 A_388= ABC(toi(pp_2)-QUADio,shape(z_2)[0]);
A_390=inds1x(z_2,A_388,z_2);
 z_3=( A_390);
 A_392=rhoXDI( z_3);
 A_393=rotrXII( A_392);
 A_394=rhoIDD(A_393,factor_0);
 A_395=tranXDD( A_394);
 /* dsf Check needed */
A_396=mpyDDD(z_3,A_395);
 z_4=( A_396);
 return(z_4);
}

inline double[.,.] dmdBDD(bool[.,.] b, double[.,.] a,double QUADct,int QUADio)
{ 
/*
 ?
*/
A_27=rhoXBI( b);
 A_28=comaIBI(A_27,true);
 A_29=takeIII(2,A_28);
 A_30=rhoIBB(A_29,b);
 b_0=( A_30);
 A_34=lsBDD(b_0,a,QUADct,QUADio);
z_0=( A_34);
 return(z_0);
}

inline double[.,.] mmdXDD(double[.,.] a ,double QUADct,int QUADio)
{ 
/*
 ?
*/
A_23=rhoXDI( a);
 A_24=takeBII(true,A_23);
 A_26=iotaXII( A_24,QUADio);
 A_27=rhoXDI( a);
 A_28=takeBII(true,A_27);
 A_30=iotaXII( A_28,QUADio);
 A_31=jotdoteqIIB(A_30,A_26);
 A_41=dmdBDD(A_31,a,QUADct,QUADio);
z_0=( A_41);
 return(z_0);
}

inline double mdivXID(int n ,double QUADct,int QUADio)
{ 
/*
 ?
*/
/* dsf scalar(s) */
A_28=barDDD(1.5,0.5);
/* dsf scalar(s) */
A_29=plusIBI(n,true);
A_30=takeIDD(A_29,A_28);
 A_31=rhoIII(2,n);
 A_32=rhoIDD(A_31,A_30);
 x_0=( A_32);
 A_36=mmdXDD( x_0,QUADct,QUADio);
 A_37=modXDD( A_36);
 A_38=comaXDD( A_37);
 A_39=plusslXDDFOLD( A_38);
 r_0=( A_39);
 return(r_0);
}

int main()
{ 
/*
 ?
*/
n=CommandLineArgvXBI( true);
 QUADio_0=toi(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 QUADio_1=toi(( false));
 QUADpp_1=( 16);
 QUADpw_1=( 80);
 QUADrl_1=( 16807);
 A_57=mdivXID( n,QUADct_0,QUADio_1);
 r_0=( A_57);
 A_61=quadXDD( A_57,QUADpp_1,QUADpw_1);
 /* dsf scalar(s) */
A_63=eqDIB(r_0,n,QUADct_0);
/* dsf scalar(s) */
A_64=plusBBI(true,A_63);
 r_1=( A_64);
 A_68=quadXII( A_64,QUADpp_1,QUADpw_1);
 return(r_1);
}

