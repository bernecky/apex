
---------------------------------------------------------------------------
 SAC - Single Assignment C
---------------------------------------------------------------------------

Name:                    sac2c
Version:                 1.3.3-MijasCosta-581-g8d98d


DESCRIPTION:

    The sac2c compiler transforms SAC source code into executable programs
    (SAC programs) or into a SAC specific library format (SAC module and
    class implementations), respectively.
    
    The compilation process is performed in 4 separate stages:
      1. sac2c uses any C preprocessor to preprocess the given SAC source;
      2. sac2c itself transforms preprocessed SAC source code into C code;
      3. sac2c uses any C compiler to generate target machine code;
      4. sac2c uses any C linker to create an executable program
         or sac2c itself creates a SAC library file.
    
    When compiling a SAC program, sac2c stores the corresponding
    intermediate C code either in the file a.out.c in the current directory
    (default) or in the file <file>.c if <file> is specified using the -o
    option. Here, any absolute or relative path name may be used.
    The executable program is either written to the file a.out or to any
    file specified using the -o option.
    
    However, when compiling a SAC module/class implementation, the
    resulting SAC library is stored in the files <mod/class name>.a
    and  <mod/class name>.so in the current directory.
    In this case, the -o option may be used to specify a
    different directory but not a different file name.


INSTALLATION-SPECIFIC FEATURE SET:

 - default path to sac2crc: /usr/local/share/sac2c/1.3.3-MijasCosta-581-g8d98d/sac2crc_d
 - default path to libsac2c: /usr/local/libexec/sac2c/1.3.3-MijasCosta-581-g8d98d



SPECIAL OPTIONS:

    -h              Display this helptext.
    -help           Display this helptext.
    -copyright      Display copyright/disclaimer.
    -V              Display version identification.
    -VV             Display verbose version identification.

    -libstat        Print status information of the given SAC library file.
    -prsc           Print resource settings.

    -M              Makes sac2c print a list of dependencies of the given
                    file and exit.  Dependencies are objects and libraries that
                    will be needed to compile the given file: use/imports,
                    arguments of linkobj and linkwith pragmas.

    -C <name>       Print out a configuration parameter

    NOTE:
    When called with one of these options, sac2c does not perform
    any compilation steps.


GENERAL OPTIONS:

    -D <var>        Set preprocessor variable <var>.
    -D <var>=<val>  Set preprocessor variable <var> to <val>.
    -cppI <path>    Specify path for preprocessor includes.

    -I <path>       Specify additional SAC library source file path.
    -E <path>       Specify additional C library file path.
    -L <path>       Specify additional SAC library module path.
    -T <path>       Specify additional SAC library tree path.
    -Xc <flags>     Extra flags to pass to the C compiler for program/module code.
    -Xl <flags>     Extra flags to pass to the C linker for program/module code.
    -Xtc <flags>    Extra flags to pass to the C compiler for tree code.
    -Xtl <flags>    Extra flags to pass to the C linker for tree code.

    -o <name>       For compilation of programs:
                      Place executable code in the specified file.
                    For compilation of module/class implementations:
                      Write module tree to the specified directory.
    -olib <name>    For compilation of module/class implementations:
                      Write module code to the specified directory.
                      (if not specified, defaults to same as -o)
    -install        Exclusively for compilation of module/class
                    implementations:
                      Write to the central repository.

    -c              Generate C-file only; do not invoke C compiler.

    -v <n>          Specify verbose level:
                      0: error messages only
                      1: error messages and warnings
                      2: basic compile time information
                      3: full compile time information
                      4: even more compile time information
                    (default: 3)


BREAK OPTIONS:

    Break options allow you to stop the compilation process
    after a particular phase, subphase or cycle optimisation.
    By default the intermediate programm will be printed. You
    can visualize the syntax tree as well, and a new png file 
    will be created. But this behaviour may be influenced by 
    the following compiler options:
 
    -noPAB          Deactivates printing after break.
    -doPAB          Activates printing after break.
    -doVAB          Activates visualization of program after break.
                    Select different categories of funcion to print.
    -fVAB <format>  Output visualization in <format>. Default is PNG.
                    <format> must be supported by your dot installation,
                    run "dot -Tv" for a list of available formats.

    -b<spec>        Break after the compilation stage given
                    by <spec>, where <spec> follows the pattern
                    <phase>:<subphase>:<cyclephase>:<pass>.
                    The first three are from the list of
                    encodings below. The last one is a natural
                    number. Alternatively, a number can be used
                    for the phase, as well.


BREAK OPTION SPECIFIERS:

    scp | 1  : Loading SAC program
      loc      : Locating source code
      cpp      : Running C preprocessor
      prs      : Parsing input file

    pre | 2  : Preprocessing SAC program
      hs       : Hiding struct definitions behind typedefs and accessors
      iotc     : Introducing user-tracing calls
      zgwl     : Handling zero-generator with-loops
      mgwl     : Handling multi-generator with-loops
      mowl     : Handling multi-operator with-loops
      acn      : Resolving axis control and dot notation
      rsp      : Resolving pragma annotations
      obi      : Generating object initializers
      csgd     : Checking and simplifying generic definitions

    mod | 3  : Running module system
      prcl     : Parse runtime optimization commandline
      rsa      : Processing use and import statements
      ans      : Annotating namespaces
      gdp      : Gathering dependencies
      imp      : Retrieving imported symbols
      uss      : Retrieving used symbols
      asf      : Loading prelude functions
      rtfilter : Filter unneeded functions (runtime specialization)

    sim | 4  : Simplifying source code
      w2d      : Transforming while-loops into do-loops
      iucfb    : Insert user-defined constraint to function body
      ece      : Eliminating conditional expressions
      moe      : Handling multiple operator expressions
      flt      : Flattening nested expressions
      udt      : Processing user defined types
      gntc     : Generating nested type conversion functions
      ggtc     : Generating generic type conversion functions

    ptc | 5  : Converting to static single assignment form
      ivd      : Inserting variable declarations
      dmmls    : Mark local selects for distmem backend
      itc      : Converting type decls into type conversions
      cwf      : Creating wrapper functions
      gon      : Running global object analysis
      goi      : Generating global object initialiser
      rso      : Resolving global objects
      rrp      : Resolving reference parameters
      ewt      : Extending dispatch information
      l2f      : Eliminating loops and conditionals
      elf      : Extending LaC funs
      ssa      : Establishing static single assignment form

    tc  | 6  : Running type inference system
      esp      : Enforcing Specializations
      sossk    : Specialization Oracle for Static Shape Knowledge
      ti       : Running type inference system
      etv      : Eliminating Type Variables
      ebt      : Eliminating Bottom Types
      swr      : Splitting Wrappers

    exp | 7  : Processing exports
      exp      : Exporting symbols
      dfr      : Removing dead functions
      uid      : Set unique ids for generic functions
      ser      : Serializing syntax tree

    popt | 8  : Preparing for code optimization
      rgd      : Removing generic function definitions
      iif      : Restoring bodies of imported inline functions
      cspf     : MUTC Creating spawn functions
      cua      : Checking uniqueness annotations
      cuq      : Checking uniqueness
      cwb      : Creating Wrapper Bodies
      l2f      : Eliminating conditionals in wrapper code
      ssa      : Establishing static single assignment form in wrapper code
      dfc      : Trying to dispatch functions statically
      des      : Removing all structs
      eudt     : Eliminating User-Defined Types
      cse      : Applying common subexpression elimination
      dcr      : Removing dead code
      icc      : Inserting Conformity Checks
      ti       : Running type inference system
      etv      : Eliminating Type Variables
      ebt      : Eliminating Bottom Types

    ewl | 9  : Enhancing with-loops
      accu     : Introducing explicit accumulators
      adp      : Adding default partitions
      cf       : Applying constant folding
      cse      : Applying common subexpression elimination
      wlpg     : Generating full with-loop partitions
      wlbsc    : Ensuring structural constants for with-loop partition bounds

    opt | 10 : Running SAC optimizations
      dfr      : Removing dead functions
      inl      : Applying function inlining
      tgtl     : Transform gt and ge operators to lt and le operators
      dfr2     : Removing dead functions
      dcr      : Removing dead code
      dlir     : Applying do-loop invariant removal
      wlir     : Applying with-loop invariant removal
      glf      : Grouping local functions
      linl     : Inlining degenerated LaC functions
      cyc      : Optimization cycle
        cse      : Applying common subexpression elimination (fun based)
        ainl     : Determine candidate functions for inlining (fun based)
        ili      : Inferring loop invariant variables (fun based)
        tup      : Applying type upgrade (fun based)
        etv      : Eliminating Type Variables (fun based)
        ebt      : Eliminating Bottom Types (fun based)
        dfc      : Applying function call dispatch (fun based)
        inl      : Applying inlining (fun based)
        tgtl     : Transform gt and ge operators to lt and le operators (fun based)
        wlprop   : Applying with-loop propagation (fun based)
        ls       : Applying Loop Scalarization (fun based)
        lacsi    : Applying Loop & Conditional Argument Scalarization (fun based)
        lacso    : Applying Loop & Conditional Result Scalarization (fun based)
        cf       : Applying constant folding (fun based)
        linl     : Inlining degenerated LaC functions (fun based)
        vp       : Propagating variables (fun based)
        rea      : Reorder arguments of equality primitive function  (fun based)
        wlpg     : Generating full with-loop partitions (fun based)
        wlbsc    : Ensuring structural constants for with-loop partition bounds (fun based)
        wlsimp   : Simplifying with-loops (fun based)
        cwle     : Eliminate copy with-loops (fun based)
        wli      : Inferring foldable with-loops (fun based)
        wlf      : Applying with-loop folding (fun based)
        wlfssa   : Restoring SSA form after with-loop folding (fun based)
        dcr      : Applying dead code removal (fun based)
        linl2    : Inlining degenerated LaC functions (fun based)
        dlir     : Applying do-loop invariant removal (fun based)
        wlir     : Applying with-loop invariant removal (fun based)
        wls      : Applying with-loop scalarization (fun based)
        prfunr   : Applying prf unrolling (fun based)
        etc      : Eliminating typeconv primitives (fun based)
        xvp      : Propagating variables (fun based)
        xrea     : Reorder arguments of equality primitive function  (fun based)
        lur      : Applying loop unrolling (fun based)
        lurssa   : Restoring SSA form after loop unrolling (fun based)
        wlur     : Applying withloop unrolling (fun based)
        wlurssa  : Restoring SSA form after withloop unrolling (fun based)
        ctzg     : Comparison to zero conversion for guards (fun based)
        ctz      : Comparison to zero conversion (fun based)
        esd      : Eliminating subtraction and division operators (fun based)
        esdcf    : Applying constant folding (esd case) (fun based)
        esdcse   : Applying common subexpression elimination (esd case) (fun based)
        as       : Arithmetic Simplification (fun based)
        al       : Applying associative law (fun based)
        dl       : Applying distributive law (fun based)
        uesd     : Reintroducing subtraction and division operators (fun based)
        dcr2     : Applying dead code removal (fun based)
        linl3    : Inlining degenerated LaC functions (fun based)
        sisi     : Simplifying function signatures
        lof      : Lifting optimization flags
      saacyc   : Symbolic array attribute cycle 2
        isaa     : Inserting symbolic array attributes (fun based)
        ggs      : Generate guard solvers (fun based)
        ivesplit : Eliminating index vectors (split selections) (fun based)
        cse      : Eliminating common subexpressions (fun based)
        prfunr   : Applying prf unrolling (fun based)
        ili      : Inferring loop invariant variables (fun based)
        tup      : Applying type upgrade (fun based)
        etv      : Eliminating type variables (fun based)
        ebt      : Eliminating bottom types (fun based)
        dfc      : Applying function call dispatch (fun based)
        inl      : Applying inlining (fun based)
        tgtl     : Transform gt and ge operators to lt and le operators (fun based)
        wlprop   : Applying with-loop propagation (fun based)
        ls       : Applying Loop Scalarization (fun based)
        lacsi    : Applying Loop & Conditional Argument Scalarization (fun based)
        lacso    : Applying Loop & Conditional Result Scalarization (fun based)
        cf       : Applying constant folding (fun based)
        linl     : Inlining degenerated LaC functions (fun based)
        vp       : Propagating variables (fun based)
        rea      : Reorder arguments of equality primitive function  (fun based)
        wlpg     : Generating full with-loop partitions (fun based)
        wlbsc    : Unflattening WL-partition structural constants (fun based)
        wlsimp   : Simplifying with-loops (fun based)
        cwle     : Eliminate copy with-loops (fun based)
        wli      : Inferring foldable with-loops (fun based)
        wlf      : Applying with-loop folding (fun based)
        wlfssa   : Restoring SSA form after with-loop folding (fun based)
        ivexi    : Inserting index vector extrema (fun based)
        ivexp    : Propagating index vector extrema (fun based)
        petl     : Propagate extrema thru lacfuns (fun based)
        dlfr     : Removing dead local functions (fun based)
        pcse     : Eliminating common subexpressions for polyhedral optimizations (fun based)
        pdcr     : Removing dead code for polyhedral optimizations (fun based)
        ssawl    : Convert withids to SSA form (fun based)
        polys    : Polyhedral analysis setup (fun based)
        plur     : Polyhedral loop unrolling (fun based)
        pogo     : Polyhedral guard optimization (fun based)
        pwlf     : Polyhedral with loop folding (fun based)
        polyt    : Polyhedral analysis tear down (fun based)
        ussawl   : Convert withids from SSA form (fun based)
        awlfi    : Inferring algebraically foldable with-loops (fun based)
        cse2     : Eliminating common subexpressions (fun based)
        wlircubsl : Applying with-loop invariant removal for CUBSL (fun based)
        cubsl    : Slicing algebraically foldable with-loops (fun based)
        awlf     : Applying algebraic with-loop folding (fun based)
        dcr      : Removing dead code (fun based)
        linl2    : Inlining degenerated LaC functions (fun based)
        dlir     : Applying do-loop invariant removal (fun based)
        wlir     : Applying with-loop invariant removal (fun based)
        wls      : Applying with-loop scalarization (fun based)
        lur      : Applying loop unrolling (fun based)
        lurssa   : Restoring SSA form after loop unrolling (fun based)
        wlur     : Applying withloop unrolling (fun based)
        wlurssa  : Restoring SSA form after withloop unrolling (fun based)
        etc      : Eliminating typeconv primitives (fun based)
        ctzg     : Comparison to zero conversion for guards (fun based)
        ctz      : Comparison to zero conversion (fun based)
        esd      : Eliminating subtraction and division operators (fun based)
        as       : Arithmetic Simplification (fun based)
        esdcf    : Applying constant folding (esd case) (fun based)
        esdcse   : Applying common subexpression elimination (esd case) (fun based)
        al       : Applying associative law (fun based)
        dl       : Applying distributive law (fun based)
        uesd     : Reintroducing subtraction and division operators (fun based)
        safa     : Sorting associative function arguments (fun based)
        dcr2     : Removing dead code (fun based)
        linl3    : Inlining degenerated LaC functions (fun based)
        edfa     : Eliminating duplicate lacfun arguments (fun based)
        sisi     : Simplifying function signatures
        lof      : Lifting optimization flags
      dfr3     : Removing dead functions
      uctz     : Eliminating comparisons to zero
      wlbscnf2 : Unflattening WL-partition structural constants
      rgs      : Remove guard solvers
      vp2      : Propagating variables
      cse3     : Eliminating common subexpression
      dcr3     : Removing dead code
      uglf     : Ungrouping local functions
      tup      : Running final type inference
      etv      : Eliminating type variables
      ebt      : Eliminating bottom types
      cffinal  : Final round of constant folding
      wlfs     : Applying with-loop fusion
      wlfscse  : Eliminating common subexpressions after fusion
      wlfsdcr  : Removing dead code after fusion
      wlpg2    : Generating full with-loop partitions
      wrci     : Inferencing with-loop reuse candidates
      ivexc    : Cleaning up index vector extrema
      wlidx    : Annotating offset variable at with-loops
      ivesplit : Eliminating index vectors (split selections)
      ivesli   : Eliminating index vectors (split loop invariants)
      ivevp    : Propagating variables (for IVE)
      dcr4     : Removing dead code
      scyc     : Type stabilization cycle
        tup      : Applying type upgrade (fun based)
        etv      : Eliminating Type Variables (fun based)
        ebt      : Eliminating Bottom Types (fun based)
        cf       : Applying constant folding (fun based)
        vp       : Propagating variables (fun based)
        rea      : Reorder arguments of equality primitive function  (fun based)
        dfc      : Applying function call dispatch (fun based)
        lof      : Lifting optimization flags
      wlflt    : Trying to flatten multi-dimensional withloops
      esaa     : Eliminating symbolic array attributes
      dcr5     : Removing dead code
      scc      : Stripping conformity checks and dataflow guards
      tup2     : Applying type upgrade
      etv2     : Eliminating Type Variables
      ebt2     : Eliminating Bottom Types
      vp       : Propagating variables
      ls       : Applying Loop Scalarization
      lacsi    : Applying Loop & Conditional Argument Scalarization
      lacso    : Applying Loop & Conditional Result Scalarization
      wlsimp   : Simplifying with-loops
      tupls    : Applying type upgrade for LS/LACS
      etvls    : Eliminating Type Variables for LS/LACS
      ebtls    : Eliminating Bottom Types for LS/LACS
      cfls     : Applying constant folding for LS/LACS
      dlirls   : Applying do-loop invariant removal for LS/LACS
      wlirls   : Applying with-loop invariant removal for LS/LACS
      ussai    : Undo SSAIV Transform
      vpls     : Propagating variables for LS/LACS
      cpive    : Propagating constants for IVE
      cse2     : Eliminating common subexpression
      iveras   : Eliminating index vectors (reuse WL-offsets and scalarize)
      ivevp2   : Propagating variables (for IVERAS)
      dcr6     : Removing dead code
      dlir2    : Applying do-loop invariant removal
      wlir2    : Applying with-loop invariant removal
      fprc     : Filtering partial reuse candidates
      wllom    : Withloop lock optimization marking
      wllos    : Withloop lock optimization shifting
      dfc      : Applying final function call dispatch
      finalinl : Applying final inlining
      xtgtl    : Transform gt and ge operators to lt and le operators
      fdi      : Freeing dispatch information
      emrci    : Collect extended WL reuse candidates
      emrcf    : Filter extended WL reuse candidates
      emrl     : Lift allocations of WL using extended reuse candidates
      ts       : Displaying type specialisation statistics
      cs       : Displaying constraint resolution statistics
      stat     : Displaying optimisation statistics

    cuda | 11 : Automatic parallelisation for GPUs
      acuwl    : CUDA Annotate CUDA withloops
      cucm     : CUDA cost model
      pfd      : CUDA Partial folding
      scuf     : CUDA Split CUDA fold withloops
      cutem    : CUDA Tag execution mode
      cuskc    : CUDA Sink scalar code
      cucc     : CUDA Create cells
      cadt     : Change arrays to distributed type
      iwlmem   : CUDA Insert CUDA memory transfer primitives for withloops
      icsmem   : CUDA Insert CUDA memory transfer primitives for cudasts
      vp       : Propagating variables
      cp       : Propagating constants
      dcr      : Removing dead code
      sptn     : CUDA Split partitions
      acuptn   : CUDA Annotate CUDA partitions
      mtran    : CUDA Minimise the number of device-host data transfers
      daa      : CUDA Data access analysis
      stknl    : CUDA Create single threaded CUDA kernels
      emrci    : Collect extended WL reuse candidates
      emrcf    : Filter extended WL reuse candidates
      cumm     : Unify host and device memory when using CUDA managed memory
      cuad     : Introduce delays into asynchronous memory transfers
      cuade    : Expand delays of asynchronous memory transfers

    wlt | 12 : Transforming with-loop representation
      wlbsc    : Unflattening WL-partition structural constants
      wlsimp   : Simplifying with-loops
      wltr     : Transforming with-loop representation
      wlsd     : Splitting withloops by dimensions
      cse      : Applying common subexpression elimination
      rw3      : Remove unneeded With3s
      ass      : Add syncs
      ms       : Move syncs
      cudr     : CUDA Exploiting data reuse with cuda shared memory
      vp       : Propagating variables
      cp       : Propagating constants
      dcr      : Removing dead code

    mt3 | 13 : Running 3rd generation multithreading
      tem      : Tagging execution modes
      crwiw    : Creating with in with
      pem      : Propagating execution modes
      cdfg     : Creating data flow graph
      asmra    : Rearringing assignments
      crece    : Creating execution mode cells
      cegro    : Extending execution mode cells
      repfun   : Replicating functions
      mtdfr    : Removing superfluous functions
      concel   : Consolidating execution mode cells
      abort    : Aborting MT3 compilation

    tp  | 14 : Introducing task parallelization
      syn      : Add sync statements
      mss      : Move sync statements
      tff      : Tag function definitions
      tfa      : Tag function applications
      lva      : Do live variable analysis
      css      : Count spawns and syncs

    mem | 15 : Introducing memory management instructions
      ufiv     : Unshare index vectors in WL-folds
      cp       : Propagating constants
      cnstass  : CUDA Flatten generators
      asd      : AUD/SCL distinction
      copy     : Making copy operations explicit
      racc     : Removing alias results from conformity checks
      alloc    : Introducing explicit allocation statements 
      dcr      : Removing dead code
      rci      : Inferring reuse candidates
      ia       : Interface aliasing analysis
      lro      : Applying loop reuse optimization
      aa       : Aliasing analysis
      srce     : Removing non-local reuse-candidates
      frc      : Removing invalid reuse candidates
      sr       : Static reuse
      lao      : Applying loop allocation optimization
      rb       : Introducing reuse branches
      ipc      : Identifying in-place updates
      dr       : Exploiting data reuse
      pew3     : MUTC Prune empty with3
      dcr2     : Removing dead code again
      rc       : Running reference count inference
      rcm      : Reducing reference counting instructions
      rco      : Optimizing reference counting instructions
      re       : Removing reuse instructions

    iprof | 16 : Introduce profiling instruction
      pfap     : Profiling function applications

    dm  | 17 : Preparing for distributed memory execution
      dmisef   : Identifying functions with side effects

    ussa | 18 : Converting from static single assignment form
      ussa     : Converting from SSA form
      f2l      : Reintroducing loops and conditionals
      linl     : Inlining LaC functions
      rec      : Removing external code
      rera     : Restoring reference arguments
      reso     : Restoring global objects

    mt  | 19 : Running automatic parallelisation
      mtcm     : Running multithreading cost model
      mtstf    : Creating MT and ST functions
      mtspmdf  : Creating SPMD functions
      rmpr     : Filtering propagates
      mtrmi    : Restoring memory instructions
      mtdcr    : Removing dead code
      mtas     : Annotating scheduling information
      sspmdls  : Applying SPMD linksign pragma
      distcond : Creating distributed with-loop conditionals

    pc  | 20 : Preparing C code generation
      uw3      : Unroll With3
      msa      : MUTC Mark SubAlloc
      lw3      : MUTC Lifting With-Loop bodies into threads
      armp     : MUTC Add RC Mode PRF
      dmui     : MUTC Dynamic memory usage inference
      pknlg    : CUDA Prepare kernel generation
      mmv      : Marking memval identifiers
      rnb      : Remove noop branch
      imemdist : Insert memory transfer primitives for distributed variables
      ial      : Introduce availability loops for distributed variables
      cuasr    : CUDA Adjust return ids of single threaded kernel
      cuknl    : CUDA Create Cuda kernel functions
      dvr      : Removing obsolete variable declarations
      dst      : MUTC Computing static thread mapping
      sls      : Applying linksign pragma
      moi      : Manage object initialisers
      rcs      : Resolving code sharing in With-Loops
      tmft     : MUTC tag main function as thread function
      tft      : MUTC tag functions as thread functions if needed
      cfp      : MUTC create function pairs
      rtspec   : Runtime Specialization create wrapper entry functions
      msc      : Make Slow Clones
      fpc      : Reorganising function prototypes
      tcp      : Applying type conversions
      mng      : Mark NoOp Grids
      rid      : Consistently renaming identifiers
      ofp      : OpenMP find private variables
      mc       : Move constants to variable declaration
      pfg      : CUDA Prepare for loop generation
      dmisefa  : Identifying function applications with side effects for distributed memory backend
      dmisaa   : Identify sub-allocated arrays for the distributed memory backend

    cg  | 21 : Generating Code
      tp       : Tag preparation
      cpl      : Creating intermediate code macros
      pds      : Prepare distributed with-loop schedulers
      prt      : Generating C file(s)

    icc | 22 : Creating binary code
      frtr     : De-allocating syntax tree representation
      hdep     : Handling dependencies
      ivcc     : Invoking C compiler

    prof | 23 : Profiling report
      mem      : Generating memory reports


PRINTING OPTIONS:

    -print [adv]+
               Add internal AST information as comments to the program output.
               The following flags are supported:
                 a: Print all (same as dv).
                 d: Print specialization demand.
                 v: Print avis information.

    -printfun <fun_name>
               Uses <fun_name> as a compare token to selectively print only
               functions that match the <fun_name>. 
               Use in conjunction with -b 
                 Example usage: -b 5:goi -printfun foo

    -printfunsets [aiudwp]+
                Select different categories of funcion to print or visualize
                (if using -doVAB when break).
               Use in conjunction with -b 
               The following flags are supported:
                 a: Print/visualize all function(same as iudwp).
                 i: Print/visualize functions introduced by import statement.
                 u: Print/visualize functions introduced by use statement.
                 d: Print/visualize local-defined functions.
                 w: Print/visualize wrapper functions.
                 p: Print/visualize prelude functions.

    -printstart <phase_id> [-printstop <phase_id>]
               Will report end of phase output to files in the format
               a.out.<phase_id> unless -o <outfilename> option is specified
               in which case the output file format will be
               <outfilename>.<phase_id>

    -printstop <phase_id> 
               if this option is used printing will stop at this
               phase whilst compilation will continue until completion
               unless -b is used.

               NOTE: Local Funs associated with Fundefs will be printed
               after every fundef node.

    <phase_id>
               In the context of -printstart/-printstop options this describes
               the level of granularity that the output will appear in.
               For Example:
               -printstart 2 -printstop 4
                 Will report the state after the end of each phase in the range.
               -printstart 2:hs -printstop 2 || -printstop 2:csgd
                 Will report the state after the end of each sub phase in the range
                 2:hs -> 2:csgd.
               -printstart 11:cyc -printstop 11:cyc
                 Will report the state after each pass of the cyc cycle
               -printstart 11:cyc:cse -printstop 11:cyc:cse
                 Will report the state of each fundef node after a pass of
                 the given cyclephase. NOTE: it is recommended to use this in
                 conjunction with -printfun <fun_name> as the output could get BIG.



TYPE INFERENCE OPTIONS:

    -specmode <strat>  Specify function specialization strategy:
                         aks: try to infer all shapes statically,
                         akd: try to infer all ranks statically,
                         aud: do not specialize at all.
                         (default: aks)

    -maxspec <n>       Individual functions will be specialized at most <n> times.
                         (default: 20)


OPTIMIZATION OPTIONS:

    -enforceIEEE    Treat floating point arithmetic as defined in the IEEE-754
                    standard. In particular, this means
                      - disable some algebraic optimizations,
                      - disable segmentation and tiling of fold-with-loops,
                      - disable parallel execution of fold-with-loops.
                    Currently implemented for:
                      - associative law optimization,
                      - segmentation and tiling of fold-with-loops.

    -noreuse        Disable reuse inference in emm.

    -iveo <n>       Enable or disable certain index vector optimisations
                    <n> is a bitmask consisting of the following bits:
                      1: enable the usage of withloop offsets where possible
                      2: scalarise vect2offset operations where possible
                      3: try to optimise computations on index vectors
                      4: try to reuse offsets once computed
                    The iveo option to for testing, and is to be removed.

    -dossawl        This option, if enabled, forces all with-loop generator
                    and with-loop partition variables, to be unique (SSA form).
                    If disabled (the default setting), all with-loop
                    generators use the same index vector variables,
                    and no attempt is made to enforce SSA form.
    -extrema        This option, if enabled, allows the compiler to
                    use optimizations based on index variable extrema;
                    i.e., the minimum and maximum value that index variables
                    may take on. This option is deprecated.

    -no <opt>       Disable optimization technique <opt>.

    -do <opt>       Enable optimization technique <opt>.


    The following optimization techniques are currently supported:

     (A leading * identifies optimization enabled by default.)

      * ls      loop scalarization
        lacsi   loop & conditional arg scalarization
        lacso   loop & conditional result scalarization
      * dcr     dead code removal
      * cf      constant folding
      * dlir    do-loop invariant removal
      * wlir    with-loop invariant removal
      * ainl    function auto-inlining
      * inl     function inlining
      * lur     loop unrolling
      * wlur    with-loop unrolling
      * prfunr  prf unrolling
        lus     loop unswitching
      * cse     common subexpression elimination
      * dlfr    dead local function removal
      * dfr     dead function removal
        wlt     with-loop transformation
      * wlf     with-loop folding
        awlf    algebraic with-loop folding
        cubsl   hypercube slicing
      * ivecyc  index vector elimination in SAACYC
      * ive     index vector elimination
      * ivesli  loop invariant index computation splitting
        wlflt   withloop flattening
        ae      array elimination
      * dl      distributive law
      * rco     reference count optimization
      * uip     update-in-place analysis
      * dr      data reuse
      * ipc     in-place computation
        tsi     with-loop tile size inference
      * tsp     with-loop tile size pragmas
      * wlpg    with-loop partition generation
      * cp      constant propagation
      * vp      variable propagation
        rea     reorder arguments of equality operator
        tgtl    Transform gt and ge operator to lt and le operator
      * srf     static reuse / static free
        pr      partial reuse
      * phm     private heap management
      * aps     arena preselection
      * dpa     descriptor preallocation
      * msca    memory size cache adjustment
        ap      array padding
        apl     array placement
      * wls     with-loop scalarization
      * as      arithmetic simplification
      * al      associative law
      * edfa    eliminate duplicate fundef args
      * petl    propagate extrema in/out of lacfuns
      * etc     typeconv elimination
        sp      selection propagation
      * wlsimp  with-loop simplification
      * cwle    copy with-loop elimination
        wlfs    with-loop fusion
      * lro     loop reuse optimization
        lao     loop allocation optimization
        pra     polyhedra data reuse optimization
      * emrci   EMR candidate inference
        emrcic  EMR candidate inference for CUDA
      * emrcf   EMR candidate filtering
      * emrl    EMR loop memory optimisation
      * memrt   Minimize memcpy transfers for EMRL affected loop functions
        rnb     remove noop conditional branch in with-loops
      * rwo     memory reuse with offset
      * rip     memory reuse with in place selection
      * tup     type upgrade
        sisi    signature simplification
        dmmls   DISTMEM mark local selects
        dmgs    DISTMEM group selects
      * sde     subtraction / division elimination
      * wlprop  with-loop propagation
      * saa     use symbolic array attributes
      * cyc     run optimization cycle
      * scyc    run stabilization cycle
      * saacyc  run saa cycle
        wllo    run with-loop lock optimization
        rw3     MUTC remove with3 loops
      * ms      MUTC move syncs
      * uw3     MUTC unroll with3 loops
      * pew3    MUTC prune empty with3 loops
      * msa     MUTC mark suballoc as unique
      * armp    MUTC add rc mode prf
      * wlsd    withloop split dimension
        expar   CUDA expand parallel region
        scuf    CUDA split cuda fold withloop
        shr     CUDA shared memory reuse
        coal    CUDA device memory coalescing
        pad     CUDA shared memory padding
        lb      CUDA set kernel launch bound
        pfd     CUDA perform partial folding
      * memopt  CUDA minimize memory tranfers
        slpt    CUDA split partition
      * cumm    Unify host and device memory when using CUDA managed memory
      * cuprf   Perform prefetching for CUDA managed memory
        cuad    Introduce delayed CUDA memory transfers primitives
        cuade   Delay asynchronous CUDA memory transfers primitives
        ctzg    comparisons to zero for guards
      * ctz     comparisons to zero
      * uctz    eliminating comparisons to zero
      * ggs     generating guard solvers
        plur    polyhedral loop unrolling
        pogo    polyhedral guard optimization
        pwlf    polyhedral WLF
        wls_aggressiveaggressive loop scalarization
        sse     simplify symbiotic expressions
      * safa    sort associative fun arguments
      * scs     Symbolic Constant Simplification
      * sccf    Structural constant constant folding
      * saacf   SAA constant folding
      * scwlf   Simple composition AWLF
      * relcf   CF on relationals and guards
      * ewlcf   enhancing with-loop CF
        ssawl   SSA on with-loops

    NOTE:
     -no opt     disables all optimizations at once.
     -do opt     enables all optimizations at once.

    NOTE:
     Upper case letters may be used to indicate optimization techniques.

    NOTE:
     Command line arguments are evaluated from left to right, i.e.,
     "-no opt -do inl" disables all optimizations except for function inlining.

    NOTE:
     Some of the optimization techniques are parameterized by additional side
     conditions. They are controlled by the following options:

    -maxoptcyc <n>  Repeat optimization cycle max <n> times. After <n> cycles
                    all optimisations except for type upgrade and function dispatch
                    are disabled.
                      (default: 10)

    -maxrecinl <n>  Inline recursive function applications at most <n> times.
                      (default: 0)

    -maxlur <n>     Unroll loops having at most <n> iterations.
                      (default: 2)

    -maxwlur <n>    Unroll with-loops with at most <n> elements generator set
                    size.
                      (default: 9)

    -maxprfur <n>   Unroll built-in vector operations with at most <n> elements
                    generator set size.
                      (default: 6)

    -maxae <n>      Try to eliminate arrays with at most <n> elements.
                      (default: 4)

    -initmheap <n>  At program startup initially request <n> KB of heap memory
                    for master thread.
                      (default: 1024)

    -initwheap <n>  At program startup initially request <n> KB of heap memory
                    for each worker thread.
                      (default: 64)

    -inituheap <n>  At program startup initially request <n> KB of heap memory
                    for usage by all threads.
                      (default: 0)

    -aplimit <n>    Set the array padding resource allocation overhead limit
                    to <n> %.
                      (default: 10)

    -apdiag         Print additional information for array padding to file
                    "<outfile>.ap", where <outfile> is the name specified via
                    the "-o" option.

    -apdiagsize <n> Limit the amount of information written to the diagnostic
                    output file created via the -apdiag option to approximately
                    <n> lines.
                      (default: 20000)

    -dowls_aggressive Set WLS optimization level to aggressive.
                    WARNING:
                    Aggressive with-loop scalarization may have the opposite
                    effect as with-loop invariant removal and cause duplication
                    of code execution.

    -maxwls         Set the maximum number of inner with-loop elements for which
                    aggressive behaviour will be used even if -dowls_aggressive is
                    not given. (default: 1)

    -dofoldfusion   Enable fusion of with-loops with fold operator (default).
    -nofoldfusion   Disable fusion of with-loops with fold operator.

    -maxnewgens <n> Set the maximum number of new created generators while
                    intersection of generatorsets from two with-loops in
                    with-loop fusion to <n>.
                      (default: 100)

    -sigspec <strat>   Specify strategy for specialization of function sigantures:
                          akv: try to infer all values statically,
                          aks: try to infer all shapes statically,
                          akd: try to infer all ranks statically,
                          aud: do not specialize at all.
                          (default: aks)
    -force_naive    Make wlt always run in naive mode



MULTI-THREAD OPTIONS:

    -mt_barrier_type <mode>
                    Select barrier type for synchronization of threads:
                      spin:    (default) uses a spinlock technique to implement the 
                               barrier
                      mutex:   a barrier implementation solely based on mutex locks 
                               and counters
                      cond:    uses pthread_cond_wait to implement the barrier
                      pthread: uses the built-in POSIX thread barrier implementation
                      futex:   a barrier that uses the low level futex lock technique,
                               NOTE: FUTEX BARRIER IS ONLY AVAILABLE ON LINUX!

    -mt_bind <mode>
                    Select cpu binding strategy:
                      off:    (default) OS decides the mapping of threads to cores.

                      simple: bind to consecutive (wrt. hwloc idxs) cores

                      env:    use environment variables to define
                              SAC_NUM_SOCKETS the # of sockets to use
                              SAC_NUM_CORES the # of cores per socket to use
                              SAC_NUM_PUS the # of PUs per core to use

                      numa:   bind to PUs, evenly distributed over all NUMA nodes. 

                    socket:   bind to PUs, evenly distributed over all sockets.

    -mt_smart_mode <mode>
                    Select smart decision mode:
                      off:     (default) do not use the smart decision technique
                      train:   toggles the smart decision tool into training mode
                      on:      use smart decisions to optimize the number of threads
                               being used to compute spmd functions

    -mt_smart_filename <str>
                    Filename for smart decision database file.

    -mt_smart_arch <str>
                    The name of the computer architecture you are using.

    -mt_smart_period <n>
                    To be able to make smart decisions, a performance profile is being
                    created by performing a number of time measurements. This value is
                    an indication for the time (ms) a single measurement should take.
                    The real time can be a bit shorter or a bit longer.

    -mt_smart_gradient <n>
                    To be able to make smart decisions, a performance profile is being
                    created. This profile is used to create a performance graph for
                    each spmd function. The smart decision tool tries to find the point
                    on the performance graph where the gradient matches the
                    'mt_smart_gradient' value (degrees). This point on the performance
                    graph will be used to determine the optimal number of threads to
                    be used to parallelize the spmd function.

    -numthreads <n> Specify at compile time the exact number of threads to be
                    used for parallel execution.

    -maxthreads <n> Specify at compile time only an upper bound on the number
                    of threads to be used  for parallel execution when exact
                    number is determined at runtime.
                      (default: 128)

    -dofoldparallel Enable parallelization of fold with-loops (default).
    -nofoldparallel Disable parallelization of fold with-loops.

    -minmtsize <n>  Specify minimum generator set size for parallel execution
                    of with-loops.
                      (default: 250)

    -maxrepsize <n> Specify maximum size for arrays to be replicated as
                    private data of multiple threads.
                      (default: 250)


DISTRIBUTED MEMORY BACKEND OPTIONS (experimental):

    -dsm_maxmem_mb <n>     Maximum amount of memory to use for the DSM system in MB.
                           (default: 512 MB)

    -distmem_min_elems <n> Minimum number of array elements per node such that an array
                           gets distributed (default: 10 elements)

    -distmem_tr_pf_node <r> Only produce trace and profile output at the node with this rank (-1 = all nodes).
                            (default: -1 elements)

    -dmgs_min_selects <n> Minimum number of selects that have not been marked as local in the DMMLS
                          optimisation so that the DMGS optimisation is applied.
                          The value has to be at least 3 because otherwise it cannot pay off.
                          (default: 3 elements)

    -dmgs_max_selects <n> Maximum number of selects that have not been marked as local in the DMMLS
                          optimisation so that the DMGS optimisation is applied.
                          (default: 0 elements, 0 = unbounded)

    -dsm_cache_outside_seg Allocate the caches outside of the DSM memory segment when GASNet
                           is used. This requires Firehose to be disabled.
                           (By default, the caches are allocated within the DSM segment when GASNet is used.)

    -distmem_ptrs_desc   Keep pointers to the start of a distributed array at
                         every node in the array descriptor.

    -distmem_no_ptr_cache  Disables the pointer cache.



MUTC OPTIONS:

    -mutc_fun_threads                Convert all functions to thread functions
                                     and use singleton creates

    -mutc_thread_mem                 Use thread local memory every where not
                                     global memory

    -mutc_disable_thread_mem         Disable creation of thread local memory
    -mutc_benchmark                  Enable mutc benchmarking support

    -mutc_static_resource_management Staticly manage resources

    -mutc_force_block_size <n>       Force the block size to <n> for all
                                     creates
    -mutc_force_spawn_flags <s>      Force the flags to <s> for all spawns
    -mutc_distribute <mode>          Select a mode for distributing threads
                                     across cores. Possible modes are:

                                     toplevel : only distribute the top-evel
                                                create of a with3 nesting
                                     bounded :  distribute threads globally
                                                until at least <n> threads
                                                have been distributed. <n> is
                                                specified using the
                                                -mutc_distribute_arg option

    -mutc_distribute_arg             numerical argument for distribution modes.

    -mutc_unroll <n>                 Maximum with3 size to unroll(1)

    -mutc_suballoc_desc_one_level_up Allocate discs one level higher than they
                                     are used

    -mutc_rc_places <n>              Number of exclusive places to be used for
                                     reference counting operations(1)

    -mutc_rc_indirect                Perform reference counting operations using
                                     wrapper functions

    -mutc_seq_data_parallel          sequentialised data parallel code



BACKEND OPTIONS:

    -minarrayrep <class>
                    Specify the minimum array representation class used:
                      s: use all (SCL, AKS, AKD, AUD) representations,
                      d: use SCL, AKD, AUD representations only,
                      +: use SCL, AUD representations only,
                      *: use AUD representation only.
                    (default: s)

    -force_desc_size <n>
                    Force the size of the descriptor to n bytes

    -cuda_arch <sm>
                    Specify which CUDA architecture to generate code for:
                      sm10: for Tesla architecture
                      sm11: same as above
                      sm12: same as above
                      sm13: same as above
                      sm20: for Fermi architecture
                      sm35: for Kepler architecture
                      sm50: for Maxwell architecture
                      sm60: for Pascal architecture
                      sm61: same as above
                      sm70: for Volta architecture
                    (default: sm35)

    -cuda_async_mode <mode>
                    Specify synchronisation mode between host thread and CUDA:
                        nosync: do not synchronise at all
                        device: synchronise the entire device
                        stream: synchronise the stream
                      callback: synchronise the stream using callback
                    (default: device)

    -cuda_shape <1d>,<2d_x>,<2d_y>
                    Override the grid/block specification, given as:
                        1d: 1-dim block size
                      2d_x: 2-dim block size for the x-dim
                      2d_y: 2-dim block size for the y-dim
                    (default: depends on <cuda_arch> value)



DEBUG OPTIONS:

    -debug_rc       Enable reference counting debuging features
    -d treecheck    Check syntax tree for consistency with xml specification.
    -d memcheck     Check syntax tree for memory consistency.
    -d nofree       Don't free any memory.
    -d noclean      Don't initialize or clean memory before freeing.
    -d sancheck     Check syntax tree for structural consistency.
    -d lacfuncheck  Check syntax tree for single call property of LaC functions.
    -d nolacinline  Do not inline loop and conditional functions.
    -d nocleanup    Do not remove temporary files and directories.
    -d syscall      Show all system calls during compilation.
    -d cccall       Generate shell script ".sac2c" that contains C compiler
                    invocation.
                    This implies option "-d nocleanup".

    -stop           issue a SIGSTOP at the very beginning (usefull for OSX debugging).

    -chkfreq <n>    Frequency of treecheck and lacfuncheck:
                       0: no checks
                       1: after each phase
                       2: after each subphase
                       3: after each optimisation
                       4: after each function-based optimisation
                    Default: 2


OPTIONS FOR FRED FISH'S DBUG:

    -# t            Display trace information.
                    Each function entry and exit during program execution is
                    printed on the screen.

    -# d            Display debug output information.
                    Each DBUG_PRINT macro in the code will be executed.
                    Each DBUG_EXECUTE macro in the code will be executed.

    -# d,<str>      Restrict "-# d" option to DBUG_PRINT / DBUG_EXECUTE macros
                    which are tagged with the string <str> (no quotes).

    -# <f>/<t>/<o>  Restrict the effect of any Fred Fish DBUG package option <o>
                    to the range <f> to <t> of sac2c compiler phases.
                      (default: <f> = first compiler phase,
                                <t> = last compiler phase.)
                    All kinds of phases can be specified using a syntax
                    analogous to that of the -b option.


COMPILETIME FEEDBACK OPTIONS:

    -feedback [atcor]+
                    Perform some compile time analyses and output some user feedback.
                    The following flags are supported:
                      a: Analyse all (same as tcor).
                      t: Analyse the effectiveness of function specialisation.
                      c: Analyse the effectveness of static constraint resolution.
                      o: Analyse the effectiveness of the optimisation cycle.
                      r: Analyse the effectiveness of reference counting.


RUNTIME CHECK OPTIONS:

    -ecc            Insert explicit conformity checks at compile time.

    -check [acgtbmehdi]+
                    Incorporate runtime checks into executable program.
                    The following flags are supported:
                      a: Incorporate all available runtime checks.
                      c: Perform conformity checks.
                      g: Perform GPU error checks.
                      t: Check assignments for type violations.
                      b: Check array accesses for boundary violations.
                      m: Check success of memory allocations.
                      e: Check errno variable upon applications of
                         external functions.
                      h: Use diagnostic heap manager.
                      d: Perform checks for the distributed memory backend.
                         (Check that there are no illegal accesses to distributed
                         arrays.)
                      i: Use diagnostic heap manager for distributed memory backend.


RUNTIME TRACE OPTIONS:

    -trace [amrfpwstcd]+
                    Incorporate trace output generation into executable program.
                    The following flags are supported:
                      a: Trace all (same as mrfpwstcd).
                      m: Trace memory operations.
                      r: Trace reference counting operations.
                      f: Trace user-defined function calls.
                      p: Trace primitive function calls.
                      w: Trace with-loop execution.
                      s: Trace array accesses.
                      g: Trace CUDA runtime.
                      t: Trace multi-threading specific operations.
                      c: Trace runtime enviroment init/exit when
                         using SAC libraries in C programs.
                      d: Trace distributed memory run time.
                         (per element tracing only in combination with s)

    -utrace
                    Introduce user tracing calls.

RUNTIME PROFILING OPTIONS:

    -profile [afilwmocd]+
                    Incorporate profiling analysis into executable program.
                    The following flags are supported:
                      a: Analyse all (same as filwmod).
                      f: Analyse time spent in non-inline functions.
                      i: Analyse time spent in inline functions.
                      l: Analyse time spent in library functions.
                      w: Analyse time spent in with-loops.
                      m: Analyse number of memory operations.
                      o: Analyse number of primitive operations (FLOPS,INTOPS).
                      c: Analyse time spent in CUDA kernels.
                      d: Analyse performance of distributed memory backend.


CACHE SIMULATION OPTIONS:

    -cs             Enable runtime cache simulation.

    -csdefaults [sagbifp]+
                    This option sets default parameters for cache simulation.
                    These settings may be overridden when starting the analysis
                    of an application program:
                      s: simple cache simulation,
                      a: advanced cache simulation,
                      g: global cache simulation,
                      b: cache simulation on selected blocks,
                      i: immediate analysis of memory access data,
                      f: storage of memory access data in file,
                      p: piping of memory access data to concurrently running
                         analyser process.
                    The default simulation parameters are "sgp".

    -cshost <name>  This option specifies the host machine to run the additional
                    analyser process on when doing piped cache simulation.
                    This is very useful for single processor machines because
                    the rather limited buffer size of the pipe determines the
                    synchronisation distance of the two processes, i.e. the
                    application process and the analysis process. This results
                    in very frequent context switches when both processes are
                    run on the same processor, and consequently, degrades the
                    performance by orders of magnitude. So, when doing piped
                    cache simulation always be sure to do so either on a
                    multiprocessor or specify a different machine to run the
                    analyser process on. However, this only defines a default
                    which may be overridden by using this option when starting
                    the compiled application program.

    -csfile <name>  This option specifies a default file where to write the
                    memory access trace when performing cache simulation via
                    a file. This default may be overridden by using this option
                    when starting the compiled application program.
                    The general default name is "<executable_name>.cs".

    -csdir <name>   This option specifies a default directory where to write
                    the memory access trace file when performing cache
                    simulation via a file. This default may be overridden by
                    using this option when starting the compiled application
                    program.
                    The general default directory is the tmp directory specified
                    in your sac2crc file.


CACHE SIMULATION FEATURES:

    Simple cache simulation only counts cache hits and cache misses while
    advanced cache simulation additionally classifies cache misses into
    cold start, cross interference, self interference, and invalidation
    misses.

    Simulation results may be presented for the entire program run or more
    specifically for any code block marked by the following pragma:
        #pragma cachesim [tag]
    The optional tag allows to distinguish between the simulation results
    for various code blocks. The tag must be a string.

    Memory accesses may be evaluated with respect to their cache behaviour
    either immediately within the application process, stored in a file,
    or they may be piped to a concurrently running analyser process.
    Whereas immediate analysis usually is the fastest alternative,
    results, in particular for advanced analysis, are often inaccurate due
    to changes in the memory layout caused by the analyser. If you choose
    to write memory accesses to a file, beware that even for small programs
    to be analysed the amount of data may be quite large. However, once a
    memory trace file exists, it can be used to simulate different cache
    configurations without repeatedly running the application program
    itself. The simulation tool for memory access trace files is called
    'csima' and resides in the bin directory of your SAC installation.

    These default cache simulation parameters may be overridden when
    invoking the application program to be analysed by using the generic
    command line option
        -cs [sagbifp]+
    where the various flags have the same meaning as described for the
    "-csdefaults" compiler option.

    Cache parameters for up to 3 levels of caches may be provided as target
    specification in the sac2crc file. However, these only serve as a
    default cache specification which may well be altered when running the
    compiled SAC program with cache simulation enabled. This can be done
    using the following command line options:
        -cs[123] <size>[/<line size>[/<assoc>[/<write miss policy>]]].
    The cache size must be given in KBytes, the cache line size in
    Bytes. A cache size of 0 KB disables the corresponding cache level
    completely regardless of any other setting.
    Write miss policies are specified by a single letter:
        d: default (fetch on write)
        f: fetch on write
        v: write validate
        a: write around


LIBRARY OPTIONS:

    -linksetsize <n> Specify how many compiled C functions are stored within
                     a single C source file for further compilation and linking.
                     A large number here means that potentially many functions
                     need to be linked to an executable that are actually never
                     called. However, setting the linksetsize to 1 considerably
                     slows down the compilation of large SAC modules/classes
                     (default: 10)

                     NOTE:
                     A linksetsize of 0 means all functions are stored in a
                     a single file.

    -noprelude       Do not load the standard prelude library `sacprelude_d'.

    -on_demand_lib   Do prepare the library provided as source for on demand
                     compilation when needed by other source files.

    -notree          Avoid generating tree file when compiling a module or a class.


C-COMPILER OPTIONS:

    -g              Include debug information into object code.
    -gg             Same as `-g', with extra debug information included
                    into object code. (e.g. source line # mapping from
                    SAC source code, etc.)

    -O <n>          Specify the C compiler level of optimization.
                      0: no C compiler optimizations.
                      1: minor C compiler optimizations.
                      2: medium C compiler optimizations.
                      3: full C compiler optimizations.
                    (default: 0)

    -generic        Specify that the generated C code should be compiled
                    without any architecture specific optimisations. This
                    is useful when compiling for other systems.
                    NOTE: if this flag is not given, the C code will be
                          aggresively optimised to take advantage of the
                          current architecture.

                    NOTE:
                    The actual effects of these options are specific to
                    the C compiler used for code generation. Both the
                    choice of a C compiler as well as the mapping of these
                    generic options to compiler-specific optimization
                    options are determined via the sac2crc configuration
                    file. For details concerning sac2crc files see below
                    under "customization".


CUSTOMIZATION OPTIONS:

    -target <name>  Specify a particular compilation target.
    -t <name>       Compilation targets are used to customize sac2c for
                    various target architectures, operating systems, and C
                    compilers.

                    The target description is either read from the
                    installation specific file $PREFIX/share/sac2crc or
                    from a file named .sac2crc within the user's home
                    directory.

                  target list can be printed with -list-targets



ENVIRONMENT VARIABLES:

    The following environment variables are used by the SAC compiler suite:

    SAC2CRC         Invoke compiler with a specific configuration file.
    SAC_PARALLEL    (optional) specifies the number of threads to use.
    SAC_NUM_SOCKETS (optional) specifies the number of sockets to use.
    SAC_NUM_CORES   (optional) specifies the number of cores per socket to use.
    SAC_NUM_PUS     (optional) specifies the number of processing units (e.g
                    hardware threads) per core to use.
                    If SAC_NUM_SOCKETS, SAC_NUM_CORES or SAC_NUM_PUS are not
                    set or set to 0, threads will not be bound.


AUTHORS:

    The following people contributed their time and mind to create the
    SAC compiler suite (roughly in order of entering the project):

      Sven-Bodo Scholz
      Henning Wolf
      Arne Sievers
      Clemens Grelck
      Dietmar Kreye
      Soeren Schwartz
      Bjoern Schierau
      Helge Ernst
      Jan-Hendrik Schoeler
      Nico Marcussen-Wulff
      Markus Bradtke
      Borg Enders
      Kai Trojahner
      Michael Werner
      Stephan Herhut
      Karsten Hinckfuss
      Steffen Kuthe
      Jan-Henrik Baumgarten
      Robert Bernecky
      Theo van Klaveren
      Florian Buether
      Torben Gerhards
      Carl A Joslin
      Jing Guo
      Hraban Luyat
      Zheng Zhangzheng
      Aram Visser
      Tim van Deurzen
      Roeland Douma
      Oscar Leijendekker
      Miguel Diogo
      Jaroslav Sykora
      Edward Michniak
      Martin Hawes


CONTACT:

    WWW:    http://www.sac-home.org/
    E-Mail: info@sac-home.org


BUGS:

    Bugs??  We????

    SAC is a research project!

    SAC tools are platforms for scientific research rather than
    "products" for end users. Although we try to do our very best,
    you may well run into a compiler bug. So, we are happy to receive
    your bug reports (Well, not really "happy", but ...).


