use Array: all;
use Numerical : all;
use StdIO : all;
use CommandLine: all;
use String: {tochar,sscanf};
use Bits: all;

/* Compiled by APEX Version: /home/apex/apex2003/wss/sac3002.dws2009-04-11 16:49:16.908 */
/*
% This is the APEX stdlib.sis include file.
% Standard equates and constants for APL compiler
% Also standard coercion functions
*/

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

inline double divXDD(double y)
{ return(1.0/tod(y));
}

inline double[+] modXDD(double[+] y)
{ /* Monadic scalar functions on array */
  z = with {
   ( . <= iv <= .)
                : modXDD(toD(y[iv]));
         } : genarray(shape(y), 0.0d);
  return(z);
}

inline double[+] divXDD(double[+] y)
{ /* Monadic scalar functions on array */
  z = with {
   ( . <= iv <= .)
                : divXDD(toD(y[iv]));
         } : genarray(shape(y), 0.0d);
  return(z);
}

inline double divBBD(bool x, bool y)
{ dx = tod(x);
  dy = tod(y);
 if (dx == dy) 
     z = 1.0d;
  else 
    z = dx/dy;
  return(z);
}

inline bool eqDBB(double x, bool y, double QUADct)
{ /* A=B on doubles */
 return((toD(x) == toD(y)) || APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline double starIID(int x, int y)
{ return(pow(tod(x),tod(y)));
}

inline double mpyDDD(double x, double y)
{ return(toD(x)*toD(y));
}

inline bool leDDB(double x, double y, double QUADct)
{ /* Fuzzy <= */
 return((toD(x)<toD(y)) | APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline int plusIII(int x, int y)
{ return(toI(x)+toI(y));
}

inline double starDDD(double x, double y)
{ return(pow(tod(x),tod(y)));
}

inline bool leBDB(bool x, double y, double QUADct)
{ /* Fuzzy <= */
 return((toD(x)<toD(y)) | APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline int mpyIBI(int x, bool y)
{ return(toI(x)*toI(y));
}

inline int barBII(bool x, int y)
{ return(toI(x)-toI(y));
}

inline double mpyIDD(int x, double y)
{ return(toD(x)*toD(y));
}

inline double barDDD(double x, double y)
{ return(toD(x)-toD(y));
}

inline int plusIBI(int x, bool y)
{ return(toI(x)+toI(y));
}

inline int plusBII(bool x, int y)
{ return(toI(x)+toI(y));
}

inline bool eqDIB(double x, int y, double QUADct)
{ /* A=B on doubles */
 return((toD(x) == toD(y)) || APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline int plusBBI(bool x, bool y)
{ return(toI(x)+toI(y));
}

inline int[+] plusBII(bool x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline double[+] divDDD(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("divDDD(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : divDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline double[+] mpyDDD(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("mpyDDD(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : mpyDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline int[+] plusIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("plusIII(int[+],int[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toI(x[iv]);
                    yel = toI(y[iv]);
            } : plusIII(xel,yel);
        } : genarray(sx, 0);
  return(z);
}







inline double[+] starDID(double[+] x, int y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : starDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline int[+] plusIBI(int x, bool[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline double[+] mpyDDD(double x, double[+] y)
{ /* SxA scalar function */
  xel = toD(x);
  z = with {
     ( . <= iv <= .) {
              yel = toD(y[iv]);
                    } : mpyDDD(xel,yel);
  } : genarray(shape(y), 0.0d);
  return(z);
}


inline double[+] barDDD(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("barDDD(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : barDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline double[+] divDDD(double[+] x, double y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : divDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline int[.] rotrXII(int[.] y)
{ /* Vector reverse */
 n = shape(y);
 cell = 0;
 z = with {
         ( . <= iv <= .)
                : y[(n-1)-iv];
         } : genarray(n, cell);
 return(z);
}

inline double[.,.] tranXDD(double[.,.] y)
{ /* Transpose on rank-2 */
   z = { [i,j] -> y[j,i] };
       return(z);
}

inline double[.] comaXDD(double[+] y)
{ /* Ravel of anything with rank>1 */
     z = reshape([prod(shape(y))],y);
       return(z);
}

inline double[*] rhoIDD(int[.] x, double[+] y)
{ /* APEX vector x reshape, with item reuse */
  ix = toi(x);
  ry = comaXDD(y);
  zxrho = prod(ix); /* THIS NEEDS XRHO FOR CODE SAFETY!! */
  yxrho = shape(ry)[[0]];
  if( zxrho <= yxrho) { /* No element resuse case */
        z = take([zxrho],ry);
 } else {
        ncopies = zxrho/yxrho; /* # complete copies of y. */
        /* FIXME: y empty case !*/
        z = with {
          (. <= [i] <= .)
                        : y;
           } : genarray( [ncopies], y);
        /* Now append the leftover bits */
        z = comaXDD(z) ++ take([zxrho-(ncopies*yxrho)],ry);
 }
 return(reshape(ix,z));
}



inline int iotaDDI(double[.] x, double y,double QUADct,int QUADio)
{ /* Fuzzy Vector iota Scalar */
 sx = shape(x)[[0]];
 z = sx;
 for(i=0; i<sx; i++) {
   if (eqDDB(toD(x[[i]]),toD(y),QUADct)){
             z = i;
                 i = sx;
        }
 }
 return(z+QUADio);
}


inline bool[*] rhoIBB(int[.] x, bool y)
{ /* Vector reshape scalar to matrix) */
         zxrho = prod(toi(x)); /* Result element count */
       z = genarray([zxrho], y); /* allocate result */
        z = reshape(toi(x),z);
         return(z);
}

inline bool[*] rhoIBB(int[.] x, bool[+] y)
{ /* APEX vector x reshape, with item reuse */
  ix = toi(x);
  ry = comaXBB(y);
  zxrho = prod(ix); /* THIS NEEDS XRHO FOR CODE SAFETY!! */
  yxrho = shape(ry)[[0]];
  if( zxrho <= yxrho) { /* No element resuse case */
        z = take([zxrho],ry);
 } else {
        ncopies = zxrho/yxrho; /* # complete copies of y. */
        /* FIXME: y empty case !*/
        z = with {
          (. <= [i] <= .)
                        : y;
           } : genarray( [ncopies], y);
        /* Now append the leftover bits */
        z = comaXBB(z) ++ take([zxrho-(ncopies*yxrho)],ry);
 }
 return(reshape(ix,z));
}



inline int[.] rhoIII(int x, int y)
{ /* Scalar reshape scalar to vector) */
      z = genarray([toi(x)], y);
     return(z);
}

inline int[*] dropBII(bool x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[.] takeBII(bool x, int[.] y)
{ /* Scalar take vector */ 
  return(take([toi(x)], y));
}

inline int[.] takeIII(int x, int[.] y)
{ /* Scalar take vector */ 
  return(take([toi(x)], y));
}

inline double[*] dropIDD(int[.] x, double[*] y)
{ /* Vector drop non-scalar */
  /* FIXME: Assert  dim(y)  == shape(x)[0]; */
  /* e.g, (,5)drop iota 5  */
  return(drop(toi(x), y));
}

inline double[*] dropIDD(int x, double[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}

inline int[*] dropIII(int x, int[*] y)
{ /* Scalar drop non-scalar */
  return(drop([toi(x)], y));
}


inline bool[.] takeIBB(int x, bool y)
{ /* Scalar take scalar */
  return(take([toi(x)],[y]));
}


inline double[.] takeIDD(int x, double y)
{ /* Scalar take scalar */
  return(take([toi(x)],[y]));
}

inline int[2]  rhoXBI(bool[.,.] y)
{ /* Shape of matrix (rank-2) */
 return(shape(y));
}

inline int[2]  rhoXDI(double[.,.] y)
{ /* Shape of matrix (rank-2) */
 return(shape(y));
}

inline int[.] iotaXII(int[1] y, int QUADio)
{ /* Index generator on 1-element vector */
 /* HELP! Needs length error check */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y[[0]]));
  return( z);
}

inline double[*] quadXDD(double[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
  show(y);
       return(y);
}
inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
  show(y);
       return(y);
}
inline int[2] comaIII(int x, int y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline int[2] comaIBI(int x, bool y)
{/* SxS catenate first (or last) axis */
 return([toI(x)]++[toI(y)]);
}

inline int[.] comaIII(int[.] x, int[.] y)
{ /* VxV catenate first or last axis */
 return(toI(x)++toI(y));
}

inline int[.] comaIBI(int[.] x, bool y)
{/* VxS catenate first (or last) axis */
 return(toI(x)++[toI(y)]);
}

inline int[*] indr(int[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline double[*] indr(double[+] X)
{ /* X[;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[;;j;]
   */
 return(X);
}



inline double[*] indr(double[+] X, int I)
{ /* X[scalarI;;;] */
  /* Used only in conjunction with other indexing, e.g.,
   * X[scalarI;;j;]
   */
 z = X[[I]];
 return(z);
}




inline int[+] inds0(int[+] X, int  I0, int Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = toi(X);
 Y = Yin;

 
 z[[I0]]=toi(Y);

 
 return(z);
}



inline double[+] indsx0(double[+] X, int  I1, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 for(i0=0; i0<shape(X)[[0]]; i0++){

 z[[i0,I1]]=tod(Y[[i0]]);

 }

 return(z);
}



inline double[+] inds0x(double[+] X, int  I0, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 
 z[[I0]]=tod(Y);

 
 return(z);
}



inline double[+] inds0(double[+] X, int  I0, double Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = tod(X);
 Y = Yin;

 
 z[[I0]]=tod(Y);

 
 return(z);
}



inline double[+] inds11(double[+] X, int [+] I0,int [+] I1, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 for(i0=0; i0<shape(I0)[[0]]; i0++){
 for(i1=0; i1<shape(I1)[[0]]; i1++){

 z[[I0[[i0]],I1[[i1]]]]=tod(Y[[i0,i1]]);

 }
 }

 return(z);
}



inline double[+] inds1x(double[+] X, int [+] I0, double[+] Y)
{ /* X[;;nonscalarI;;;]<- nonscalarY */
  /* In function name indsXXX, XXX are ranks of various Is, or x if axis elided */
 
 z = tod(X);
 for(i0=0; i0<shape(I0)[[0]]; i0++){

 z[[I0[[i0]]]]=tod(Y[[i0]]);

 }

 return(z);
}



inline double[+] inds00(double[+] X, int  I0,int  I1, double Yin)
{ /* X[;;nonscalarI;;;]<- scalarY */
 
 z = tod(X);
 Y = Yin;

 
 z[[I0,I1]]=tod(Y);

 
 return(z);
}



inline int CommandLineArgvXBI(bool y)
{ /* Get Command-line argument element #y as integer scalar */
  int z;
  junk, z = sscanf(argv(toi(y)), "%d");
  return( z);
}

inline double[*] jotdotmpyDDD(double [+] x, double [+] y)
{ /* AxA outer product */
 cell = genarray(shape(y), 0.0d);
 z = with {
  (. <= iv <= .) {
        xitem = toD(x[iv]);
         } : mpyDDD(xitem, toD(y));
  } : genarray(shape(x), cell);
 return(z);
}

inline double[*] plusdotmpyDDDTRANSPOSE(double[.] x, double[*] y)
{ /* TRANSPOSE case of inner product z = vector_f.g y */
 yt = toD(TRANSPOSE(y));
 xct = toD(x);
 /* if (1 != shape(xct)[[0]]) FIXME; length error check */

 shp = drop([-1],shape(xct)) ++ drop([1], shape(y));
 z = with {
        (. <= iv <= .) {
               vx = xct[take([dim(x)-1], iv)];
                vy = yt[ reverse(take([1-dim(y)], iv))];
       } : plusslXDDFOLD(mpyDDDsl(vx,vy));
       } :genarray(shp, 0.0d);
 return(z);
}




inline double[+] maxslXDDFOLD(double[+] y)
{ /* last axis reduce rank-2 or greater matrix w/folding */
  sy = shape(y);
  zrho = drop([-1], sy);
  z = with {
        (. <= iv <= .)
               : maxslXDDFOLD(y[iv]);
   } : genarray(zrho, 0.0d);
  return(z);
}


inline double[.] maxsl1XDDFOLD(double[.,.] y)
{ /* first-axis reduce rank-2 matrix */
  yt = TRANSPOSE(y);
  zrho = drop([-1], shape(yt));
  z = with {
  (. <= iv <= .)
                 : maxslXDDFOLD(yt[iv]);
    } : genarray(zrho, 0.0d);
  return(z);
}




inline double maxslXDDFOLD(double[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
     (0*shape(y) <= iv < shape(y))
                 : toD(y[lim-iv]);
       } :  fold( maxDDD, toD(mindouble()));
  return(z);
}


inline double plusslXDDFOLD(double[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
     (0*shape(y) <= iv < shape(y))
                 : toD(y[lim-iv]);
       } :  fold( plusDDD, toD(0));
  return(z);
}


inline double modXDD(double y)
{ return(abs(toD(y)));
}

inline double divDDD(double x, double y)
{ dx = tod(x);
  dy = tod(y);
 if (dx == dy) 
     z = 1.0d;
  else 
    z = dx/dy;
  return(z);
}

inline bool eqDDB(double x, double y, double QUADct)
{ /* A=B on doubles */
 return((toD(x) == toD(y)) || APEXFUZZEQ(toD(x),toD(y),QUADct));
}


inline double maxDDD(double x, double y)
{ /* x max y */ 
 return (max(toD(x),toD(y)));
}

inline double plusDDD(double x, double y)
{ return(toD(x)+toD(y));
}

inline double[+] divDDD(double x, double[+] y)
{ /* SxA scalar function */
  xel = toD(x);
  z = with {
     ( . <= iv <= .) {
              yel = toD(y[iv]);
                    } : divDDD(xel,yel);
  } : genarray(shape(y), 0.0d);
  return(z);
}


inline double[+] mpyDDD(double[+] x, double y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : mpyDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline int[+] plusIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : plusIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] plusIII(int[+] x, int y)
{ /* AxS scalar function */
  yel = toI(y);
  z = with {
        ( . <= iv <= .) {
              xel = toI(x[iv]);
    } : plusIII(xel,yel);
  } : genarray( shape(x), 0);
  return(z);
}


inline double[+] barDDD(double x, double[+] y)
{ /* SxA scalar function */
  xel = toD(x);
  z = with {
     ( . <= iv <= .) {
              yel = toD(y[iv]);
                    } : barDDD(xel,yel);
  } : genarray(shape(y), 0.0d);
  return(z);
}


inline double[+] barDDD(double[+] x, double y)
{ /* AxS scalar function */
  yel = toD(y);
  z = with {
        ( . <= iv <= .) {
              xel = toD(x[iv]);
    } : barDDD(xel,yel);
  } : genarray( shape(x), 0.0d);
  return(z);
}


inline double[+] mpyDDDsl(double[+] x, double[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
   sx = DSFLenErrorCheck(shape(x), shape(y),tochar("mpyDDDsl(double[+],double[+]"));
        z = with {
             ( . <= iv <= .) {
                      xel = toD(x[iv]);
                    yel = toD(y[iv]);
            } : mpyDDD(xel,yel);
        } : genarray(sx, 0.0d);
  return(z);
}







inline int[.] comaXII(int[+] y)
{ /* Ravel of anything with rank>1 */
     z = reshape([prod(shape(y))],y);
       return(z);
}

inline bool[.] comaXBB(bool[+] y)
{ /* Ravel of anything with rank>1 */
     z = reshape([prod(shape(y))],y);
       return(z);
}

inline int[*] indrfr(int fr, int[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
    (. <= iv <= .)
                 : indrfr0(X[iv], I);
   } : genarray(frameshape, cell);
 return(z);
}

inline int[*] indrfr0(int[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, 0);
 z = with {
   (. <= iv <= .)
                 : sel( I[iv], X);
      } : genarray(shape(I), cell);
 return(z);
}



inline int[*] indrfr(int fr, int[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,0);
 z = with {
       (. <= iv <= .)
                 : sel( I, X[iv]);
      } : genarray(frameshape, cell);
 return(z);
}


inline double[*] indrfr(int fr, double[+] X, int[+] I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
  frameshape = take([fr], shape(X));
  cellshape =  shape(I)++drop([fr+1], shape(X));
  cell = genarray(cellshape, 0.0d);
 z = with {
    (. <= iv <= .)
                 : indrfr0(X[iv], I);
   } : genarray(frameshape, cell);
 return(z);
}

inline double[*] indrfr0(double[+] X, int[+] I)
{ /* X[I;;;] or    I from X */
  cellshape =  drop([1], shape(X));
  cell = genarray(cellshape, 0.0d);
 z = with {
   (. <= iv <= .)
                 : sel( I[iv], X);
      } : genarray(shape(I), cell);
 return(z);
}



inline double[*] indrfr(int fr, double[+] X, int I)
{ /* X[;;;I;;;], where I has fr (framerank) semicolons to its left */
  /* This is actually "I from"fr X" */
 frameshape = take([fr], shape(X));
 cellshape = drop([1+fr],shape(X));
 cell = genarray(cellshape,0.0d);
 z = with {
       (. <= iv <= .)
                 : sel( I, X[iv]);
      } : genarray(frameshape, cell);
 return(z);
}


inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

inline int[.] DSFLenErrorCheck(int[.] sx, int[.] sy, char[.] whodunit)
{ /* Dyadic scalar fn length error check */
     z = sx;
#ifdef GENME
/* SAC bug #306 - side effect kills fold!  */
    if (any(sx != sy)) { /* Check that shapes match */
   show(tochar("APEX dyadic scalar function length error in function"));
  show(whodunit);
        show(sx); show(sy);
    }
#endif
     return(z);
}

inline int ABC(int I, int Xshape)
{ /* Array bounds checker for indexed ref X[scalarI] and indexed assign */
 z = I;
#ifdef BOUNDSCHECKING
 /* This needs more thought... */
  if ( (I < 0) || (I >= Xshape)) {
         print(tochar("APEX index error!"));
  }
#endif
 return(z);
}

inline int[+] ABC(int[+] I, int Xshape)
{ /* Array bounds checker for indexed ref  X[nonscalarI] and indexed assign */
 z = I;
#ifdef BOUNDSCHECKING
 bad = with {
     ((0*shape(z)) <= iv < shape(z))
                : (z[iv] < 0) || (z[iv] >= Xshape);
    }: fold(|, false);
 if (bad)
  print(tochar("APEX index error!"));
#endif
 return(z);
}

inline double[+] TRANSPOSE(double[+] y)
{ /* Generic monadic transpose */
  z = with {
        ( . <= iv <= .)
                 : y[reverse( iv)];
    }: genarray( reverse( shape(y)), 0.0d);
  return(z);
}

inline bool SingularXBB(bool y ,double QUADct)
{ 
/*
 ?
*/
/* dsf scalar(s) */
A_25=divBBD(true,y);
 j_0=( A_25);
 /* dsf scalar(s) */
A_28=eqDBB(j_0,true,QUADct);
z_0=( A_28);
 return(z_0);
}

inline double[.,.] ls2BDD(bool[.,.] b, double[.,.] a,double QUADct,int QUADio)
{ 
/*
 ?
*/
A_139=rhoXBI( b);
 A_140=dropBII(true,A_139);
 p_0=( A_140);
 A_142=rhoXDI( a);
 A_143=takeBII(true,A_142);
 m_0=( A_143);
 A_145=rhoXDI( a);
 A_146=takeIII(-1,A_145);
 n_0=( A_146);
 A_149=iotaXII( n_0,QUADio);
 /* dsf scalar(s) */
A_150=plusBII(false,A_149);
 pp_0=( A_150);
 A_152=modXDD( a);
 A_153=maxslXDDFOLD( A_152);
 mv_0=( A_153);
 A_158=rhoXDI( a);
 A_159=rotrXII( A_158);
 A_160=rhoIDD(A_159,A_153);
 A_161=tranXDD( A_160);
 /* dsf Check needed */
A_162=divDDD(a,A_161);
 A_163=modXDD( A_162);
 A_164=maxsl1XDDFOLD( A_163);
 A_168=divXDD( A_164);
 factor_0=( A_168);
 A_170=rhoXDI( a);
 A_171=rhoIDD(A_170,factor_0);
 /* dsf Check needed */
A_172=mpyDDD(a,A_171);
 a_0=( A_172);
 /* dsf scalar(s) */
A_174=plusIII(n_0,p_0);
 np_0=( A_174);
 A_176=maxslXDDFOLD( mv_0);
 /* dsf scalar(s) */
A_180=starIID(16,-13);
 /* dsf scalar(s) */
A_181=mpyDDD(A_180,A_176);
 eps_0=( A_181);
 A_184=iotaXII( n_0,QUADio);
 A_CTR185_= 0;
A_CTR185z_ = (shape(A_184)[[0]])-1;
pp_3=toi(pp_0);
a_7=tod(a_0);
b_3=tod(b);
i_0=toi(0);
for(; A_CTR185_ <= A_CTR185z_; A_CTR185_++){
i_0 = A_184[[A_CTR185_]];
 A_193=comaIII(i_0,i_0);
 A_194=dropIDD(A_193,a_7);
 A_195=modXDD( A_194);
 A_196=maxsl1XDDFOLD( A_195);
 mv_2=( A_196);
 A_201=maxslXDDFOLD( mv_2);
 /* dsf scalar(s) */
A_206=leDDB(eps_0,A_201,QUADct);
 A_208=SingularXBB( A_206,QUADct);
 sink_0=( A_208);
 A_210=maxslXDDFOLD( mv_2);
 A_216=iotaDDI(mv_2,A_210,QUADct,QUADio);
 /* dsf scalar(s) */
A_217=plusIII(i_0,A_216);
 pi_1=( A_217);
 A_219= ABC(toi(i_0)-QUADio,shape(pp_3)[0]);
A_221=pp_3[[A_219]];
 tmp_1=( A_221);
 A_223= ABC(toi(pi_1)-QUADio,shape(pp_3)[0]);
A_225=pp_3[[A_223]];
 A_226= ABC(toi(i_0)-QUADio,shape(pp_3)[0]);
A_228=inds0(pp_3,A_226,A_225);
 pp_2=( A_228);
 A_230= ABC(toi(pi_1)-QUADio,shape(pp_2)[0]);
A_232=inds0(pp_2,A_230,tmp_1);
 pp_3=( A_232);
 A_234= ABC(toi(i_0)-QUADio,shape(a_7)[1]);
A_237=indrfr(1,a_7,A_234);
 tmp_2=( A_237);
 A_239= ABC(toi(pi_1)-QUADio,shape(a_7)[1]);
A_242=indrfr(1,a_7,A_239);
 A_243= ABC(toi(i_0)-QUADio,shape(a_7)[1]);
A_246=indsx0(a_7,A_243,A_242);
 a_2=( A_246);
 A_248= ABC(toi(pi_1)-QUADio,shape(a_2)[1]);
A_251=indsx0(a_2,A_248,tmp_2);
 a_3=( A_251);
 A_253= ABC(toi(i_0)-QUADio,shape(a_3)[1]);
A_256=indrfr(1,a_3,A_253);
 A_257=dropIDD(i_0,A_256);
 A_258=modXDD( A_257);
 A_259=maxslXDDFOLD( A_258);
 A_263= ABC(toi(i_0)-QUADio,shape(a_3)[1]);
A_266=indrfr(1,a_3,A_263);
 A_267=dropIDD(i_0,A_266);
 A_268=modXDD( A_267);
 A_271=iotaDDI(A_268,A_259,QUADct,QUADio);
 /* dsf scalar(s) */
A_272=plusIII(i_0,A_271);
 pi_2=( A_272);
 A_275= ABC(toi(i_0)-QUADio,shape(a_3)[0]);
A_277=a_3[[A_275]];
 tmp_3=( A_277);
 A_280= ABC(toi(pi_2)-QUADio,shape(a_3)[0]);
A_282=a_3[[A_280]];
 A_284= ABC(toi(i_0)-QUADio,shape(a_3)[0]);
A_286=inds0x(a_3,A_284,A_282);
 a_4=( A_286);
 A_289= ABC(toi(pi_2)-QUADio,shape(a_4)[0]);
A_291=inds0x(a_4,A_289,tmp_3);
 a_5=( A_291);
 A_294= ABC(toi(i_0)-QUADio,shape(b_3)[0]);
A_296=b_3[[A_294]];
 tmp_4=( A_296);
 A_299= ABC(toi(pi_2)-QUADio,shape(b_3)[0]);
A_301=b_3[[A_299]];
 A_303= ABC(toi(i_0)-QUADio,shape(b_3)[0]);
A_305=inds0x(b_3,A_303,A_301);
 b_1=( A_305);
 A_308= ABC(toi(pi_2)-QUADio,shape(b_1)[0]);
A_310=inds0x(b_1,A_308,tmp_4);
 b_2=( A_310);
 A_312= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_315=indrfr(1,a_5,A_312);
 A_316=dropIDD(i_0,A_315);
 /* dsf scalar(s) */
A_317=starDID(A_316,2);
 A_318=plusslXDDFOLD( A_317);
 sigma_0=( A_318);
 A_324= ABC(toi(i_0)-QUADio,shape(a_5)[0]);
A_323= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_326=a_5[[A_324,A_323]];
 aii_0=( A_326);
 /* dsf scalar(s) */
A_328=starDDD(sigma_0,0.5);
 /* dsf scalar(s) */
A_330=leBDB(false,aii_0,QUADct);
 /* dsf scalar(s) */
A_331=mpyIBI(2,A_330);
 /* dsf scalar(s) */
A_332=barBII(true,A_331);
 /* dsf scalar(s) */
A_333=mpyIDD(A_332,A_328);
 alfa_0=( A_333);
 A_335= ABC(toi(i_0)-QUADio,shape(a_5)[1]);
A_338=indrfr(1,a_5,A_335);
 A_339=dropIDD(i_0,A_338);
 tmp_5=( A_339);
 A_341= ABC(toi(false)-QUADio,shape(tmp_5)[0]);
A_343=tmp_5[[A_341]];
 /* dsf scalar(s) */
A_344=barDDD(A_343,alfa_0);
 A_345= ABC(toi(false)-QUADio,shape(tmp_5)[0]);
A_347=inds0(tmp_5,A_345,A_344);
 tmp_6=( A_347);
 /* dsf scalar(s) */
A_349=plusIBI(i_0,[false,true]);
 A_350=dropIDD(A_349,a_5);
 A_351=plusdotmpyDDDTRANSPOSE(tmp_6,A_350);
 newta_0=( A_351);
 A_359=comaIBI(i_0,false);
 A_360=dropIDD(A_359,b_2);
 A_361=plusdotmpyDDDTRANSPOSE(tmp_6,A_360);
 newtb_0=( A_361);
 /* dsf scalar(s) */
A_369=mpyDDD(aii_0,alfa_0);
 /* dsf scalar(s) */
A_370=barDDD(sigma_0,A_369);
 A_371=divXDD( A_370);
 tb_0=( A_371);
 /* dsf scalar(s) */
A_373=mpyDDD(tb_0,newta_0);
 A_374=jotdotmpyDDD(tmp_6,A_373);
 tc1_0=( A_374);
 /* dsf scalar(s) */
A_382=mpyDDD(tb_0,newtb_0);
 A_383=jotdotmpyDDD(tmp_6,A_382);
 tc2_0=( A_383);
 /* dsf scalar(s) */
A_391=plusIBI(i_0,[false,true]);
 A_392=dropIDD(A_391,a_5);
 /* dsf Check needed */
A_393=barDDD(A_392,tc1_0);
 td1_0=( A_393);
 A_395=comaIBI(i_0,false);
 A_396=dropIDD(A_395,b_2);
 /* dsf Check needed */
A_397=barDDD(A_396,tc2_0);
 td2_0=( A_397);
 A_400=iotaXII( n_0,QUADio);
 /* dsf scalar(s) */
A_401=plusIBI(i_0,true);
 A_402=dropIII(A_401,A_400);
 A_404=iotaXII( m_0,QUADio);
 A_405=dropIII(i_0,A_404);
 A_407= ABC(toi(A_405)-QUADio,shape(a_5)[0]);
A_406= ABC(toi(A_402)-QUADio,shape(a_5)[1]);
A_409=inds11(a_5,A_407,A_406,td1_0);
 a_6=( A_409);
 A_412=iotaXII( m_0,QUADio);
 A_413=dropIII(i_0,A_412);
 A_415= ABC(toi(A_413)-QUADio,shape(b_2)[0]);
A_417=inds1x(b_2,A_415,td2_0);
 b_3=( A_417);
 A_420= ABC(toi(i_0)-QUADio,shape(a_6)[0]);
A_419= ABC(toi(i_0)-QUADio,shape(a_6)[1]);
A_422=inds00(a_6,A_420,A_419,alfa_0);
 a_7=( A_422);
 }
 A_425=comaIII(n_0,p_0);
 A_426=rhoIBB(A_425,false);
 z_0=( A_426);
 A_429=iotaXII( n_0,QUADio);
 A_430=rotrXII( A_429);
 A_CTR431_= 0;
A_CTR431z_ = (shape(A_430)[[0]])-1;
i_1=toi(i_0);
z_2=tod(z_0);
for(; A_CTR431_ <= A_CTR431z_; A_CTR431_++){
i_1 = A_430[[A_CTR431_]];
 A_435= ABC(toi(i_1)-QUADio,shape(a_7)[0]);
A_437=a_7[[A_435]];
 A_438=plusdotmpyDDDTRANSPOSE(A_437,z_2);
 A_446= ABC(toi(i_1)-QUADio,shape(b_3)[0]);
A_448=b_3[[A_446]];
 /* dsf Check needed */
A_449=barDDD(A_448,A_438);
 t1_0=( A_449);
 A_452= ABC(toi(i_1)-QUADio,shape(a_7)[0]);
A_451= ABC(toi(i_1)-QUADio,shape(a_7)[1]);
A_454=a_7[[A_452,A_451]];
 /* dsf scalar(s) */
A_455=divDDD(t1_0,A_454);
 A_457= ABC(toi(i_1)-QUADio,shape(z_2)[0]);
A_459=inds0x(z_2,A_457,A_455);
 z_2=( A_459);
 }
 A_463= ABC(toi(pp_3)-QUADio,shape(z_2)[0]);
A_465=inds1x(z_2,A_463,z_2);
 z_3=( A_465);
 A_467=rhoXDI( z_3);
 A_468=rotrXII( A_467);
 A_469=rhoIDD(A_468,factor_0);
 A_470=tranXDD( A_469);
 /* dsf Check needed */
A_471=mpyDDD(z_3,A_470);
 z_4=( A_471);
 return(z_4);
}

inline double[.,.] dmd2BDD(bool[.,.] b, double[.,.] a,double QUADct,int QUADio)
{ 
/*
 ?
*/
A_27=rhoXBI( b);
 A_28=comaIBI(A_27,true);
 A_29=takeIII(2,A_28);
 A_30=rhoIBB(A_29,b);
 b_0=( A_30);
 A_34=ls2BDD(b_0,a,QUADct,QUADio);
z_0=( A_34);
 return(z_0);
}

inline double[.,.] mmd2XDD(double[.,.] a ,double QUADct,int QUADio)
{ 
/*
 ?
*/
A_31=rhoXDI( a);
 A_30= ABC(toi(false)-QUADio,shape(A_31)[0]);
A_33=A_31[[A_30]];
sz_0=( A_33);
 /* dsf scalar(s) */
A_35=plusBII(true,sz_0);
 A_36=takeIBB(A_35,true);
 A_37=rhoIII(2,sz_0);
 A_38=rhoIBB(A_37,A_36);
 id_0=( A_38);
 A_42=dmd2BDD(id_0,a,QUADct,QUADio);
 z_0=( A_42);
 return(z_0);
}

inline double mdiv2XID(int n ,double QUADct,int QUADio)
{ 
/*
 ?
*/
/* dsf scalar(s) */
A_28=barDDD(1.5,0.5);
/* dsf scalar(s) */
A_29=plusIBI(n,true);
A_30=takeIDD(A_29,A_28);
 A_31=rhoIII(2,n);
 A_32=rhoIDD(A_31,A_30);
 x_0=( A_32);
 A_36=mmd2XDD( x_0,QUADct,QUADio);
 A_37=modXDD( A_36);
 A_38=comaXDD( A_37);
 A_39=plusslXDDFOLD( A_38);
 r_0=( A_39);
 return(r_0);
}

int main()
{ 
/*
 ?
*/
n=CommandLineArgvXBI( true);
 QUADio_0=toi(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 QUADio_1=toi(( false));
 QUADpp_1=( 16);
 QUADpw_1=( 80);
 QUADrl_1=( 16807);
 A_57=mdiv2XID( n,QUADct_0,QUADio_1);
 r_0=( A_57);
 A_61=quadXDD( A_57,QUADpp_1,QUADpw_1);
 /* dsf scalar(s) */
A_63=eqDIB(r_0,n,QUADct_0);
/* dsf scalar(s) */
A_64=plusBBI(true,A_63);
 r_1=( A_64);
 A_68=quadXII( A_64,QUADpp_1,QUADpw_1);
 return(r_1);
}

