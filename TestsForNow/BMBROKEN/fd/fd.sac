use Array: all;
use StdIO : all;
use Numerical : all;
use CommandLine: all;
use String: {to_string,tochar,sscanf};
use ArrayFormat: all;
use Bits: all;

/* Compiled by APEX Version: /home/apex/apex3/wss/sac3013.dws2012-11-07 10:24:23.952 */
/*
% This is the APEX stdlib.sis include file.
% Standard equates and constants for APL compiler
% Also standard coercion functions
*/

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

#define BtoB(x) ((x))
#define ItoI(x) ((x))
#define DtoD(x) ((x))
#define CtoC(x) ((x))

#define BtoI(x) toi((x))
#define BtoD(x) tod((x))
#define ItoB(x) to_bool((x))
#define ItoD(x) tod((x))
#define DtoB(x) to_bool((x))
#define DtoI(x) toi((x))


inline bool eqIIB(int x, int y)
{ /* A=B on non-doubles */
 return(ItoI(x) == ItoI(y));
}

inline int barBBI(bool x, bool y)
{ return(BtoI(x)-BtoI(y));
}

inline bool[+] neIIB(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sx = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : neIIB(xel,yel);
        } : genarray(sx, false);
  return(z);
}






inline int[.] rotrIII(int x, int[.] y)
{ /* Scalar rotate first/last axis vector */
 ix = toi(x);
 rows = shape(y)[0];
 k = VectorRotateAmount(ix,rows); /* Normalize rotate count */
 z = drop( [k], y) ++ take( [k], y);
 return(z);
}


inline int[.] iotaXII(int y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline int[.]  rhoXBI(bool[+] y)
{ /* Shape of non-scalar */
 return(shape(y));
}

inline int[.] iotaXII(int[1] y, int QUADio)
{ /* Index generator on 1-element vector */
 /* HELP! Needs length error check */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y[[0]]));
  return( z);
}

inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline int plusdotmpyBIITRANSPOSE(bool[.] x, int[.] y)
{ /* Vector-Vector inner product */
  z =  plusslXIIFOLD(mpyIII(toI(x),toI(y)));
  return(z);
}



inline int[.] slIII(int x, int y)
{ /* Scalar replicate scalar */
 z = with {
        (. <= iv <= .)
                : y;
        } : genarray([toi(x)]);
 return(z);
}

inline int[.] slIII(int[.] x, int[.] y)
{/* Non-Boolean vector compress/replicate vector */
 /* HELP! non-boolean left argument needs a range check */
  intx = toi(x);
  zxrho = sum(intx);
  z = genarray([zxrho], 0);
  zi = 0;
  for(i=0; i<shape(x)[0]; i++)
    for(k=0; k<intx[[i]]; k++){
     z[[zi]] = y[[i]];
     zi++;
    }
  return(z);
}


inline bool neIIB(int x, int y)
{/* A !=B on non-doubles */
 return(ItoI(x) != ItoI(y));
}

inline bool[+] neIIB(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : neIIB(xel,yel);
  } : genarray(shape(y), false);
  return(z);
}


inline bool[+] neIIB(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : neIIB(xel,y);
  } : genarray( shape(x), false);
  return(z);
}


inline int[+] mpyIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
         sx = shape(y);
         z = with {
             ( . <= iv <= .) {
                      xel = x[iv];
                   yel = y[iv];
           } : mpyIII(xel,yel);
        } : genarray(sx, 0);
  return(z);
}






inline int[.] comaXII(int[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline int VectorRotateAmount(int x, int y)
{ /* Normalize x rotate for array of shape y on selected axis */
 /* normalize rotation count */

if ((0==x) || (0==y))
  z = 0;
else if (x>0)
        z = _mod_SxS_(x,y);
     else
        z = y - _mod_SxS_(abs(x),y);
 return(z);
}

inline int plusslXIIFOLD(int[.] y)
{ /* First/last axis fold-based reduction of vector */
  lim = shape(y)[0]-1;
  z = with {
        (0*shape(y) <= iv < shape(y))
                : ItoI(y[lim-iv]);
       } :  fold( plusIII, ItoI(0));
  return(z);
}


inline int mpyIII(int x, int y)
{ return(ItoI(x)*ItoI(y));
}

inline int plusIII(int x, int y)
{ return(ItoI(x)+ItoI(y));
}

inline int[+] mpyIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
     ( . <= iv <= .) {
              yel = toI(y[iv]);
                    } : mpyIII(xel,yel);
  } : genarray(shape(y), 0);
  return(z);
}


inline int[+] mpyIII(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
  ( . <= iv <= .) {
              xel = x[iv];
   } : mpyIII(xel,y);
  } : genarray( shape(x), 0);
  return(z);
}


inline bool[.] fdXIB(int[.] y )
{ 
/*
 ?
*/
A_19=rotrIII(-1,y);
 /* dsf clique */
A_21=neIIB(y,A_19);
r_0=( A_21);
 return(r_0);
}

inline int[.] testdataXII(int n ,int QUADio)
{ 
/*
 ?
*/
A_20=iotaXII( 10,QUADio);
A_21=slIII(10,n);
 A_22=slIII(A_21,A_20);
 r_0=( A_22);
 return(r_0);
}

inline int benchfdXII(int n ,int QUADio)
{ 
/*
 ?
*/
A_22=testdataXII( n,QUADio);
 A_23=fdXIB( A_22);
 r_0=( A_23);
 A_25=rhoXBI( r_0);
 A_27=iotaXII( A_25,QUADio);
 A_28=plusdotmpyBIITRANSPOSE(r_0,A_27);
 r_1=( A_28);
 return(r_1);
}

int main()
{ 
/*
 ?
*/
QUADio_0=toI(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 QUADio_1=toI(( false));
 n_0=( 3000000);
 QUADrl_1=( 16807);
 QUADpp_1=( 16);
 QUADpw_1=( 80);
 A_57=benchfdXII( n_0,QUADio_1);
 r_0=( A_57);
 A_61=quadXII( r_0,QUADpp_1,QUADpw_1);
 /* dsf scalar(s) */
A_63=eqIIB(r_0,135000000);
/* dsf scalar(s) */
A_64=barBBI(true,A_63);
 r_1=( A_64);
 A_68=quadXII( A_64,QUADpp_1,QUADpw_1);
 return(r_1);
}

