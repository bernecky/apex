module UTShapeCl;

use Array: all;
use ArrayFormat: all;
use Bits: all;
use Clock: {clock,mday,mon,year,to_time};
use CommandLine: all;
use Numerical : all;
use RTClock: all;
use StdIO : all;
use String: {to_string,tochar,sscanf};

/* Compiled by APEX Version: CLEAR WS 2021-02-25 17:11:14.692 */
/*
% This is the APEX stdlib.sis include file.
% Standard equates and constants for APL compiler
% Also standard coercion functions
*/

#define toB(x) to_bool((x))
#define toI(x) toi((x))
#define toD(x) tod((x))
#define toC(x) (x)
#define toc(x) ((x))

#define BtoB(x) ((x))
#define ItoI(x) ((x))
#define DtoD(x) ((x))
#define CtoC(x) ((x))

#define BtoI(x) toi((x))
#define BtoD(x) tod((x))
#define ItoB(x) to_bool((x))
#define ItoD(x) tod((x))
#define DtoB(x) to_bool((x))
#define DtoI(x) toi((x))


export all;

inline int barBBI(bool x, bool y)
{ return(BtoI(x)-BtoI(y));
}

inline int[+] plusIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
	sy = shape(y);
	z = with {
		( . <= iv <= .) {
			xel = x[iv];
			yel = y[iv];
		} : plusIII(xel,yel);
        } : genarray(sy, 0);
  return(z);
}






inline int[+] plusIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
	( . <= iv <= .) {
        	yel = toI(y[iv]);
      		} : plusIII(xel,yel);
	} : genarray(shape(y), 0);
  return(z);
}


inline int[+] modBII(bool x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
	( . <= iv <= .) {
        	yel = toI(y[iv]);
      		} : modIII(xel,yel);
	} : genarray(shape(y), 0);
  return(z);
}


inline int[+] barIII(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
	sy = shape(y);
	z = with {
		( . <= iv <= .) {
			xel = x[iv];
			yel = y[iv];
		} : barIII(xel,yel);
        } : genarray(sy, 0);
  return(z);
}






inline int[.] iotaXII(int y, int QUADio)
{ /* Index generator on scalar */
/* HELP! Needs domain check for negative shp */
  z = QUADio+iota(toi(y));
  return( z);
}

inline bool[*] quadXBB(bool[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline int[*] quadXII(int[*] y, int QUADpp, int QUADpw)
{ /* {quad}{<-} anything */
        show(y);
        return(y);
}
inline bool[2] comaBBB(bool x, bool y)
{/* SxS catenate first (or last) axis */
 return([toB(x)]++[toB(y)]);
}

inline bool sameIIB(int[+] x, int[+] y)
{ /* Non-scalar match non-scalar */
   z = (( _dim_A_( x) == _dim_A_( y))          &&
       ( all( _shape_A_( x) == _shape_A_( y))) &&
       ( all( eqIIB(toI( x),  toI( y)))));
  return(z);
}



inline bool andslXBBQUICKSTOP(bool[.] y)
{ /* First/last axis reduction of vector with quick stop*/
  z = with {
         (0*shape(y) <= iv < shape(y))
                : BtoB(y[iv]);
        } : foldfix( andBBB, ItoB(1), ItoB(0));
  return(z);
}


inline int plusIII(int x, int y)
{ return(ItoI(x)+ItoI(y));
}

inline int modIII(int x, int y)
{ /* SxS residue (aka modulo) */
  /* (x residue y) <-->   y-x times floor y divide x + 0 = x  */
  /* See model residueI in workspace UTDScalarI.dws */
  x = ItoI(x);
  y = ItoI(y);
  if( 0 != x) {
    q = y / x;
    z = y - ( x * q);
  } else {
    z = y;
  }

  if( z != 0) {
    if( mpyXII( x) != mpyXII( y)) {
      z = z + x;
    }
  }
 return(z);
}


inline int barIII(int x, int y)
{ return(ItoI(x)-ItoI(y));
}

inline bool andBBB(bool x, bool y)
{ return(BtoB(x)&BtoB(y));
}

inline int[+] plusIII(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
	( . <= iv <= .) {
		xel = x[iv];
	} : plusIII(xel,y);
	} : genarray( shape(x), 0);
  return(z);
}


inline int[+] barIII(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
	( . <= iv <= .) {
        	yel = toI(y[iv]);
      		} : barIII(xel,yel);
	} : genarray(shape(y), 0);
  return(z);
}


inline int[+] barIII(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
	( . <= iv <= .) {
		xel = x[iv];
	} : barIII(xel,y);
	} : genarray( shape(x), 0);
  return(z);
}


inline bool[+] eqIIB(int[+] x, int[+] y)
{ /* AxA Dyadic scalar fn, shapes may or may not match */
	sy = shape(y);
	z = with {
		( . <= iv <= .) {
			xel = x[iv];
			yel = y[iv];
		} : eqIIB(xel,yel);
        } : genarray(sy, false);
  return(z);
}






inline int[.] comaXII(int[+] y)
{ /* Ravel of anything with rank>1 */
  z = reshape([prod(shape(y))],y);
  return(z);
}

inline bool APEXFUZZEQ(double x, double y, double QUADct)
{ /* ISO APL Tolerant equality predicate */
 absx = abs(x);
 absy = abs(y);
 tolerance = QUADct * max(absx,absy);
 z = abs(x-y) <= tolerance;
 return(z);
}

inline int mpyXII(int y)
{ /* signum int/double */
   if( toI(0) == y) {
    z = 0;
  } else {
    if( toI(0) < y) {
      z = 1;
    } else {
      z = -1;
    }
  }
  return(z);
}

inline bool eqIIB(int x, int y)
{ /* A=B on non-doubles */
 return(ItoI(x) == ItoI(y));
}

inline bool[+] eqIIB(int x, int[+] y)
{ /* SxA scalar function */
  xel = toI(x);
  z = with {
	( . <= iv <= .) {
        	yel = toI(y[iv]);
      		} : eqIIB(xel,yel);
	} : genarray(shape(y), false);
  return(z);
}


inline bool[+] eqIIB(int[+] x, int y)
{ /* AxS scalar function */
  z = with {
	( . <= iv <= .) {
		xel = x[iv];
	} : eqIIB(xel,y);
	} : genarray( shape(x), false);
  return(z);
}


inline int UTShapeCl_mainXXI()
{ 
/*
 ?
*/
QUADio_0=toI(( false));
 QUADct_0=( 1.0e-13);
 QUADpp_0=( 10);
 QUADpw_0=( 80);
 QUADrl_0=( 16807);
 A_56=iotaXII( 5,QUADio_0);
 a_0=( A_56);
 b_0=( a_0);
 /* dsf clique */
A_59=plusIII(a_0,b_0);
 c_0=( A_59);
 A_62=iotaXII( 5,QUADio_0);
 /* dsf scalar(s) */
A_63=plusIII(2,A_62);
 /* dsf Check needed */
A_64=plusIII(a_0,A_63);
d_0=( A_64);
 /* dsf Check needed */
A_66=plusIII(d_0,a_0);
 e_0=( A_66);
 A_69=sameIIB([2, 5, 8, 11, 14],e_0);
 r_0=( A_69);
 /* dsf scalar(s) */
A_72=modBII(true,a_0);
 /* dsf clique */
A_73=barIII(a_0,A_72);
 A_75=sameIIB(a_0,A_73);
 A_76=comaBBB(r_0,A_75);
 r_1=( A_76);
 A_80=quadXBB( A_76,QUADpp_0,QUADpw_0);
 A_81=andslXBBQUICKSTOP( r_1);
 /* dsf scalar(s) */
A_85=barBBI(true,A_81);
 r_2=( A_85);
 A_89=quadXII( A_85,QUADpp_0,QUADpw_0);
 return(r_2);
}

